// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "featuresweep.h"

namespace prj
{
  namespace srl
  {
    // SweepProfile
    // 

    const SweepProfile::PickType& SweepProfile::
    pick () const
    {
      return this->pick_.get ();
    }

    SweepProfile::PickType& SweepProfile::
    pick ()
    {
      return this->pick_.get ();
    }

    void SweepProfile::
    pick (const PickType& x)
    {
      this->pick_.set (x);
    }

    void SweepProfile::
    pick (::std::unique_ptr< PickType > x)
    {
      this->pick_.set (std::move (x));
    }

    const SweepProfile::ContactType& SweepProfile::
    contact () const
    {
      return this->contact_.get ();
    }

    SweepProfile::ContactType& SweepProfile::
    contact ()
    {
      return this->contact_.get ();
    }

    void SweepProfile::
    contact (const ContactType& x)
    {
      this->contact_.set (x);
    }

    void SweepProfile::
    contact (::std::unique_ptr< ContactType > x)
    {
      this->contact_.set (std::move (x));
    }

    const SweepProfile::CorrectionType& SweepProfile::
    correction () const
    {
      return this->correction_.get ();
    }

    SweepProfile::CorrectionType& SweepProfile::
    correction ()
    {
      return this->correction_.get ();
    }

    void SweepProfile::
    correction (const CorrectionType& x)
    {
      this->correction_.set (x);
    }

    void SweepProfile::
    correction (::std::unique_ptr< CorrectionType > x)
    {
      this->correction_.set (std::move (x));
    }

    const SweepProfile::ContactLabelType& SweepProfile::
    contactLabel () const
    {
      return this->contactLabel_.get ();
    }

    SweepProfile::ContactLabelType& SweepProfile::
    contactLabel ()
    {
      return this->contactLabel_.get ();
    }

    void SweepProfile::
    contactLabel (const ContactLabelType& x)
    {
      this->contactLabel_.set (x);
    }

    void SweepProfile::
    contactLabel (::std::unique_ptr< ContactLabelType > x)
    {
      this->contactLabel_.set (std::move (x));
    }

    const SweepProfile::CorrectionLabelType& SweepProfile::
    correctionLabel () const
    {
      return this->correctionLabel_.get ();
    }

    SweepProfile::CorrectionLabelType& SweepProfile::
    correctionLabel ()
    {
      return this->correctionLabel_.get ();
    }

    void SweepProfile::
    correctionLabel (const CorrectionLabelType& x)
    {
      this->correctionLabel_.set (x);
    }

    void SweepProfile::
    correctionLabel (::std::unique_ptr< CorrectionLabelType > x)
    {
      this->correctionLabel_.set (std::move (x));
    }


    // SweepProfiles
    // 

    const SweepProfiles::ArraySequence& SweepProfiles::
    array () const
    {
      return this->array_;
    }

    SweepProfiles::ArraySequence& SweepProfiles::
    array ()
    {
      return this->array_;
    }

    void SweepProfiles::
    array (const ArraySequence& s)
    {
      this->array_ = s;
    }


    // SweepAuxiliary
    // 

    const SweepAuxiliary::PickType& SweepAuxiliary::
    pick () const
    {
      return this->pick_.get ();
    }

    SweepAuxiliary::PickType& SweepAuxiliary::
    pick ()
    {
      return this->pick_.get ();
    }

    void SweepAuxiliary::
    pick (const PickType& x)
    {
      this->pick_.set (x);
    }

    void SweepAuxiliary::
    pick (::std::unique_ptr< PickType > x)
    {
      this->pick_.set (std::move (x));
    }

    const SweepAuxiliary::CurvilinearEquivalenceType& SweepAuxiliary::
    curvilinearEquivalence () const
    {
      return this->curvilinearEquivalence_.get ();
    }

    SweepAuxiliary::CurvilinearEquivalenceType& SweepAuxiliary::
    curvilinearEquivalence ()
    {
      return this->curvilinearEquivalence_.get ();
    }

    void SweepAuxiliary::
    curvilinearEquivalence (const CurvilinearEquivalenceType& x)
    {
      this->curvilinearEquivalence_.set (x);
    }

    void SweepAuxiliary::
    curvilinearEquivalence (::std::unique_ptr< CurvilinearEquivalenceType > x)
    {
      this->curvilinearEquivalence_.set (std::move (x));
    }

    const SweepAuxiliary::ContactTypeType& SweepAuxiliary::
    contactType () const
    {
      return this->contactType_.get ();
    }

    SweepAuxiliary::ContactTypeType& SweepAuxiliary::
    contactType ()
    {
      return this->contactType_.get ();
    }

    void SweepAuxiliary::
    contactType (const ContactTypeType& x)
    {
      this->contactType_.set (x);
    }

    void SweepAuxiliary::
    contactType (::std::unique_ptr< ContactTypeType > x)
    {
      this->contactType_.set (std::move (x));
    }

    const SweepAuxiliary::CurvilinearEquivalenceLabelType& SweepAuxiliary::
    curvilinearEquivalenceLabel () const
    {
      return this->curvilinearEquivalenceLabel_.get ();
    }

    SweepAuxiliary::CurvilinearEquivalenceLabelType& SweepAuxiliary::
    curvilinearEquivalenceLabel ()
    {
      return this->curvilinearEquivalenceLabel_.get ();
    }

    void SweepAuxiliary::
    curvilinearEquivalenceLabel (const CurvilinearEquivalenceLabelType& x)
    {
      this->curvilinearEquivalenceLabel_.set (x);
    }

    void SweepAuxiliary::
    curvilinearEquivalenceLabel (::std::unique_ptr< CurvilinearEquivalenceLabelType > x)
    {
      this->curvilinearEquivalenceLabel_.set (std::move (x));
    }

    const SweepAuxiliary::ContactTypeLabelType& SweepAuxiliary::
    contactTypeLabel () const
    {
      return this->contactTypeLabel_.get ();
    }

    SweepAuxiliary::ContactTypeLabelType& SweepAuxiliary::
    contactTypeLabel ()
    {
      return this->contactTypeLabel_.get ();
    }

    void SweepAuxiliary::
    contactTypeLabel (const ContactTypeLabelType& x)
    {
      this->contactTypeLabel_.set (x);
    }

    void SweepAuxiliary::
    contactTypeLabel (::std::unique_ptr< ContactTypeLabelType > x)
    {
      this->contactTypeLabel_.set (std::move (x));
    }


    // SweepBinormal
    // 

    const SweepBinormal::PicksType& SweepBinormal::
    picks () const
    {
      return this->picks_.get ();
    }

    SweepBinormal::PicksType& SweepBinormal::
    picks ()
    {
      return this->picks_.get ();
    }

    void SweepBinormal::
    picks (const PicksType& x)
    {
      this->picks_.set (x);
    }

    void SweepBinormal::
    picks (::std::unique_ptr< PicksType > x)
    {
      this->picks_.set (std::move (x));
    }

    const SweepBinormal::BinormalType& SweepBinormal::
    binormal () const
    {
      return this->binormal_.get ();
    }

    SweepBinormal::BinormalType& SweepBinormal::
    binormal ()
    {
      return this->binormal_.get ();
    }

    void SweepBinormal::
    binormal (const BinormalType& x)
    {
      this->binormal_.set (x);
    }

    void SweepBinormal::
    binormal (::std::unique_ptr< BinormalType > x)
    {
      this->binormal_.set (std::move (x));
    }

    const SweepBinormal::BinormalLabelType& SweepBinormal::
    binormalLabel () const
    {
      return this->binormalLabel_.get ();
    }

    SweepBinormal::BinormalLabelType& SweepBinormal::
    binormalLabel ()
    {
      return this->binormalLabel_.get ();
    }

    void SweepBinormal::
    binormalLabel (const BinormalLabelType& x)
    {
      this->binormalLabel_.set (x);
    }

    void SweepBinormal::
    binormalLabel (::std::unique_ptr< BinormalLabelType > x)
    {
      this->binormalLabel_.set (std::move (x));
    }


    // InstanceValues
    // 

    const InstanceValues::ArraySequence& InstanceValues::
    array () const
    {
      return this->array_;
    }

    InstanceValues::ArraySequence& InstanceValues::
    array ()
    {
      return this->array_;
    }

    void InstanceValues::
    array (const ArraySequence& s)
    {
      this->array_ = s;
    }


    // Instance
    // 

    const Instance::KeyType& Instance::
    key () const
    {
      return this->key_.get ();
    }

    Instance::KeyType& Instance::
    key ()
    {
      return this->key_.get ();
    }

    void Instance::
    key (const KeyType& x)
    {
      this->key_.set (x);
    }

    void Instance::
    key (::std::unique_ptr< KeyType > x)
    {
      this->key_.set (std::move (x));
    }

    const Instance::ValuesType& Instance::
    values () const
    {
      return this->values_.get ();
    }

    Instance::ValuesType& Instance::
    values ()
    {
      return this->values_.get ();
    }

    void Instance::
    values (const ValuesType& x)
    {
      this->values_.set (x);
    }

    void Instance::
    values (::std::unique_ptr< ValuesType > x)
    {
      this->values_.set (std::move (x));
    }


    // InstanceMap
    // 

    const InstanceMap::ArraySequence& InstanceMap::
    array () const
    {
      return this->array_;
    }

    InstanceMap::ArraySequence& InstanceMap::
    array ()
    {
      return this->array_;
    }

    void InstanceMap::
    array (const ArraySequence& s)
    {
      this->array_ = s;
    }


    // FeatureSweep
    // 

    const FeatureSweep::FeatureBaseType& FeatureSweep::
    featureBase () const
    {
      return this->featureBase_.get ();
    }

    FeatureSweep::FeatureBaseType& FeatureSweep::
    featureBase ()
    {
      return this->featureBase_.get ();
    }

    void FeatureSweep::
    featureBase (const FeatureBaseType& x)
    {
      this->featureBase_.set (x);
    }

    void FeatureSweep::
    featureBase (::std::unique_ptr< FeatureBaseType > x)
    {
      this->featureBase_.set (std::move (x));
    }

    const FeatureSweep::LawFunctionType& FeatureSweep::
    lawFunction () const
    {
      return this->lawFunction_.get ();
    }

    FeatureSweep::LawFunctionType& FeatureSweep::
    lawFunction ()
    {
      return this->lawFunction_.get ();
    }

    void FeatureSweep::
    lawFunction (const LawFunctionType& x)
    {
      this->lawFunction_.set (x);
    }

    void FeatureSweep::
    lawFunction (::std::unique_ptr< LawFunctionType > x)
    {
      this->lawFunction_.set (std::move (x));
    }

    const FeatureSweep::TrihedronType& FeatureSweep::
    trihedron () const
    {
      return this->trihedron_.get ();
    }

    FeatureSweep::TrihedronType& FeatureSweep::
    trihedron ()
    {
      return this->trihedron_.get ();
    }

    void FeatureSweep::
    trihedron (const TrihedronType& x)
    {
      this->trihedron_.set (x);
    }

    void FeatureSweep::
    trihedron (::std::unique_ptr< TrihedronType > x)
    {
      this->trihedron_.set (std::move (x));
    }

    const FeatureSweep::TransitionType& FeatureSweep::
    transition () const
    {
      return this->transition_.get ();
    }

    FeatureSweep::TransitionType& FeatureSweep::
    transition ()
    {
      return this->transition_.get ();
    }

    void FeatureSweep::
    transition (const TransitionType& x)
    {
      this->transition_.set (x);
    }

    void FeatureSweep::
    transition (::std::unique_ptr< TransitionType > x)
    {
      this->transition_.set (std::move (x));
    }

    const FeatureSweep::ForceC1Type& FeatureSweep::
    forceC1 () const
    {
      return this->forceC1_.get ();
    }

    FeatureSweep::ForceC1Type& FeatureSweep::
    forceC1 ()
    {
      return this->forceC1_.get ();
    }

    void FeatureSweep::
    forceC1 (const ForceC1Type& x)
    {
      this->forceC1_.set (x);
    }

    void FeatureSweep::
    forceC1 (::std::unique_ptr< ForceC1Type > x)
    {
      this->forceC1_.set (std::move (x));
    }

    const FeatureSweep::SolidType& FeatureSweep::
    solid () const
    {
      return this->solid_.get ();
    }

    FeatureSweep::SolidType& FeatureSweep::
    solid ()
    {
      return this->solid_.get ();
    }

    void FeatureSweep::
    solid (const SolidType& x)
    {
      this->solid_.set (x);
    }

    void FeatureSweep::
    solid (::std::unique_ptr< SolidType > x)
    {
      this->solid_.set (std::move (x));
    }

    const FeatureSweep::UseLawType& FeatureSweep::
    useLaw () const
    {
      return this->useLaw_.get ();
    }

    FeatureSweep::UseLawType& FeatureSweep::
    useLaw ()
    {
      return this->useLaw_.get ();
    }

    void FeatureSweep::
    useLaw (const UseLawType& x)
    {
      this->useLaw_.set (x);
    }

    void FeatureSweep::
    useLaw (::std::unique_ptr< UseLawType > x)
    {
      this->useLaw_.set (std::move (x));
    }

    const FeatureSweep::SpineType& FeatureSweep::
    spine () const
    {
      return this->spine_.get ();
    }

    FeatureSweep::SpineType& FeatureSweep::
    spine ()
    {
      return this->spine_.get ();
    }

    void FeatureSweep::
    spine (const SpineType& x)
    {
      this->spine_.set (x);
    }

    void FeatureSweep::
    spine (::std::unique_ptr< SpineType > x)
    {
      this->spine_.set (std::move (x));
    }

    const FeatureSweep::ProfilesType& FeatureSweep::
    profiles () const
    {
      return this->profiles_.get ();
    }

    FeatureSweep::ProfilesType& FeatureSweep::
    profiles ()
    {
      return this->profiles_.get ();
    }

    void FeatureSweep::
    profiles (const ProfilesType& x)
    {
      this->profiles_.set (x);
    }

    void FeatureSweep::
    profiles (::std::unique_ptr< ProfilesType > x)
    {
      this->profiles_.set (std::move (x));
    }

    const FeatureSweep::AuxiliaryType& FeatureSweep::
    auxiliary () const
    {
      return this->auxiliary_.get ();
    }

    FeatureSweep::AuxiliaryType& FeatureSweep::
    auxiliary ()
    {
      return this->auxiliary_.get ();
    }

    void FeatureSweep::
    auxiliary (const AuxiliaryType& x)
    {
      this->auxiliary_.set (x);
    }

    void FeatureSweep::
    auxiliary (::std::unique_ptr< AuxiliaryType > x)
    {
      this->auxiliary_.set (std::move (x));
    }

    const FeatureSweep::SupportType& FeatureSweep::
    support () const
    {
      return this->support_.get ();
    }

    FeatureSweep::SupportType& FeatureSweep::
    support ()
    {
      return this->support_.get ();
    }

    void FeatureSweep::
    support (const SupportType& x)
    {
      this->support_.set (x);
    }

    void FeatureSweep::
    support (::std::unique_ptr< SupportType > x)
    {
      this->support_.set (std::move (x));
    }

    const FeatureSweep::BinormalType& FeatureSweep::
    binormal () const
    {
      return this->binormal_.get ();
    }

    FeatureSweep::BinormalType& FeatureSweep::
    binormal ()
    {
      return this->binormal_.get ();
    }

    void FeatureSweep::
    binormal (const BinormalType& x)
    {
      this->binormal_.set (x);
    }

    void FeatureSweep::
    binormal (::std::unique_ptr< BinormalType > x)
    {
      this->binormal_.set (std::move (x));
    }

    const FeatureSweep::TrihedronLabelType& FeatureSweep::
    trihedronLabel () const
    {
      return this->trihedronLabel_.get ();
    }

    FeatureSweep::TrihedronLabelType& FeatureSweep::
    trihedronLabel ()
    {
      return this->trihedronLabel_.get ();
    }

    void FeatureSweep::
    trihedronLabel (const TrihedronLabelType& x)
    {
      this->trihedronLabel_.set (x);
    }

    void FeatureSweep::
    trihedronLabel (::std::unique_ptr< TrihedronLabelType > x)
    {
      this->trihedronLabel_.set (std::move (x));
    }

    const FeatureSweep::TransitionLabelType& FeatureSweep::
    transitionLabel () const
    {
      return this->transitionLabel_.get ();
    }

    FeatureSweep::TransitionLabelType& FeatureSweep::
    transitionLabel ()
    {
      return this->transitionLabel_.get ();
    }

    void FeatureSweep::
    transitionLabel (const TransitionLabelType& x)
    {
      this->transitionLabel_.set (x);
    }

    void FeatureSweep::
    transitionLabel (::std::unique_ptr< TransitionLabelType > x)
    {
      this->transitionLabel_.set (std::move (x));
    }

    const FeatureSweep::ForceC1LabelType& FeatureSweep::
    forceC1Label () const
    {
      return this->forceC1Label_.get ();
    }

    FeatureSweep::ForceC1LabelType& FeatureSweep::
    forceC1Label ()
    {
      return this->forceC1Label_.get ();
    }

    void FeatureSweep::
    forceC1Label (const ForceC1LabelType& x)
    {
      this->forceC1Label_.set (x);
    }

    void FeatureSweep::
    forceC1Label (::std::unique_ptr< ForceC1LabelType > x)
    {
      this->forceC1Label_.set (std::move (x));
    }

    const FeatureSweep::SolidLabelType& FeatureSweep::
    solidLabel () const
    {
      return this->solidLabel_.get ();
    }

    FeatureSweep::SolidLabelType& FeatureSweep::
    solidLabel ()
    {
      return this->solidLabel_.get ();
    }

    void FeatureSweep::
    solidLabel (const SolidLabelType& x)
    {
      this->solidLabel_.set (x);
    }

    void FeatureSweep::
    solidLabel (::std::unique_ptr< SolidLabelType > x)
    {
      this->solidLabel_.set (std::move (x));
    }

    const FeatureSweep::UseLawLabelType& FeatureSweep::
    useLawLabel () const
    {
      return this->useLawLabel_.get ();
    }

    FeatureSweep::UseLawLabelType& FeatureSweep::
    useLawLabel ()
    {
      return this->useLawLabel_.get ();
    }

    void FeatureSweep::
    useLawLabel (const UseLawLabelType& x)
    {
      this->useLawLabel_.set (x);
    }

    void FeatureSweep::
    useLawLabel (::std::unique_ptr< UseLawLabelType > x)
    {
      this->useLawLabel_.set (std::move (x));
    }

    const FeatureSweep::LawVizMatrixType& FeatureSweep::
    lawVizMatrix () const
    {
      return this->lawVizMatrix_.get ();
    }

    FeatureSweep::LawVizMatrixType& FeatureSweep::
    lawVizMatrix ()
    {
      return this->lawVizMatrix_.get ();
    }

    void FeatureSweep::
    lawVizMatrix (const LawVizMatrixType& x)
    {
      this->lawVizMatrix_.set (x);
    }

    void FeatureSweep::
    lawVizMatrix (::std::unique_ptr< LawVizMatrixType > x)
    {
      this->lawVizMatrix_.set (std::move (x));
    }

    const FeatureSweep::LawVizScaleType& FeatureSweep::
    lawVizScale () const
    {
      return this->lawVizScale_.get ();
    }

    FeatureSweep::LawVizScaleType& FeatureSweep::
    lawVizScale ()
    {
      return this->lawVizScale_.get ();
    }

    void FeatureSweep::
    lawVizScale (const LawVizScaleType& x)
    {
      this->lawVizScale_.set (x);
    }

    const FeatureSweep::SolidIdType& FeatureSweep::
    solidId () const
    {
      return this->solidId_.get ();
    }

    FeatureSweep::SolidIdType& FeatureSweep::
    solidId ()
    {
      return this->solidId_.get ();
    }

    void FeatureSweep::
    solidId (const SolidIdType& x)
    {
      this->solidId_.set (x);
    }

    void FeatureSweep::
    solidId (::std::unique_ptr< SolidIdType > x)
    {
      this->solidId_.set (std::move (x));
    }

    const FeatureSweep::ShellIdType& FeatureSweep::
    shellId () const
    {
      return this->shellId_.get ();
    }

    FeatureSweep::ShellIdType& FeatureSweep::
    shellId ()
    {
      return this->shellId_.get ();
    }

    void FeatureSweep::
    shellId (const ShellIdType& x)
    {
      this->shellId_.set (x);
    }

    void FeatureSweep::
    shellId (::std::unique_ptr< ShellIdType > x)
    {
      this->shellId_.set (std::move (x));
    }

    const FeatureSweep::FirstFaceIdType& FeatureSweep::
    firstFaceId () const
    {
      return this->firstFaceId_.get ();
    }

    FeatureSweep::FirstFaceIdType& FeatureSweep::
    firstFaceId ()
    {
      return this->firstFaceId_.get ();
    }

    void FeatureSweep::
    firstFaceId (const FirstFaceIdType& x)
    {
      this->firstFaceId_.set (x);
    }

    void FeatureSweep::
    firstFaceId (::std::unique_ptr< FirstFaceIdType > x)
    {
      this->firstFaceId_.set (std::move (x));
    }

    const FeatureSweep::LastFaceIdType& FeatureSweep::
    lastFaceId () const
    {
      return this->lastFaceId_.get ();
    }

    FeatureSweep::LastFaceIdType& FeatureSweep::
    lastFaceId ()
    {
      return this->lastFaceId_.get ();
    }

    void FeatureSweep::
    lastFaceId (const LastFaceIdType& x)
    {
      this->lastFaceId_.set (x);
    }

    void FeatureSweep::
    lastFaceId (::std::unique_ptr< LastFaceIdType > x)
    {
      this->lastFaceId_.set (std::move (x));
    }

    const FeatureSweep::OuterWireMapType& FeatureSweep::
    outerWireMap () const
    {
      return this->outerWireMap_.get ();
    }

    FeatureSweep::OuterWireMapType& FeatureSweep::
    outerWireMap ()
    {
      return this->outerWireMap_.get ();
    }

    void FeatureSweep::
    outerWireMap (const OuterWireMapType& x)
    {
      this->outerWireMap_.set (x);
    }

    void FeatureSweep::
    outerWireMap (::std::unique_ptr< OuterWireMapType > x)
    {
      this->outerWireMap_.set (std::move (x));
    }

    const FeatureSweep::InstanceMapType& FeatureSweep::
    instanceMap () const
    {
      return this->instanceMap_.get ();
    }

    FeatureSweep::InstanceMapType& FeatureSweep::
    instanceMap ()
    {
      return this->instanceMap_.get ();
    }

    void FeatureSweep::
    instanceMap (const InstanceMapType& x)
    {
      this->instanceMap_.set (x);
    }

    void FeatureSweep::
    instanceMap (::std::unique_ptr< InstanceMapType > x)
    {
      this->instanceMap_.set (std::move (x));
    }

    const FeatureSweep::FirstShapeMapType& FeatureSweep::
    firstShapeMap () const
    {
      return this->firstShapeMap_.get ();
    }

    FeatureSweep::FirstShapeMapType& FeatureSweep::
    firstShapeMap ()
    {
      return this->firstShapeMap_.get ();
    }

    void FeatureSweep::
    firstShapeMap (const FirstShapeMapType& x)
    {
      this->firstShapeMap_.set (x);
    }

    void FeatureSweep::
    firstShapeMap (::std::unique_ptr< FirstShapeMapType > x)
    {
      this->firstShapeMap_.set (std::move (x));
    }

    const FeatureSweep::LastShapeMapType& FeatureSweep::
    lastShapeMap () const
    {
      return this->lastShapeMap_.get ();
    }

    FeatureSweep::LastShapeMapType& FeatureSweep::
    lastShapeMap ()
    {
      return this->lastShapeMap_.get ();
    }

    void FeatureSweep::
    lastShapeMap (const LastShapeMapType& x)
    {
      this->lastShapeMap_.set (x);
    }

    void FeatureSweep::
    lastShapeMap (::std::unique_ptr< LastShapeMapType > x)
    {
      this->lastShapeMap_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace prj
{
  namespace srl
  {
    // SweepProfile
    //

    SweepProfile::
    SweepProfile (const PickType& pick,
                  const ContactType& contact,
                  const CorrectionType& correction,
                  const ContactLabelType& contactLabel,
                  const CorrectionLabelType& correctionLabel)
    : ::xml_schema::Type (),
      pick_ (pick, this),
      contact_ (contact, this),
      correction_ (correction, this),
      contactLabel_ (contactLabel, this),
      correctionLabel_ (correctionLabel, this)
    {
    }

    SweepProfile::
    SweepProfile (::std::unique_ptr< PickType > pick,
                  ::std::unique_ptr< ContactType > contact,
                  ::std::unique_ptr< CorrectionType > correction,
                  ::std::unique_ptr< ContactLabelType > contactLabel,
                  ::std::unique_ptr< CorrectionLabelType > correctionLabel)
    : ::xml_schema::Type (),
      pick_ (std::move (pick), this),
      contact_ (std::move (contact), this),
      correction_ (std::move (correction), this),
      contactLabel_ (std::move (contactLabel), this),
      correctionLabel_ (std::move (correctionLabel), this)
    {
    }

    SweepProfile::
    SweepProfile (const SweepProfile& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      pick_ (x.pick_, f, this),
      contact_ (x.contact_, f, this),
      correction_ (x.correction_, f, this),
      contactLabel_ (x.contactLabel_, f, this),
      correctionLabel_ (x.correctionLabel_, f, this)
    {
    }

    SweepProfile::
    SweepProfile (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      pick_ (this),
      contact_ (this),
      correction_ (this),
      contactLabel_ (this),
      correctionLabel_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SweepProfile::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // pick
        //
        if (n.name () == "pick" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< PickType > r (
            PickTraits::create (i, f, this));

          if (!pick_.present ())
          {
            this->pick_.set (::std::move (r));
            continue;
          }
        }

        // contact
        //
        if (n.name () == "contact" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ContactType > r (
            ContactTraits::create (i, f, this));

          if (!contact_.present ())
          {
            this->contact_.set (::std::move (r));
            continue;
          }
        }

        // correction
        //
        if (n.name () == "correction" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< CorrectionType > r (
            CorrectionTraits::create (i, f, this));

          if (!correction_.present ())
          {
            this->correction_.set (::std::move (r));
            continue;
          }
        }

        // contactLabel
        //
        if (n.name () == "contactLabel" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ContactLabelType > r (
            ContactLabelTraits::create (i, f, this));

          if (!contactLabel_.present ())
          {
            this->contactLabel_.set (::std::move (r));
            continue;
          }
        }

        // correctionLabel
        //
        if (n.name () == "correctionLabel" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< CorrectionLabelType > r (
            CorrectionLabelTraits::create (i, f, this));

          if (!correctionLabel_.present ())
          {
            this->correctionLabel_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!pick_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "pick",
          "");
      }

      if (!contact_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "contact",
          "");
      }

      if (!correction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "correction",
          "");
      }

      if (!contactLabel_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "contactLabel",
          "");
      }

      if (!correctionLabel_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "correctionLabel",
          "");
      }
    }

    SweepProfile* SweepProfile::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SweepProfile (*this, f, c);
    }

    SweepProfile& SweepProfile::
    operator= (const SweepProfile& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->pick_ = x.pick_;
        this->contact_ = x.contact_;
        this->correction_ = x.correction_;
        this->contactLabel_ = x.contactLabel_;
        this->correctionLabel_ = x.correctionLabel_;
      }

      return *this;
    }

    SweepProfile::
    ~SweepProfile ()
    {
    }

    // SweepProfiles
    //

    SweepProfiles::
    SweepProfiles ()
    : ::xml_schema::Type (),
      array_ (this)
    {
    }

    SweepProfiles::
    SweepProfiles (const SweepProfiles& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      array_ (x.array_, f, this)
    {
    }

    SweepProfiles::
    SweepProfiles (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      array_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SweepProfiles::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // array
        //
        if (n.name () == "array" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ArrayType > r (
            ArrayTraits::create (i, f, this));

          this->array_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    SweepProfiles* SweepProfiles::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SweepProfiles (*this, f, c);
    }

    SweepProfiles& SweepProfiles::
    operator= (const SweepProfiles& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->array_ = x.array_;
      }

      return *this;
    }

    SweepProfiles::
    ~SweepProfiles ()
    {
    }

    // SweepAuxiliary
    //

    SweepAuxiliary::
    SweepAuxiliary (const PickType& pick,
                    const CurvilinearEquivalenceType& curvilinearEquivalence,
                    const ContactTypeType& contactType,
                    const CurvilinearEquivalenceLabelType& curvilinearEquivalenceLabel,
                    const ContactTypeLabelType& contactTypeLabel)
    : ::xml_schema::Type (),
      pick_ (pick, this),
      curvilinearEquivalence_ (curvilinearEquivalence, this),
      contactType_ (contactType, this),
      curvilinearEquivalenceLabel_ (curvilinearEquivalenceLabel, this),
      contactTypeLabel_ (contactTypeLabel, this)
    {
    }

    SweepAuxiliary::
    SweepAuxiliary (::std::unique_ptr< PickType > pick,
                    ::std::unique_ptr< CurvilinearEquivalenceType > curvilinearEquivalence,
                    ::std::unique_ptr< ContactTypeType > contactType,
                    ::std::unique_ptr< CurvilinearEquivalenceLabelType > curvilinearEquivalenceLabel,
                    ::std::unique_ptr< ContactTypeLabelType > contactTypeLabel)
    : ::xml_schema::Type (),
      pick_ (std::move (pick), this),
      curvilinearEquivalence_ (std::move (curvilinearEquivalence), this),
      contactType_ (std::move (contactType), this),
      curvilinearEquivalenceLabel_ (std::move (curvilinearEquivalenceLabel), this),
      contactTypeLabel_ (std::move (contactTypeLabel), this)
    {
    }

    SweepAuxiliary::
    SweepAuxiliary (const SweepAuxiliary& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      pick_ (x.pick_, f, this),
      curvilinearEquivalence_ (x.curvilinearEquivalence_, f, this),
      contactType_ (x.contactType_, f, this),
      curvilinearEquivalenceLabel_ (x.curvilinearEquivalenceLabel_, f, this),
      contactTypeLabel_ (x.contactTypeLabel_, f, this)
    {
    }

    SweepAuxiliary::
    SweepAuxiliary (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      pick_ (this),
      curvilinearEquivalence_ (this),
      contactType_ (this),
      curvilinearEquivalenceLabel_ (this),
      contactTypeLabel_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SweepAuxiliary::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // pick
        //
        if (n.name () == "pick" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< PickType > r (
            PickTraits::create (i, f, this));

          if (!pick_.present ())
          {
            this->pick_.set (::std::move (r));
            continue;
          }
        }

        // curvilinearEquivalence
        //
        if (n.name () == "curvilinearEquivalence" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< CurvilinearEquivalenceType > r (
            CurvilinearEquivalenceTraits::create (i, f, this));

          if (!curvilinearEquivalence_.present ())
          {
            this->curvilinearEquivalence_.set (::std::move (r));
            continue;
          }
        }

        // contactType
        //
        if (n.name () == "contactType" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ContactTypeType > r (
            ContactTypeTraits::create (i, f, this));

          if (!contactType_.present ())
          {
            this->contactType_.set (::std::move (r));
            continue;
          }
        }

        // curvilinearEquivalenceLabel
        //
        if (n.name () == "curvilinearEquivalenceLabel" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< CurvilinearEquivalenceLabelType > r (
            CurvilinearEquivalenceLabelTraits::create (i, f, this));

          if (!curvilinearEquivalenceLabel_.present ())
          {
            this->curvilinearEquivalenceLabel_.set (::std::move (r));
            continue;
          }
        }

        // contactTypeLabel
        //
        if (n.name () == "contactTypeLabel" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ContactTypeLabelType > r (
            ContactTypeLabelTraits::create (i, f, this));

          if (!contactTypeLabel_.present ())
          {
            this->contactTypeLabel_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!pick_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "pick",
          "");
      }

      if (!curvilinearEquivalence_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "curvilinearEquivalence",
          "");
      }

      if (!contactType_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "contactType",
          "");
      }

      if (!curvilinearEquivalenceLabel_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "curvilinearEquivalenceLabel",
          "");
      }

      if (!contactTypeLabel_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "contactTypeLabel",
          "");
      }
    }

    SweepAuxiliary* SweepAuxiliary::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SweepAuxiliary (*this, f, c);
    }

    SweepAuxiliary& SweepAuxiliary::
    operator= (const SweepAuxiliary& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->pick_ = x.pick_;
        this->curvilinearEquivalence_ = x.curvilinearEquivalence_;
        this->contactType_ = x.contactType_;
        this->curvilinearEquivalenceLabel_ = x.curvilinearEquivalenceLabel_;
        this->contactTypeLabel_ = x.contactTypeLabel_;
      }

      return *this;
    }

    SweepAuxiliary::
    ~SweepAuxiliary ()
    {
    }

    // SweepBinormal
    //

    SweepBinormal::
    SweepBinormal (const PicksType& picks,
                   const BinormalType& binormal,
                   const BinormalLabelType& binormalLabel)
    : ::xml_schema::Type (),
      picks_ (picks, this),
      binormal_ (binormal, this),
      binormalLabel_ (binormalLabel, this)
    {
    }

    SweepBinormal::
    SweepBinormal (::std::unique_ptr< PicksType > picks,
                   ::std::unique_ptr< BinormalType > binormal,
                   ::std::unique_ptr< BinormalLabelType > binormalLabel)
    : ::xml_schema::Type (),
      picks_ (std::move (picks), this),
      binormal_ (std::move (binormal), this),
      binormalLabel_ (std::move (binormalLabel), this)
    {
    }

    SweepBinormal::
    SweepBinormal (const SweepBinormal& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      picks_ (x.picks_, f, this),
      binormal_ (x.binormal_, f, this),
      binormalLabel_ (x.binormalLabel_, f, this)
    {
    }

    SweepBinormal::
    SweepBinormal (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      picks_ (this),
      binormal_ (this),
      binormalLabel_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SweepBinormal::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // picks
        //
        if (n.name () == "picks" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< PicksType > r (
            PicksTraits::create (i, f, this));

          if (!picks_.present ())
          {
            this->picks_.set (::std::move (r));
            continue;
          }
        }

        // binormal
        //
        if (n.name () == "binormal" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< BinormalType > r (
            BinormalTraits::create (i, f, this));

          if (!binormal_.present ())
          {
            this->binormal_.set (::std::move (r));
            continue;
          }
        }

        // binormalLabel
        //
        if (n.name () == "binormalLabel" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< BinormalLabelType > r (
            BinormalLabelTraits::create (i, f, this));

          if (!binormalLabel_.present ())
          {
            this->binormalLabel_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!picks_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "picks",
          "");
      }

      if (!binormal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "binormal",
          "");
      }

      if (!binormalLabel_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "binormalLabel",
          "");
      }
    }

    SweepBinormal* SweepBinormal::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SweepBinormal (*this, f, c);
    }

    SweepBinormal& SweepBinormal::
    operator= (const SweepBinormal& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->picks_ = x.picks_;
        this->binormal_ = x.binormal_;
        this->binormalLabel_ = x.binormalLabel_;
      }

      return *this;
    }

    SweepBinormal::
    ~SweepBinormal ()
    {
    }

    // InstanceValues
    //

    InstanceValues::
    InstanceValues ()
    : ::xml_schema::Type (),
      array_ (this)
    {
    }

    InstanceValues::
    InstanceValues (const InstanceValues& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      array_ (x.array_, f, this)
    {
    }

    InstanceValues::
    InstanceValues (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      array_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void InstanceValues::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // array
        //
        if (n.name () == "array" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ArrayType > r (
            ArrayTraits::create (i, f, this));

          this->array_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    InstanceValues* InstanceValues::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class InstanceValues (*this, f, c);
    }

    InstanceValues& InstanceValues::
    operator= (const InstanceValues& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->array_ = x.array_;
      }

      return *this;
    }

    InstanceValues::
    ~InstanceValues ()
    {
    }

    // Instance
    //

    Instance::
    Instance (const KeyType& key,
              const ValuesType& values)
    : ::xml_schema::Type (),
      key_ (key, this),
      values_ (values, this)
    {
    }

    Instance::
    Instance (const KeyType& key,
              ::std::unique_ptr< ValuesType > values)
    : ::xml_schema::Type (),
      key_ (key, this),
      values_ (std::move (values), this)
    {
    }

    Instance::
    Instance (const Instance& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      key_ (x.key_, f, this),
      values_ (x.values_, f, this)
    {
    }

    Instance::
    Instance (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      key_ (this),
      values_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Instance::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // key
        //
        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< KeyType > r (
            KeyTraits::create (i, f, this));

          if (!key_.present ())
          {
            this->key_.set (::std::move (r));
            continue;
          }
        }

        // values
        //
        if (n.name () == "values" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ValuesType > r (
            ValuesTraits::create (i, f, this));

          if (!values_.present ())
          {
            this->values_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!key_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "key",
          "");
      }

      if (!values_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "values",
          "");
      }
    }

    Instance* Instance::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Instance (*this, f, c);
    }

    Instance& Instance::
    operator= (const Instance& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->key_ = x.key_;
        this->values_ = x.values_;
      }

      return *this;
    }

    Instance::
    ~Instance ()
    {
    }

    // InstanceMap
    //

    InstanceMap::
    InstanceMap ()
    : ::xml_schema::Type (),
      array_ (this)
    {
    }

    InstanceMap::
    InstanceMap (const InstanceMap& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      array_ (x.array_, f, this)
    {
    }

    InstanceMap::
    InstanceMap (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      array_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void InstanceMap::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // array
        //
        if (n.name () == "array" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ArrayType > r (
            ArrayTraits::create (i, f, this));

          this->array_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    InstanceMap* InstanceMap::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class InstanceMap (*this, f, c);
    }

    InstanceMap& InstanceMap::
    operator= (const InstanceMap& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->array_ = x.array_;
      }

      return *this;
    }

    InstanceMap::
    ~InstanceMap ()
    {
    }

    // FeatureSweep
    //

    FeatureSweep::
    FeatureSweep (const FeatureBaseType& featureBase,
                  const LawFunctionType& lawFunction,
                  const TrihedronType& trihedron,
                  const TransitionType& transition,
                  const ForceC1Type& forceC1,
                  const SolidType& solid,
                  const UseLawType& useLaw,
                  const SpineType& spine,
                  const ProfilesType& profiles,
                  const AuxiliaryType& auxiliary,
                  const SupportType& support,
                  const BinormalType& binormal,
                  const TrihedronLabelType& trihedronLabel,
                  const TransitionLabelType& transitionLabel,
                  const ForceC1LabelType& forceC1Label,
                  const SolidLabelType& solidLabel,
                  const UseLawLabelType& useLawLabel,
                  const LawVizMatrixType& lawVizMatrix,
                  const LawVizScaleType& lawVizScale,
                  const SolidIdType& solidId,
                  const ShellIdType& shellId,
                  const FirstFaceIdType& firstFaceId,
                  const LastFaceIdType& lastFaceId,
                  const OuterWireMapType& outerWireMap,
                  const InstanceMapType& instanceMap,
                  const FirstShapeMapType& firstShapeMap,
                  const LastShapeMapType& lastShapeMap)
    : ::xml_schema::Type (),
      featureBase_ (featureBase, this),
      lawFunction_ (lawFunction, this),
      trihedron_ (trihedron, this),
      transition_ (transition, this),
      forceC1_ (forceC1, this),
      solid_ (solid, this),
      useLaw_ (useLaw, this),
      spine_ (spine, this),
      profiles_ (profiles, this),
      auxiliary_ (auxiliary, this),
      support_ (support, this),
      binormal_ (binormal, this),
      trihedronLabel_ (trihedronLabel, this),
      transitionLabel_ (transitionLabel, this),
      forceC1Label_ (forceC1Label, this),
      solidLabel_ (solidLabel, this),
      useLawLabel_ (useLawLabel, this),
      lawVizMatrix_ (lawVizMatrix, this),
      lawVizScale_ (lawVizScale, this),
      solidId_ (solidId, this),
      shellId_ (shellId, this),
      firstFaceId_ (firstFaceId, this),
      lastFaceId_ (lastFaceId, this),
      outerWireMap_ (outerWireMap, this),
      instanceMap_ (instanceMap, this),
      firstShapeMap_ (firstShapeMap, this),
      lastShapeMap_ (lastShapeMap, this)
    {
    }

    FeatureSweep::
    FeatureSweep (::std::unique_ptr< FeatureBaseType > featureBase,
                  ::std::unique_ptr< LawFunctionType > lawFunction,
                  ::std::unique_ptr< TrihedronType > trihedron,
                  ::std::unique_ptr< TransitionType > transition,
                  ::std::unique_ptr< ForceC1Type > forceC1,
                  ::std::unique_ptr< SolidType > solid,
                  ::std::unique_ptr< UseLawType > useLaw,
                  ::std::unique_ptr< SpineType > spine,
                  ::std::unique_ptr< ProfilesType > profiles,
                  ::std::unique_ptr< AuxiliaryType > auxiliary,
                  ::std::unique_ptr< SupportType > support,
                  ::std::unique_ptr< BinormalType > binormal,
                  ::std::unique_ptr< TrihedronLabelType > trihedronLabel,
                  ::std::unique_ptr< TransitionLabelType > transitionLabel,
                  ::std::unique_ptr< ForceC1LabelType > forceC1Label,
                  ::std::unique_ptr< SolidLabelType > solidLabel,
                  ::std::unique_ptr< UseLawLabelType > useLawLabel,
                  ::std::unique_ptr< LawVizMatrixType > lawVizMatrix,
                  const LawVizScaleType& lawVizScale,
                  const SolidIdType& solidId,
                  const ShellIdType& shellId,
                  const FirstFaceIdType& firstFaceId,
                  const LastFaceIdType& lastFaceId,
                  ::std::unique_ptr< OuterWireMapType > outerWireMap,
                  ::std::unique_ptr< InstanceMapType > instanceMap,
                  ::std::unique_ptr< FirstShapeMapType > firstShapeMap,
                  ::std::unique_ptr< LastShapeMapType > lastShapeMap)
    : ::xml_schema::Type (),
      featureBase_ (std::move (featureBase), this),
      lawFunction_ (std::move (lawFunction), this),
      trihedron_ (std::move (trihedron), this),
      transition_ (std::move (transition), this),
      forceC1_ (std::move (forceC1), this),
      solid_ (std::move (solid), this),
      useLaw_ (std::move (useLaw), this),
      spine_ (std::move (spine), this),
      profiles_ (std::move (profiles), this),
      auxiliary_ (std::move (auxiliary), this),
      support_ (std::move (support), this),
      binormal_ (std::move (binormal), this),
      trihedronLabel_ (std::move (trihedronLabel), this),
      transitionLabel_ (std::move (transitionLabel), this),
      forceC1Label_ (std::move (forceC1Label), this),
      solidLabel_ (std::move (solidLabel), this),
      useLawLabel_ (std::move (useLawLabel), this),
      lawVizMatrix_ (std::move (lawVizMatrix), this),
      lawVizScale_ (lawVizScale, this),
      solidId_ (solidId, this),
      shellId_ (shellId, this),
      firstFaceId_ (firstFaceId, this),
      lastFaceId_ (lastFaceId, this),
      outerWireMap_ (std::move (outerWireMap), this),
      instanceMap_ (std::move (instanceMap), this),
      firstShapeMap_ (std::move (firstShapeMap), this),
      lastShapeMap_ (std::move (lastShapeMap), this)
    {
    }

    FeatureSweep::
    FeatureSweep (const FeatureSweep& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      featureBase_ (x.featureBase_, f, this),
      lawFunction_ (x.lawFunction_, f, this),
      trihedron_ (x.trihedron_, f, this),
      transition_ (x.transition_, f, this),
      forceC1_ (x.forceC1_, f, this),
      solid_ (x.solid_, f, this),
      useLaw_ (x.useLaw_, f, this),
      spine_ (x.spine_, f, this),
      profiles_ (x.profiles_, f, this),
      auxiliary_ (x.auxiliary_, f, this),
      support_ (x.support_, f, this),
      binormal_ (x.binormal_, f, this),
      trihedronLabel_ (x.trihedronLabel_, f, this),
      transitionLabel_ (x.transitionLabel_, f, this),
      forceC1Label_ (x.forceC1Label_, f, this),
      solidLabel_ (x.solidLabel_, f, this),
      useLawLabel_ (x.useLawLabel_, f, this),
      lawVizMatrix_ (x.lawVizMatrix_, f, this),
      lawVizScale_ (x.lawVizScale_, f, this),
      solidId_ (x.solidId_, f, this),
      shellId_ (x.shellId_, f, this),
      firstFaceId_ (x.firstFaceId_, f, this),
      lastFaceId_ (x.lastFaceId_, f, this),
      outerWireMap_ (x.outerWireMap_, f, this),
      instanceMap_ (x.instanceMap_, f, this),
      firstShapeMap_ (x.firstShapeMap_, f, this),
      lastShapeMap_ (x.lastShapeMap_, f, this)
    {
    }

    FeatureSweep::
    FeatureSweep (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      featureBase_ (this),
      lawFunction_ (this),
      trihedron_ (this),
      transition_ (this),
      forceC1_ (this),
      solid_ (this),
      useLaw_ (this),
      spine_ (this),
      profiles_ (this),
      auxiliary_ (this),
      support_ (this),
      binormal_ (this),
      trihedronLabel_ (this),
      transitionLabel_ (this),
      forceC1Label_ (this),
      solidLabel_ (this),
      useLawLabel_ (this),
      lawVizMatrix_ (this),
      lawVizScale_ (this),
      solidId_ (this),
      shellId_ (this),
      firstFaceId_ (this),
      lastFaceId_ (this),
      outerWireMap_ (this),
      instanceMap_ (this),
      firstShapeMap_ (this),
      lastShapeMap_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureSweep::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // featureBase
        //
        if (n.name () == "featureBase" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< FeatureBaseType > r (
            FeatureBaseTraits::create (i, f, this));

          if (!featureBase_.present ())
          {
            this->featureBase_.set (::std::move (r));
            continue;
          }
        }

        // lawFunction
        //
        if (n.name () == "lawFunction" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< LawFunctionType > r (
            LawFunctionTraits::create (i, f, this));

          if (!lawFunction_.present ())
          {
            this->lawFunction_.set (::std::move (r));
            continue;
          }
        }

        // trihedron
        //
        if (n.name () == "trihedron" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< TrihedronType > r (
            TrihedronTraits::create (i, f, this));

          if (!trihedron_.present ())
          {
            this->trihedron_.set (::std::move (r));
            continue;
          }
        }

        // transition
        //
        if (n.name () == "transition" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< TransitionType > r (
            TransitionTraits::create (i, f, this));

          if (!transition_.present ())
          {
            this->transition_.set (::std::move (r));
            continue;
          }
        }

        // forceC1
        //
        if (n.name () == "forceC1" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ForceC1Type > r (
            ForceC1Traits::create (i, f, this));

          if (!forceC1_.present ())
          {
            this->forceC1_.set (::std::move (r));
            continue;
          }
        }

        // solid
        //
        if (n.name () == "solid" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< SolidType > r (
            SolidTraits::create (i, f, this));

          if (!solid_.present ())
          {
            this->solid_.set (::std::move (r));
            continue;
          }
        }

        // useLaw
        //
        if (n.name () == "useLaw" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< UseLawType > r (
            UseLawTraits::create (i, f, this));

          if (!useLaw_.present ())
          {
            this->useLaw_.set (::std::move (r));
            continue;
          }
        }

        // spine
        //
        if (n.name () == "spine" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< SpineType > r (
            SpineTraits::create (i, f, this));

          if (!spine_.present ())
          {
            this->spine_.set (::std::move (r));
            continue;
          }
        }

        // profiles
        //
        if (n.name () == "profiles" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ProfilesType > r (
            ProfilesTraits::create (i, f, this));

          if (!profiles_.present ())
          {
            this->profiles_.set (::std::move (r));
            continue;
          }
        }

        // auxiliary
        //
        if (n.name () == "auxiliary" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< AuxiliaryType > r (
            AuxiliaryTraits::create (i, f, this));

          if (!auxiliary_.present ())
          {
            this->auxiliary_.set (::std::move (r));
            continue;
          }
        }

        // support
        //
        if (n.name () == "support" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< SupportType > r (
            SupportTraits::create (i, f, this));

          if (!support_.present ())
          {
            this->support_.set (::std::move (r));
            continue;
          }
        }

        // binormal
        //
        if (n.name () == "binormal" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< BinormalType > r (
            BinormalTraits::create (i, f, this));

          if (!binormal_.present ())
          {
            this->binormal_.set (::std::move (r));
            continue;
          }
        }

        // trihedronLabel
        //
        if (n.name () == "trihedronLabel" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< TrihedronLabelType > r (
            TrihedronLabelTraits::create (i, f, this));

          if (!trihedronLabel_.present ())
          {
            this->trihedronLabel_.set (::std::move (r));
            continue;
          }
        }

        // transitionLabel
        //
        if (n.name () == "transitionLabel" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< TransitionLabelType > r (
            TransitionLabelTraits::create (i, f, this));

          if (!transitionLabel_.present ())
          {
            this->transitionLabel_.set (::std::move (r));
            continue;
          }
        }

        // forceC1Label
        //
        if (n.name () == "forceC1Label" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ForceC1LabelType > r (
            ForceC1LabelTraits::create (i, f, this));

          if (!forceC1Label_.present ())
          {
            this->forceC1Label_.set (::std::move (r));
            continue;
          }
        }

        // solidLabel
        //
        if (n.name () == "solidLabel" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< SolidLabelType > r (
            SolidLabelTraits::create (i, f, this));

          if (!solidLabel_.present ())
          {
            this->solidLabel_.set (::std::move (r));
            continue;
          }
        }

        // useLawLabel
        //
        if (n.name () == "useLawLabel" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< UseLawLabelType > r (
            UseLawLabelTraits::create (i, f, this));

          if (!useLawLabel_.present ())
          {
            this->useLawLabel_.set (::std::move (r));
            continue;
          }
        }

        // lawVizMatrix
        //
        if (n.name () == "lawVizMatrix" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< LawVizMatrixType > r (
            LawVizMatrixTraits::create (i, f, this));

          if (!lawVizMatrix_.present ())
          {
            this->lawVizMatrix_.set (::std::move (r));
            continue;
          }
        }

        // lawVizScale
        //
        if (n.name () == "lawVizScale" && n.namespace_ ().empty ())
        {
          if (!lawVizScale_.present ())
          {
            this->lawVizScale_.set (LawVizScaleTraits::create (i, f, this));
            continue;
          }
        }

        // solidId
        //
        if (n.name () == "solidId" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< SolidIdType > r (
            SolidIdTraits::create (i, f, this));

          if (!solidId_.present ())
          {
            this->solidId_.set (::std::move (r));
            continue;
          }
        }

        // shellId
        //
        if (n.name () == "shellId" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ShellIdType > r (
            ShellIdTraits::create (i, f, this));

          if (!shellId_.present ())
          {
            this->shellId_.set (::std::move (r));
            continue;
          }
        }

        // firstFaceId
        //
        if (n.name () == "firstFaceId" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< FirstFaceIdType > r (
            FirstFaceIdTraits::create (i, f, this));

          if (!firstFaceId_.present ())
          {
            this->firstFaceId_.set (::std::move (r));
            continue;
          }
        }

        // lastFaceId
        //
        if (n.name () == "lastFaceId" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< LastFaceIdType > r (
            LastFaceIdTraits::create (i, f, this));

          if (!lastFaceId_.present ())
          {
            this->lastFaceId_.set (::std::move (r));
            continue;
          }
        }

        // outerWireMap
        //
        if (n.name () == "outerWireMap" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< OuterWireMapType > r (
            OuterWireMapTraits::create (i, f, this));

          if (!outerWireMap_.present ())
          {
            this->outerWireMap_.set (::std::move (r));
            continue;
          }
        }

        // instanceMap
        //
        if (n.name () == "instanceMap" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< InstanceMapType > r (
            InstanceMapTraits::create (i, f, this));

          if (!instanceMap_.present ())
          {
            this->instanceMap_.set (::std::move (r));
            continue;
          }
        }

        // firstShapeMap
        //
        if (n.name () == "firstShapeMap" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< FirstShapeMapType > r (
            FirstShapeMapTraits::create (i, f, this));

          if (!firstShapeMap_.present ())
          {
            this->firstShapeMap_.set (::std::move (r));
            continue;
          }
        }

        // lastShapeMap
        //
        if (n.name () == "lastShapeMap" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< LastShapeMapType > r (
            LastShapeMapTraits::create (i, f, this));

          if (!lastShapeMap_.present ())
          {
            this->lastShapeMap_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!featureBase_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "featureBase",
          "");
      }

      if (!lawFunction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "lawFunction",
          "");
      }

      if (!trihedron_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "trihedron",
          "");
      }

      if (!transition_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "transition",
          "");
      }

      if (!forceC1_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "forceC1",
          "");
      }

      if (!solid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "solid",
          "");
      }

      if (!useLaw_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "useLaw",
          "");
      }

      if (!spine_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "spine",
          "");
      }

      if (!profiles_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "profiles",
          "");
      }

      if (!auxiliary_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "auxiliary",
          "");
      }

      if (!support_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "support",
          "");
      }

      if (!binormal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "binormal",
          "");
      }

      if (!trihedronLabel_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "trihedronLabel",
          "");
      }

      if (!transitionLabel_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "transitionLabel",
          "");
      }

      if (!forceC1Label_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "forceC1Label",
          "");
      }

      if (!solidLabel_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "solidLabel",
          "");
      }

      if (!useLawLabel_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "useLawLabel",
          "");
      }

      if (!lawVizMatrix_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "lawVizMatrix",
          "");
      }

      if (!lawVizScale_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "lawVizScale",
          "");
      }

      if (!solidId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "solidId",
          "");
      }

      if (!shellId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "shellId",
          "");
      }

      if (!firstFaceId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "firstFaceId",
          "");
      }

      if (!lastFaceId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "lastFaceId",
          "");
      }

      if (!outerWireMap_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "outerWireMap",
          "");
      }

      if (!instanceMap_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "instanceMap",
          "");
      }

      if (!firstShapeMap_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "firstShapeMap",
          "");
      }

      if (!lastShapeMap_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "lastShapeMap",
          "");
      }
    }

    FeatureSweep* FeatureSweep::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FeatureSweep (*this, f, c);
    }

    FeatureSweep& FeatureSweep::
    operator= (const FeatureSweep& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->featureBase_ = x.featureBase_;
        this->lawFunction_ = x.lawFunction_;
        this->trihedron_ = x.trihedron_;
        this->transition_ = x.transition_;
        this->forceC1_ = x.forceC1_;
        this->solid_ = x.solid_;
        this->useLaw_ = x.useLaw_;
        this->spine_ = x.spine_;
        this->profiles_ = x.profiles_;
        this->auxiliary_ = x.auxiliary_;
        this->support_ = x.support_;
        this->binormal_ = x.binormal_;
        this->trihedronLabel_ = x.trihedronLabel_;
        this->transitionLabel_ = x.transitionLabel_;
        this->forceC1Label_ = x.forceC1Label_;
        this->solidLabel_ = x.solidLabel_;
        this->useLawLabel_ = x.useLawLabel_;
        this->lawVizMatrix_ = x.lawVizMatrix_;
        this->lawVizScale_ = x.lawVizScale_;
        this->solidId_ = x.solidId_;
        this->shellId_ = x.shellId_;
        this->firstFaceId_ = x.firstFaceId_;
        this->lastFaceId_ = x.lastFaceId_;
        this->outerWireMap_ = x.outerWireMap_;
        this->instanceMap_ = x.instanceMap_;
        this->firstShapeMap_ = x.firstShapeMap_;
        this->lastShapeMap_ = x.lastShapeMap_;
      }

      return *this;
    }

    FeatureSweep::
    ~FeatureSweep ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace prj
{
  namespace srl
  {
    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (const ::std::string& u,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::prj::srl::FeatureSweep > (
        ::prj::srl::sweep (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (const ::std::string& u,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::prj::srl::FeatureSweep > (
        ::prj::srl::sweep (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::prj::srl::FeatureSweep > (
        ::prj::srl::sweep (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::std::istream& is,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::prj::srl::sweep (isrc, f, p);
    }

    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::std::istream& is,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::prj::srl::sweep (isrc, h, f, p);
    }

    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::prj::srl::sweep (isrc, h, f, p);
    }

    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::prj::srl::sweep (isrc, f, p);
    }

    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::prj::srl::sweep (isrc, h, f, p);
    }

    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::prj::srl::sweep (isrc, h, f, p);
    }

    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::xercesc::InputSource& i,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::prj::srl::FeatureSweep > (
        ::prj::srl::sweep (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::xercesc::InputSource& i,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::prj::srl::FeatureSweep > (
        ::prj::srl::sweep (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::prj::srl::FeatureSweep > (
        ::prj::srl::sweep (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (const ::xercesc::DOMDocument& doc,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::prj::srl::FeatureSweep > (
          ::prj::srl::sweep (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "sweep" &&
          n.namespace_ () == "http://www.cadseer.com/prj/srl")
      {
        ::std::unique_ptr< ::prj::srl::FeatureSweep > r (
          ::xsd::cxx::tree::traits< ::prj::srl::FeatureSweep, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "sweep",
        "http://www.cadseer.com/prj/srl");
    }

    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "sweep" &&
          n.namespace_ () == "http://www.cadseer.com/prj/srl")
      {
        ::std::unique_ptr< ::prj::srl::FeatureSweep > r (
          ::xsd::cxx::tree::traits< ::prj::srl::FeatureSweep, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "sweep",
        "http://www.cadseer.com/prj/srl");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace prj
{
  namespace srl
  {
    void
    operator<< (::xercesc::DOMElement& e, const SweepProfile& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // pick
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "pick",
            e));

        s << i.pick ();
      }

      // contact
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "contact",
            e));

        s << i.contact ();
      }

      // correction
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "correction",
            e));

        s << i.correction ();
      }

      // contactLabel
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "contactLabel",
            e));

        s << i.contactLabel ();
      }

      // correctionLabel
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "correctionLabel",
            e));

        s << i.correctionLabel ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SweepProfiles& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // array
      //
      for (SweepProfiles::ArrayConstIterator
           b (i.array ().begin ()), n (i.array ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "array",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SweepAuxiliary& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // pick
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "pick",
            e));

        s << i.pick ();
      }

      // curvilinearEquivalence
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "curvilinearEquivalence",
            e));

        s << i.curvilinearEquivalence ();
      }

      // contactType
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "contactType",
            e));

        s << i.contactType ();
      }

      // curvilinearEquivalenceLabel
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "curvilinearEquivalenceLabel",
            e));

        s << i.curvilinearEquivalenceLabel ();
      }

      // contactTypeLabel
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "contactTypeLabel",
            e));

        s << i.contactTypeLabel ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SweepBinormal& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // picks
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "picks",
            e));

        s << i.picks ();
      }

      // binormal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "binormal",
            e));

        s << i.binormal ();
      }

      // binormalLabel
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "binormalLabel",
            e));

        s << i.binormalLabel ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const InstanceValues& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // array
      //
      for (InstanceValues::ArrayConstIterator
           b (i.array ().begin ()), n (i.array ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "array",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Instance& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // key
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "key",
            e));

        s << i.key ();
      }

      // values
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "values",
            e));

        s << i.values ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const InstanceMap& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // array
      //
      for (InstanceMap::ArrayConstIterator
           b (i.array ().begin ()), n (i.array ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "array",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureSweep& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // featureBase
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "featureBase",
            e));

        s << i.featureBase ();
      }

      // lawFunction
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "lawFunction",
            e));

        s << i.lawFunction ();
      }

      // trihedron
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "trihedron",
            e));

        s << i.trihedron ();
      }

      // transition
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "transition",
            e));

        s << i.transition ();
      }

      // forceC1
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "forceC1",
            e));

        s << i.forceC1 ();
      }

      // solid
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "solid",
            e));

        s << i.solid ();
      }

      // useLaw
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "useLaw",
            e));

        s << i.useLaw ();
      }

      // spine
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "spine",
            e));

        s << i.spine ();
      }

      // profiles
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "profiles",
            e));

        s << i.profiles ();
      }

      // auxiliary
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "auxiliary",
            e));

        s << i.auxiliary ();
      }

      // support
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "support",
            e));

        s << i.support ();
      }

      // binormal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "binormal",
            e));

        s << i.binormal ();
      }

      // trihedronLabel
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "trihedronLabel",
            e));

        s << i.trihedronLabel ();
      }

      // transitionLabel
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "transitionLabel",
            e));

        s << i.transitionLabel ();
      }

      // forceC1Label
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "forceC1Label",
            e));

        s << i.forceC1Label ();
      }

      // solidLabel
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "solidLabel",
            e));

        s << i.solidLabel ();
      }

      // useLawLabel
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "useLawLabel",
            e));

        s << i.useLawLabel ();
      }

      // lawVizMatrix
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "lawVizMatrix",
            e));

        s << i.lawVizMatrix ();
      }

      // lawVizScale
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "lawVizScale",
            e));

        s << ::xml_schema::AsDouble(i.lawVizScale ());
      }

      // solidId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "solidId",
            e));

        s << i.solidId ();
      }

      // shellId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "shellId",
            e));

        s << i.shellId ();
      }

      // firstFaceId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "firstFaceId",
            e));

        s << i.firstFaceId ();
      }

      // lastFaceId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "lastFaceId",
            e));

        s << i.lastFaceId ();
      }

      // outerWireMap
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "outerWireMap",
            e));

        s << i.outerWireMap ();
      }

      // instanceMap
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "instanceMap",
            e));

        s << i.instanceMap ();
      }

      // firstShapeMap
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "firstShapeMap",
            e));

        s << i.firstShapeMap ();
      }

      // lastShapeMap
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "lastShapeMap",
            e));

        s << i.lastShapeMap ();
      }
    }

    void
    sweep (::std::ostream& o,
           const ::prj::srl::FeatureSweep& s,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::prj::srl::sweep (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    sweep (::std::ostream& o,
           const ::prj::srl::FeatureSweep& s,
           ::xml_schema::ErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::prj::srl::sweep (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    sweep (::std::ostream& o,
           const ::prj::srl::FeatureSweep& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::prj::srl::sweep (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    sweep (::xercesc::XMLFormatTarget& t,
           const ::prj::srl::FeatureSweep& s,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::prj::srl::sweep (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    sweep (::xercesc::XMLFormatTarget& t,
           const ::prj::srl::FeatureSweep& s,
           ::xml_schema::ErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::prj::srl::sweep (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    sweep (::xercesc::XMLFormatTarget& t,
           const ::prj::srl::FeatureSweep& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::prj::srl::sweep (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    sweep (::xercesc::DOMDocument& d,
           const ::prj::srl::FeatureSweep& s,
           ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "sweep" &&
          n.namespace_ () == "http://www.cadseer.com/prj/srl")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "sweep",
          "http://www.cadseer.com/prj/srl");
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    sweep (const ::prj::srl::FeatureSweep& s,
           const ::xml_schema::NamespaceInfomap& m,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "sweep",
          "http://www.cadseer.com/prj/srl",
          m, f));

      ::prj::srl::sweep (*d, s, f);
      return d;
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

