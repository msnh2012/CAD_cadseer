// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from featuresweep.xsd.
 */

#ifndef PRJ_SRL_FEATURESWEEP_H
#define PRJ_SRL_FEATURESWEEP_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include "../../../xmlbase.h"

// Forward declarations.
//
namespace prj
{
  namespace srl
  {
    class SweepProfile;
    class SweepProfiles;
    class SweepAuxiliary;
    class SweepBinormal;
    class InstanceValues;
    class Instance;
    class InstanceMap;
    class FeatureSweep;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "featurebase.h"

#include "lawfunction.h"

namespace prj
{
  /**
   * @brief C++ namespace for the %http://www.cadseer.com/prj/srl
   * schema namespace.
   */
  namespace srl
  {
    /**
     * @brief Class corresponding to the %SweepProfile schema type.
     *
     * @nosubgrouping
     */
    class SweepProfile: public ::xml_schema::Type
    {
      public:
      /**
       * @name pick
       *
       * @brief Accessor and modifier functions for the %pick
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::Pick PickType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< PickType, char > PickTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const PickType&
      pick () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      PickType&
      pick ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      pick (const PickType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      pick (::std::unique_ptr< PickType > p);

      //@}

      /**
       * @name contact
       *
       * @brief Accessor and modifier functions for the %contact
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::Parameter ContactType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ContactType, char > ContactTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const ContactType&
      contact () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      ContactType&
      contact ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      contact (const ContactType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      contact (::std::unique_ptr< ContactType > p);

      //@}

      /**
       * @name correction
       *
       * @brief Accessor and modifier functions for the %correction
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::Parameter CorrectionType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< CorrectionType, char > CorrectionTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const CorrectionType&
      correction () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      CorrectionType&
      correction ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      correction (const CorrectionType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      correction (::std::unique_ptr< CorrectionType > p);

      //@}

      /**
       * @name contactLabel
       *
       * @brief Accessor and modifier functions for the %contactLabel
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::PLabel ContactLabelType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ContactLabelType, char > ContactLabelTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const ContactLabelType&
      contactLabel () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      ContactLabelType&
      contactLabel ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      contactLabel (const ContactLabelType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      contactLabel (::std::unique_ptr< ContactLabelType > p);

      //@}

      /**
       * @name correctionLabel
       *
       * @brief Accessor and modifier functions for the %correctionLabel
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::PLabel CorrectionLabelType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< CorrectionLabelType, char > CorrectionLabelTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const CorrectionLabelType&
      correctionLabel () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      CorrectionLabelType&
      correctionLabel ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      correctionLabel (const CorrectionLabelType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      correctionLabel (::std::unique_ptr< CorrectionLabelType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      SweepProfile (const PickType&,
                    const ContactType&,
                    const CorrectionType&,
                    const ContactLabelType&,
                    const CorrectionLabelType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      SweepProfile (::std::unique_ptr< PickType >,
                    ::std::unique_ptr< ContactType >,
                    ::std::unique_ptr< CorrectionType >,
                    ::std::unique_ptr< ContactLabelType >,
                    ::std::unique_ptr< CorrectionLabelType >);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      SweepProfile (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SweepProfile (const SweepProfile& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual SweepProfile*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SweepProfile&
      operator= (const SweepProfile& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~SweepProfile ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< PickType > pick_;
      ::xsd::cxx::tree::one< ContactType > contact_;
      ::xsd::cxx::tree::one< CorrectionType > correction_;
      ::xsd::cxx::tree::one< ContactLabelType > contactLabel_;
      ::xsd::cxx::tree::one< CorrectionLabelType > correctionLabel_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %SweepProfiles schema type.
     *
     * @nosubgrouping
     */
    class SweepProfiles: public ::xml_schema::Type
    {
      public:
      /**
       * @name array
       *
       * @brief Accessor and modifier functions for the %array
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::SweepProfile ArrayType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< ArrayType > ArraySequence;

      /**
       * @brief Element iterator type.
       */
      typedef ArraySequence::iterator ArrayIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef ArraySequence::const_iterator ArrayConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ArrayType, char > ArrayTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const ArraySequence&
      array () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      ArraySequence&
      array ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      array (const ArraySequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      SweepProfiles ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      SweepProfiles (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SweepProfiles (const SweepProfiles& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual SweepProfiles*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SweepProfiles&
      operator= (const SweepProfiles& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~SweepProfiles ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ArraySequence array_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %SweepAuxiliary schema type.
     *
     * @nosubgrouping
     */
    class SweepAuxiliary: public ::xml_schema::Type
    {
      public:
      /**
       * @name pick
       *
       * @brief Accessor and modifier functions for the %pick
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::Pick PickType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< PickType, char > PickTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const PickType&
      pick () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      PickType&
      pick ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      pick (const PickType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      pick (::std::unique_ptr< PickType > p);

      //@}

      /**
       * @name curvilinearEquivalence
       *
       * @brief Accessor and modifier functions for the %curvilinearEquivalence
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::Parameter CurvilinearEquivalenceType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< CurvilinearEquivalenceType, char > CurvilinearEquivalenceTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const CurvilinearEquivalenceType&
      curvilinearEquivalence () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      CurvilinearEquivalenceType&
      curvilinearEquivalence ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      curvilinearEquivalence (const CurvilinearEquivalenceType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      curvilinearEquivalence (::std::unique_ptr< CurvilinearEquivalenceType > p);

      //@}

      /**
       * @name contactType
       *
       * @brief Accessor and modifier functions for the %contactType
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::Parameter ContactTypeType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ContactTypeType, char > ContactTypeTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const ContactTypeType&
      contactType () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      ContactTypeType&
      contactType ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      contactType (const ContactTypeType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      contactType (::std::unique_ptr< ContactTypeType > p);

      //@}

      /**
       * @name curvilinearEquivalenceLabel
       *
       * @brief Accessor and modifier functions for the %curvilinearEquivalenceLabel
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::PLabel CurvilinearEquivalenceLabelType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< CurvilinearEquivalenceLabelType, char > CurvilinearEquivalenceLabelTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const CurvilinearEquivalenceLabelType&
      curvilinearEquivalenceLabel () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      CurvilinearEquivalenceLabelType&
      curvilinearEquivalenceLabel ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      curvilinearEquivalenceLabel (const CurvilinearEquivalenceLabelType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      curvilinearEquivalenceLabel (::std::unique_ptr< CurvilinearEquivalenceLabelType > p);

      //@}

      /**
       * @name contactTypeLabel
       *
       * @brief Accessor and modifier functions for the %contactTypeLabel
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::PLabel ContactTypeLabelType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ContactTypeLabelType, char > ContactTypeLabelTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const ContactTypeLabelType&
      contactTypeLabel () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      ContactTypeLabelType&
      contactTypeLabel ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      contactTypeLabel (const ContactTypeLabelType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      contactTypeLabel (::std::unique_ptr< ContactTypeLabelType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      SweepAuxiliary (const PickType&,
                      const CurvilinearEquivalenceType&,
                      const ContactTypeType&,
                      const CurvilinearEquivalenceLabelType&,
                      const ContactTypeLabelType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      SweepAuxiliary (::std::unique_ptr< PickType >,
                      ::std::unique_ptr< CurvilinearEquivalenceType >,
                      ::std::unique_ptr< ContactTypeType >,
                      ::std::unique_ptr< CurvilinearEquivalenceLabelType >,
                      ::std::unique_ptr< ContactTypeLabelType >);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      SweepAuxiliary (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SweepAuxiliary (const SweepAuxiliary& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual SweepAuxiliary*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SweepAuxiliary&
      operator= (const SweepAuxiliary& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~SweepAuxiliary ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< PickType > pick_;
      ::xsd::cxx::tree::one< CurvilinearEquivalenceType > curvilinearEquivalence_;
      ::xsd::cxx::tree::one< ContactTypeType > contactType_;
      ::xsd::cxx::tree::one< CurvilinearEquivalenceLabelType > curvilinearEquivalenceLabel_;
      ::xsd::cxx::tree::one< ContactTypeLabelType > contactTypeLabel_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %SweepBinormal schema type.
     *
     * @nosubgrouping
     */
    class SweepBinormal: public ::xml_schema::Type
    {
      public:
      /**
       * @name picks
       *
       * @brief Accessor and modifier functions for the %picks
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::Picks PicksType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< PicksType, char > PicksTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const PicksType&
      picks () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      PicksType&
      picks ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      picks (const PicksType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      picks (::std::unique_ptr< PicksType > p);

      //@}

      /**
       * @name binormal
       *
       * @brief Accessor and modifier functions for the %binormal
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::Parameter BinormalType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< BinormalType, char > BinormalTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const BinormalType&
      binormal () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      BinormalType&
      binormal ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      binormal (const BinormalType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      binormal (::std::unique_ptr< BinormalType > p);

      //@}

      /**
       * @name binormalLabel
       *
       * @brief Accessor and modifier functions for the %binormalLabel
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::PLabel BinormalLabelType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< BinormalLabelType, char > BinormalLabelTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const BinormalLabelType&
      binormalLabel () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      BinormalLabelType&
      binormalLabel ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      binormalLabel (const BinormalLabelType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      binormalLabel (::std::unique_ptr< BinormalLabelType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      SweepBinormal (const PicksType&,
                     const BinormalType&,
                     const BinormalLabelType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      SweepBinormal (::std::unique_ptr< PicksType >,
                     ::std::unique_ptr< BinormalType >,
                     ::std::unique_ptr< BinormalLabelType >);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      SweepBinormal (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SweepBinormal (const SweepBinormal& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual SweepBinormal*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SweepBinormal&
      operator= (const SweepBinormal& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~SweepBinormal ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< PicksType > picks_;
      ::xsd::cxx::tree::one< BinormalType > binormal_;
      ::xsd::cxx::tree::one< BinormalLabelType > binormalLabel_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %InstanceValues schema type.
     *
     * @nosubgrouping
     */
    class InstanceValues: public ::xml_schema::Type
    {
      public:
      /**
       * @name array
       *
       * @brief Accessor and modifier functions for the %array
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String ArrayType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< ArrayType > ArraySequence;

      /**
       * @brief Element iterator type.
       */
      typedef ArraySequence::iterator ArrayIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef ArraySequence::const_iterator ArrayConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ArrayType, char > ArrayTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const ArraySequence&
      array () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      ArraySequence&
      array ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      array (const ArraySequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      InstanceValues ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      InstanceValues (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      InstanceValues (const InstanceValues& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual InstanceValues*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      InstanceValues&
      operator= (const InstanceValues& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~InstanceValues ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ArraySequence array_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %Instance schema type.
     *
     * @nosubgrouping
     */
    class Instance: public ::xml_schema::Type
    {
      public:
      /**
       * @name key
       *
       * @brief Accessor and modifier functions for the %key
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String KeyType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< KeyType, char > KeyTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const KeyType&
      key () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      KeyType&
      key ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      key (const KeyType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      key (::std::unique_ptr< KeyType > p);

      //@}

      /**
       * @name values
       *
       * @brief Accessor and modifier functions for the %values
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::InstanceValues ValuesType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ValuesType, char > ValuesTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const ValuesType&
      values () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      ValuesType&
      values ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      values (const ValuesType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      values (::std::unique_ptr< ValuesType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      Instance (const KeyType&,
                const ValuesType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      Instance (const KeyType&,
                ::std::unique_ptr< ValuesType >);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      Instance (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Instance (const Instance& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual Instance*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Instance&
      operator= (const Instance& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~Instance ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< KeyType > key_;
      ::xsd::cxx::tree::one< ValuesType > values_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %InstanceMap schema type.
     *
     * @nosubgrouping
     */
    class InstanceMap: public ::xml_schema::Type
    {
      public:
      /**
       * @name array
       *
       * @brief Accessor and modifier functions for the %array
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::Instance ArrayType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< ArrayType > ArraySequence;

      /**
       * @brief Element iterator type.
       */
      typedef ArraySequence::iterator ArrayIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef ArraySequence::const_iterator ArrayConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ArrayType, char > ArrayTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const ArraySequence&
      array () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      ArraySequence&
      array ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      array (const ArraySequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      InstanceMap ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      InstanceMap (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      InstanceMap (const InstanceMap& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual InstanceMap*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      InstanceMap&
      operator= (const InstanceMap& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~InstanceMap ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ArraySequence array_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %FeatureSweep schema type.
     *
     * @nosubgrouping
     */
    class FeatureSweep: public ::xml_schema::Type
    {
      public:
      /**
       * @name featureBase
       *
       * @brief Accessor and modifier functions for the %featureBase
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::FeatureBase FeatureBaseType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< FeatureBaseType, char > FeatureBaseTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const FeatureBaseType&
      featureBase () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      FeatureBaseType&
      featureBase ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      featureBase (const FeatureBaseType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      featureBase (::std::unique_ptr< FeatureBaseType > p);

      //@}

      /**
       * @name lawFunction
       *
       * @brief Accessor and modifier functions for the %lawFunction
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::lwf::Cue LawFunctionType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< LawFunctionType, char > LawFunctionTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const LawFunctionType&
      lawFunction () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      LawFunctionType&
      lawFunction ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      lawFunction (const LawFunctionType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      lawFunction (::std::unique_ptr< LawFunctionType > p);

      //@}

      /**
       * @name trihedron
       *
       * @brief Accessor and modifier functions for the %trihedron
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::Parameter TrihedronType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TrihedronType, char > TrihedronTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const TrihedronType&
      trihedron () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      TrihedronType&
      trihedron ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      trihedron (const TrihedronType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      trihedron (::std::unique_ptr< TrihedronType > p);

      //@}

      /**
       * @name transition
       *
       * @brief Accessor and modifier functions for the %transition
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::Parameter TransitionType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TransitionType, char > TransitionTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const TransitionType&
      transition () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      TransitionType&
      transition ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      transition (const TransitionType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      transition (::std::unique_ptr< TransitionType > p);

      //@}

      /**
       * @name forceC1
       *
       * @brief Accessor and modifier functions for the %forceC1
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::Parameter ForceC1Type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ForceC1Type, char > ForceC1Traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const ForceC1Type&
      forceC1 () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      ForceC1Type&
      forceC1 ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      forceC1 (const ForceC1Type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      forceC1 (::std::unique_ptr< ForceC1Type > p);

      //@}

      /**
       * @name solid
       *
       * @brief Accessor and modifier functions for the %solid
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::Parameter SolidType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< SolidType, char > SolidTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const SolidType&
      solid () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      SolidType&
      solid ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      solid (const SolidType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      solid (::std::unique_ptr< SolidType > p);

      //@}

      /**
       * @name useLaw
       *
       * @brief Accessor and modifier functions for the %useLaw
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::Parameter UseLawType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< UseLawType, char > UseLawTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const UseLawType&
      useLaw () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      UseLawType&
      useLaw ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      useLaw (const UseLawType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      useLaw (::std::unique_ptr< UseLawType > p);

      //@}

      /**
       * @name spine
       *
       * @brief Accessor and modifier functions for the %spine
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::Pick SpineType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< SpineType, char > SpineTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const SpineType&
      spine () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      SpineType&
      spine ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      spine (const SpineType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      spine (::std::unique_ptr< SpineType > p);

      //@}

      /**
       * @name profiles
       *
       * @brief Accessor and modifier functions for the %profiles
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::SweepProfiles ProfilesType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ProfilesType, char > ProfilesTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const ProfilesType&
      profiles () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      ProfilesType&
      profiles ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      profiles (const ProfilesType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      profiles (::std::unique_ptr< ProfilesType > p);

      //@}

      /**
       * @name auxiliary
       *
       * @brief Accessor and modifier functions for the %auxiliary
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::SweepAuxiliary AuxiliaryType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< AuxiliaryType, char > AuxiliaryTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const AuxiliaryType&
      auxiliary () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      AuxiliaryType&
      auxiliary ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      auxiliary (const AuxiliaryType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      auxiliary (::std::unique_ptr< AuxiliaryType > p);

      //@}

      /**
       * @name support
       *
       * @brief Accessor and modifier functions for the %support
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::Pick SupportType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< SupportType, char > SupportTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const SupportType&
      support () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      SupportType&
      support ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      support (const SupportType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      support (::std::unique_ptr< SupportType > p);

      //@}

      /**
       * @name binormal
       *
       * @brief Accessor and modifier functions for the %binormal
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::SweepBinormal BinormalType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< BinormalType, char > BinormalTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const BinormalType&
      binormal () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      BinormalType&
      binormal ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      binormal (const BinormalType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      binormal (::std::unique_ptr< BinormalType > p);

      //@}

      /**
       * @name trihedronLabel
       *
       * @brief Accessor and modifier functions for the %trihedronLabel
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::PLabel TrihedronLabelType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TrihedronLabelType, char > TrihedronLabelTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const TrihedronLabelType&
      trihedronLabel () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      TrihedronLabelType&
      trihedronLabel ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      trihedronLabel (const TrihedronLabelType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      trihedronLabel (::std::unique_ptr< TrihedronLabelType > p);

      //@}

      /**
       * @name transitionLabel
       *
       * @brief Accessor and modifier functions for the %transitionLabel
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::PLabel TransitionLabelType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TransitionLabelType, char > TransitionLabelTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const TransitionLabelType&
      transitionLabel () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      TransitionLabelType&
      transitionLabel ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      transitionLabel (const TransitionLabelType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      transitionLabel (::std::unique_ptr< TransitionLabelType > p);

      //@}

      /**
       * @name forceC1Label
       *
       * @brief Accessor and modifier functions for the %forceC1Label
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::PLabel ForceC1LabelType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ForceC1LabelType, char > ForceC1LabelTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const ForceC1LabelType&
      forceC1Label () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      ForceC1LabelType&
      forceC1Label ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      forceC1Label (const ForceC1LabelType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      forceC1Label (::std::unique_ptr< ForceC1LabelType > p);

      //@}

      /**
       * @name solidLabel
       *
       * @brief Accessor and modifier functions for the %solidLabel
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::PLabel SolidLabelType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< SolidLabelType, char > SolidLabelTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const SolidLabelType&
      solidLabel () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      SolidLabelType&
      solidLabel ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      solidLabel (const SolidLabelType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      solidLabel (::std::unique_ptr< SolidLabelType > p);

      //@}

      /**
       * @name useLawLabel
       *
       * @brief Accessor and modifier functions for the %useLawLabel
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::PLabel UseLawLabelType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< UseLawLabelType, char > UseLawLabelTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const UseLawLabelType&
      useLawLabel () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      UseLawLabelType&
      useLawLabel ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      useLawLabel (const UseLawLabelType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      useLawLabel (::std::unique_ptr< UseLawLabelType > p);

      //@}

      /**
       * @name lawVizMatrix
       *
       * @brief Accessor and modifier functions for the %lawVizMatrix
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::Matrixd LawVizMatrixType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< LawVizMatrixType, char > LawVizMatrixTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const LawVizMatrixType&
      lawVizMatrix () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      LawVizMatrixType&
      lawVizMatrix ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      lawVizMatrix (const LawVizMatrixType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      lawVizMatrix (::std::unique_ptr< LawVizMatrixType > p);

      //@}

      /**
       * @name lawVizScale
       *
       * @brief Accessor and modifier functions for the %lawVizScale
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::Double LawVizScaleType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< LawVizScaleType, char, ::xsd::cxx::tree::schema_type::double_ > LawVizScaleTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const LawVizScaleType&
      lawVizScale () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      LawVizScaleType&
      lawVizScale ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      lawVizScale (const LawVizScaleType& x);

      //@}

      /**
       * @name solidId
       *
       * @brief Accessor and modifier functions for the %solidId
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String SolidIdType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< SolidIdType, char > SolidIdTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const SolidIdType&
      solidId () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      SolidIdType&
      solidId ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      solidId (const SolidIdType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      solidId (::std::unique_ptr< SolidIdType > p);

      //@}

      /**
       * @name shellId
       *
       * @brief Accessor and modifier functions for the %shellId
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String ShellIdType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ShellIdType, char > ShellIdTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const ShellIdType&
      shellId () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      ShellIdType&
      shellId ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      shellId (const ShellIdType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      shellId (::std::unique_ptr< ShellIdType > p);

      //@}

      /**
       * @name firstFaceId
       *
       * @brief Accessor and modifier functions for the %firstFaceId
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String FirstFaceIdType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< FirstFaceIdType, char > FirstFaceIdTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const FirstFaceIdType&
      firstFaceId () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      FirstFaceIdType&
      firstFaceId ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      firstFaceId (const FirstFaceIdType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      firstFaceId (::std::unique_ptr< FirstFaceIdType > p);

      //@}

      /**
       * @name lastFaceId
       *
       * @brief Accessor and modifier functions for the %lastFaceId
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String LastFaceIdType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< LastFaceIdType, char > LastFaceIdTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const LastFaceIdType&
      lastFaceId () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      LastFaceIdType&
      lastFaceId ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      lastFaceId (const LastFaceIdType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      lastFaceId (::std::unique_ptr< LastFaceIdType > p);

      //@}

      /**
       * @name outerWireMap
       *
       * @brief Accessor and modifier functions for the %outerWireMap
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::EvolveContainer OuterWireMapType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< OuterWireMapType, char > OuterWireMapTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const OuterWireMapType&
      outerWireMap () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      OuterWireMapType&
      outerWireMap ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      outerWireMap (const OuterWireMapType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      outerWireMap (::std::unique_ptr< OuterWireMapType > p);

      //@}

      /**
       * @name instanceMap
       *
       * @brief Accessor and modifier functions for the %instanceMap
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::InstanceMap InstanceMapType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< InstanceMapType, char > InstanceMapTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const InstanceMapType&
      instanceMap () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      InstanceMapType&
      instanceMap ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      instanceMap (const InstanceMapType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      instanceMap (::std::unique_ptr< InstanceMapType > p);

      //@}

      /**
       * @name firstShapeMap
       *
       * @brief Accessor and modifier functions for the %firstShapeMap
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::EvolveContainer FirstShapeMapType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< FirstShapeMapType, char > FirstShapeMapTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const FirstShapeMapType&
      firstShapeMap () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      FirstShapeMapType&
      firstShapeMap ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      firstShapeMap (const FirstShapeMapType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      firstShapeMap (::std::unique_ptr< FirstShapeMapType > p);

      //@}

      /**
       * @name lastShapeMap
       *
       * @brief Accessor and modifier functions for the %lastShapeMap
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::prj::srl::EvolveContainer LastShapeMapType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< LastShapeMapType, char > LastShapeMapTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const LastShapeMapType&
      lastShapeMap () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      LastShapeMapType&
      lastShapeMap ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      lastShapeMap (const LastShapeMapType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      lastShapeMap (::std::unique_ptr< LastShapeMapType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      FeatureSweep (const FeatureBaseType&,
                    const LawFunctionType&,
                    const TrihedronType&,
                    const TransitionType&,
                    const ForceC1Type&,
                    const SolidType&,
                    const UseLawType&,
                    const SpineType&,
                    const ProfilesType&,
                    const AuxiliaryType&,
                    const SupportType&,
                    const BinormalType&,
                    const TrihedronLabelType&,
                    const TransitionLabelType&,
                    const ForceC1LabelType&,
                    const SolidLabelType&,
                    const UseLawLabelType&,
                    const LawVizMatrixType&,
                    const LawVizScaleType&,
                    const SolidIdType&,
                    const ShellIdType&,
                    const FirstFaceIdType&,
                    const LastFaceIdType&,
                    const OuterWireMapType&,
                    const InstanceMapType&,
                    const FirstShapeMapType&,
                    const LastShapeMapType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      FeatureSweep (::std::unique_ptr< FeatureBaseType >,
                    ::std::unique_ptr< LawFunctionType >,
                    ::std::unique_ptr< TrihedronType >,
                    ::std::unique_ptr< TransitionType >,
                    ::std::unique_ptr< ForceC1Type >,
                    ::std::unique_ptr< SolidType >,
                    ::std::unique_ptr< UseLawType >,
                    ::std::unique_ptr< SpineType >,
                    ::std::unique_ptr< ProfilesType >,
                    ::std::unique_ptr< AuxiliaryType >,
                    ::std::unique_ptr< SupportType >,
                    ::std::unique_ptr< BinormalType >,
                    ::std::unique_ptr< TrihedronLabelType >,
                    ::std::unique_ptr< TransitionLabelType >,
                    ::std::unique_ptr< ForceC1LabelType >,
                    ::std::unique_ptr< SolidLabelType >,
                    ::std::unique_ptr< UseLawLabelType >,
                    ::std::unique_ptr< LawVizMatrixType >,
                    const LawVizScaleType&,
                    const SolidIdType&,
                    const ShellIdType&,
                    const FirstFaceIdType&,
                    const LastFaceIdType&,
                    ::std::unique_ptr< OuterWireMapType >,
                    ::std::unique_ptr< InstanceMapType >,
                    ::std::unique_ptr< FirstShapeMapType >,
                    ::std::unique_ptr< LastShapeMapType >);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      FeatureSweep (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      FeatureSweep (const FeatureSweep& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual FeatureSweep*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      FeatureSweep&
      operator= (const FeatureSweep& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~FeatureSweep ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< FeatureBaseType > featureBase_;
      ::xsd::cxx::tree::one< LawFunctionType > lawFunction_;
      ::xsd::cxx::tree::one< TrihedronType > trihedron_;
      ::xsd::cxx::tree::one< TransitionType > transition_;
      ::xsd::cxx::tree::one< ForceC1Type > forceC1_;
      ::xsd::cxx::tree::one< SolidType > solid_;
      ::xsd::cxx::tree::one< UseLawType > useLaw_;
      ::xsd::cxx::tree::one< SpineType > spine_;
      ::xsd::cxx::tree::one< ProfilesType > profiles_;
      ::xsd::cxx::tree::one< AuxiliaryType > auxiliary_;
      ::xsd::cxx::tree::one< SupportType > support_;
      ::xsd::cxx::tree::one< BinormalType > binormal_;
      ::xsd::cxx::tree::one< TrihedronLabelType > trihedronLabel_;
      ::xsd::cxx::tree::one< TransitionLabelType > transitionLabel_;
      ::xsd::cxx::tree::one< ForceC1LabelType > forceC1Label_;
      ::xsd::cxx::tree::one< SolidLabelType > solidLabel_;
      ::xsd::cxx::tree::one< UseLawLabelType > useLawLabel_;
      ::xsd::cxx::tree::one< LawVizMatrixType > lawVizMatrix_;
      ::xsd::cxx::tree::one< LawVizScaleType > lawVizScale_;
      ::xsd::cxx::tree::one< SolidIdType > solidId_;
      ::xsd::cxx::tree::one< ShellIdType > shellId_;
      ::xsd::cxx::tree::one< FirstFaceIdType > firstFaceId_;
      ::xsd::cxx::tree::one< LastFaceIdType > lastFaceId_;
      ::xsd::cxx::tree::one< OuterWireMapType > outerWireMap_;
      ::xsd::cxx::tree::one< InstanceMapType > instanceMap_;
      ::xsd::cxx::tree::one< FirstShapeMapType > firstShapeMap_;
      ::xsd::cxx::tree::one< LastShapeMapType > lastShapeMap_;

      //@endcond
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace prj
{
  namespace srl
  {
    /**
     * @name Parsing functions for the %sweep document root.
     */
    //@{

    /**
     * @brief Parse a URI or a local file.
     *
     * @param uri A URI or a local file name.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function uses exceptions to report parsing errors.
     */
    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (const ::std::string& uri,
           ::xml_schema::Flags f = 0,
           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a URI or a local file with an error handler.
     *
     * @param uri A URI or a local file name.
     * @param eh An error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (const ::std::string& uri,
           ::xml_schema::ErrorHandler& eh,
           ::xml_schema::Flags f = 0,
           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a URI or a local file with a Xerces-C++ DOM error
     * handler.
     *
     * @param uri A URI or a local file name.
     * @param eh A Xerces-C++ DOM error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (const ::std::string& uri,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::Flags f = 0,
           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a standard input stream.
     *
     * @param is A standrad input stream.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function uses exceptions to report parsing errors.
     */
    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::std::istream& is,
           ::xml_schema::Flags f = 0,
           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a standard input stream with an error handler.
     *
     * @param is A standrad input stream.
     * @param eh An error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::std::istream& is,
           ::xml_schema::ErrorHandler& eh,
           ::xml_schema::Flags f = 0,
           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a standard input stream with a Xerces-C++ DOM error
     * handler.
     *
     * @param is A standrad input stream.
     * @param eh A Xerces-C++ DOM error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::std::istream& is,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::Flags f = 0,
           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a standard input stream with a resource id.
     *
     * @param is A standrad input stream.
     * @param id A resource id.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * The resource id is used to identify the document being parsed in
     * diagnostics as well as to resolve relative paths.
     *
     * This function uses exceptions to report parsing errors.
     */
    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::std::istream& is,
           const ::std::string& id,
           ::xml_schema::Flags f = 0,
           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a standard input stream with a resource id and an
     * error handler.
     *
     * @param is A standrad input stream.
     * @param id A resource id.
     * @param eh An error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * The resource id is used to identify the document being parsed in
     * diagnostics as well as to resolve relative paths.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::std::istream& is,
           const ::std::string& id,
           ::xml_schema::ErrorHandler& eh,
           ::xml_schema::Flags f = 0,
           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a standard input stream with a resource id and a
     * Xerces-C++ DOM error handler.
     *
     * @param is A standrad input stream.
     * @param id A resource id.
     * @param eh A Xerces-C++ DOM error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * The resource id is used to identify the document being parsed in
     * diagnostics as well as to resolve relative paths.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::std::istream& is,
           const ::std::string& id,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::Flags f = 0,
           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a Xerces-C++ input source.
     *
     * @param is A Xerces-C++ input source.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function uses exceptions to report parsing errors.
     */
    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::xercesc::InputSource& is,
           ::xml_schema::Flags f = 0,
           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a Xerces-C++ input source with an error handler.
     *
     * @param is A Xerces-C++ input source.
     * @param eh An error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::xercesc::InputSource& is,
           ::xml_schema::ErrorHandler& eh,
           ::xml_schema::Flags f = 0,
           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
     * error handler.
     *
     * @param is A Xerces-C++ input source.
     * @param eh A Xerces-C++ DOM error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::xercesc::InputSource& is,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::Flags f = 0,
           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a Xerces-C++ DOM document.
     *
     * @param d A Xerces-C++ DOM document.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     */
    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (const ::xercesc::DOMDocument& d,
           ::xml_schema::Flags f = 0,
           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a Xerces-C++ DOM document.
     *
     * @param d A pointer to the Xerces-C++ DOM document.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function is normally used together with the keep_dom and
     * own_dom parsing flags to assign ownership of the DOM document
     * to the object model.
     */
    ::std::unique_ptr< ::prj::srl::FeatureSweep >
    sweep (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::Flags f = 0,
           const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    //@}
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace prj
{
  namespace srl
  {
    void
    operator<< (::xercesc::DOMElement&, const SweepProfile&);

    void
    operator<< (::xercesc::DOMElement&, const SweepProfiles&);

    void
    operator<< (::xercesc::DOMElement&, const SweepAuxiliary&);

    void
    operator<< (::xercesc::DOMElement&, const SweepBinormal&);

    void
    operator<< (::xercesc::DOMElement&, const InstanceValues&);

    void
    operator<< (::xercesc::DOMElement&, const Instance&);

    void
    operator<< (::xercesc::DOMElement&, const InstanceMap&);

    void
    operator<< (::xercesc::DOMElement&, const FeatureSweep&);

    /**
     * @name Serialization functions for the %sweep document root.
     */
    //@{

    /**
     * @brief Serialize to a standard output stream.
     *
     * @param os A standrad output stream.
     * @param x An object model to serialize.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function uses exceptions to report serialization errors.
     */
    void
    sweep (::std::ostream& os,
           const ::prj::srl::FeatureSweep& x, 
           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::Flags f = 0);

    /**
     * @brief Serialize to a standard output stream with an error handler.
     *
     * @param os A standrad output stream.
     * @param x An object model to serialize.
     * @param eh An error handler.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function reports serialization errors by calling the error
     * handler.
     */
    void
    sweep (::std::ostream& os,
           const ::prj::srl::FeatureSweep& x, 
           ::xml_schema::ErrorHandler& eh,
           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::Flags f = 0);

    /**
     * @brief Serialize to a standard output stream with a Xerces-C++ DOM
     * error handler.
     *
     * @param os A standrad output stream.
     * @param x An object model to serialize.
     * @param eh A Xerces-C++ DOM error handler.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function reports serialization errors by calling the error
     * handler.
     */
    void
    sweep (::std::ostream& os,
           const ::prj::srl::FeatureSweep& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::Flags f = 0);

    /**
     * @brief Serialize to a Xerces-C++ XML format target.
     *
     * @param ft A Xerces-C++ XML format target.
     * @param x An object model to serialize.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function uses exceptions to report serialization errors.
     */
    void
    sweep (::xercesc::XMLFormatTarget& ft,
           const ::prj::srl::FeatureSweep& x, 
           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::Flags f = 0);

    /**
     * @brief Serialize to a Xerces-C++ XML format target with an error
     * handler.
     *
     * @param ft A Xerces-C++ XML format target.
     * @param x An object model to serialize.
     * @param eh An error handler.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function reports serialization errors by calling the error
     * handler.
     */
    void
    sweep (::xercesc::XMLFormatTarget& ft,
           const ::prj::srl::FeatureSweep& x, 
           ::xml_schema::ErrorHandler& eh,
           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::Flags f = 0);

    /**
     * @brief Serialize to a Xerces-C++ XML format target with a
     * Xerces-C++ DOM error handler.
     *
     * @param ft A Xerces-C++ XML format target.
     * @param x An object model to serialize.
     * @param eh A Xerces-C++ DOM error handler.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function reports serialization errors by calling the error
     * handler.
     */
    void
    sweep (::xercesc::XMLFormatTarget& ft,
           const ::prj::srl::FeatureSweep& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::Flags f = 0);

    /**
     * @brief Serialize to an existing Xerces-C++ DOM document.
     *
     * @param d A Xerces-C++ DOM document.
     * @param x An object model to serialize.
     * @param f Serialization flags.
     *
     * Note that it is your responsibility to create the DOM document
     * with the correct root element as well as set the necessary
     * namespace mapping attributes.
     */
    void
    sweep (::xercesc::DOMDocument& d,
           const ::prj::srl::FeatureSweep& x,
           ::xml_schema::Flags f = 0);

    /**
     * @brief Serialize to a new Xerces-C++ DOM document.
     *
     * @param x An object model to serialize.
     * @param m A namespace information map.
     * @param f Serialization flags.
     * @return A pointer to the new Xerces-C++ DOM document.
     */
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    sweep (const ::prj::srl::FeatureSweep& x, 
           const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
           ::xml_schema::Flags f = 0);

    //@}
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // PRJ_SRL_FEATURESWEEP_H
