// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "mesh.h"

namespace prj
{
  namespace srl
  {
    namespace msh
    {
      // ParametersOCCT
      // 

      const ParametersOCCT::LinearDeflectionType& ParametersOCCT::
      linearDeflection () const
      {
        return this->linearDeflection_.get ();
      }

      ParametersOCCT::LinearDeflectionType& ParametersOCCT::
      linearDeflection ()
      {
        return this->linearDeflection_.get ();
      }

      void ParametersOCCT::
      linearDeflection (const LinearDeflectionType& x)
      {
        this->linearDeflection_.set (x);
      }

      const ParametersOCCT::AngularDeflectionType& ParametersOCCT::
      angularDeflection () const
      {
        return this->angularDeflection_.get ();
      }

      ParametersOCCT::AngularDeflectionType& ParametersOCCT::
      angularDeflection ()
      {
        return this->angularDeflection_.get ();
      }

      void ParametersOCCT::
      angularDeflection (const AngularDeflectionType& x)
      {
        this->angularDeflection_.set (x);
      }

      const ParametersOCCT::RelativeType& ParametersOCCT::
      relative () const
      {
        return this->relative_.get ();
      }

      ParametersOCCT::RelativeType& ParametersOCCT::
      relative ()
      {
        return this->relative_.get ();
      }

      void ParametersOCCT::
      relative (const RelativeType& x)
      {
        this->relative_.set (x);
      }

      const ParametersOCCT::MinAreaType& ParametersOCCT::
      minArea () const
      {
        return this->minArea_.get ();
      }

      ParametersOCCT::MinAreaType& ParametersOCCT::
      minArea ()
      {
        return this->minArea_.get ();
      }

      void ParametersOCCT::
      minArea (const MinAreaType& x)
      {
        this->minArea_.set (x);
      }


      // ParametersNetgen
      // 

      const ParametersNetgen::UseLocalHType& ParametersNetgen::
      useLocalH () const
      {
        return this->useLocalH_.get ();
      }

      ParametersNetgen::UseLocalHType& ParametersNetgen::
      useLocalH ()
      {
        return this->useLocalH_.get ();
      }

      void ParametersNetgen::
      useLocalH (const UseLocalHType& x)
      {
        this->useLocalH_.set (x);
      }

      const ParametersNetgen::MaxHType& ParametersNetgen::
      maxH () const
      {
        return this->maxH_.get ();
      }

      ParametersNetgen::MaxHType& ParametersNetgen::
      maxH ()
      {
        return this->maxH_.get ();
      }

      void ParametersNetgen::
      maxH (const MaxHType& x)
      {
        this->maxH_.set (x);
      }

      const ParametersNetgen::MinHType& ParametersNetgen::
      minH () const
      {
        return this->minH_.get ();
      }

      ParametersNetgen::MinHType& ParametersNetgen::
      minH ()
      {
        return this->minH_.get ();
      }

      void ParametersNetgen::
      minH (const MinHType& x)
      {
        this->minH_.set (x);
      }

      const ParametersNetgen::FinenessType& ParametersNetgen::
      fineness () const
      {
        return this->fineness_.get ();
      }

      ParametersNetgen::FinenessType& ParametersNetgen::
      fineness ()
      {
        return this->fineness_.get ();
      }

      void ParametersNetgen::
      fineness (const FinenessType& x)
      {
        this->fineness_.set (x);
      }

      const ParametersNetgen::GradingType& ParametersNetgen::
      grading () const
      {
        return this->grading_.get ();
      }

      ParametersNetgen::GradingType& ParametersNetgen::
      grading ()
      {
        return this->grading_.get ();
      }

      void ParametersNetgen::
      grading (const GradingType& x)
      {
        this->grading_.set (x);
      }

      const ParametersNetgen::ElementsPerEdgeType& ParametersNetgen::
      elementsPerEdge () const
      {
        return this->elementsPerEdge_.get ();
      }

      ParametersNetgen::ElementsPerEdgeType& ParametersNetgen::
      elementsPerEdge ()
      {
        return this->elementsPerEdge_.get ();
      }

      void ParametersNetgen::
      elementsPerEdge (const ElementsPerEdgeType& x)
      {
        this->elementsPerEdge_.set (x);
      }

      const ParametersNetgen::ElementsPerCurveType& ParametersNetgen::
      elementsPerCurve () const
      {
        return this->elementsPerCurve_.get ();
      }

      ParametersNetgen::ElementsPerCurveType& ParametersNetgen::
      elementsPerCurve ()
      {
        return this->elementsPerCurve_.get ();
      }

      void ParametersNetgen::
      elementsPerCurve (const ElementsPerCurveType& x)
      {
        this->elementsPerCurve_.set (x);
      }

      const ParametersNetgen::CloseEdgeEnableType& ParametersNetgen::
      closeEdgeEnable () const
      {
        return this->closeEdgeEnable_.get ();
      }

      ParametersNetgen::CloseEdgeEnableType& ParametersNetgen::
      closeEdgeEnable ()
      {
        return this->closeEdgeEnable_.get ();
      }

      void ParametersNetgen::
      closeEdgeEnable (const CloseEdgeEnableType& x)
      {
        this->closeEdgeEnable_.set (x);
      }

      const ParametersNetgen::CloseEdgeFactorType& ParametersNetgen::
      closeEdgeFactor () const
      {
        return this->closeEdgeFactor_.get ();
      }

      ParametersNetgen::CloseEdgeFactorType& ParametersNetgen::
      closeEdgeFactor ()
      {
        return this->closeEdgeFactor_.get ();
      }

      void ParametersNetgen::
      closeEdgeFactor (const CloseEdgeFactorType& x)
      {
        this->closeEdgeFactor_.set (x);
      }

      const ParametersNetgen::MinEdgeLenEnableType& ParametersNetgen::
      minEdgeLenEnable () const
      {
        return this->minEdgeLenEnable_.get ();
      }

      ParametersNetgen::MinEdgeLenEnableType& ParametersNetgen::
      minEdgeLenEnable ()
      {
        return this->minEdgeLenEnable_.get ();
      }

      void ParametersNetgen::
      minEdgeLenEnable (const MinEdgeLenEnableType& x)
      {
        this->minEdgeLenEnable_.set (x);
      }

      const ParametersNetgen::MinEdgeLenType& ParametersNetgen::
      minEdgeLen () const
      {
        return this->minEdgeLen_.get ();
      }

      ParametersNetgen::MinEdgeLenType& ParametersNetgen::
      minEdgeLen ()
      {
        return this->minEdgeLen_.get ();
      }

      void ParametersNetgen::
      minEdgeLen (const MinEdgeLenType& x)
      {
        this->minEdgeLen_.set (x);
      }

      const ParametersNetgen::SecondOrderType& ParametersNetgen::
      secondOrder () const
      {
        return this->secondOrder_.get ();
      }

      ParametersNetgen::SecondOrderType& ParametersNetgen::
      secondOrder ()
      {
        return this->secondOrder_.get ();
      }

      void ParametersNetgen::
      secondOrder (const SecondOrderType& x)
      {
        this->secondOrder_.set (x);
      }

      const ParametersNetgen::QuadDominatedType& ParametersNetgen::
      quadDominated () const
      {
        return this->quadDominated_.get ();
      }

      ParametersNetgen::QuadDominatedType& ParametersNetgen::
      quadDominated ()
      {
        return this->quadDominated_.get ();
      }

      void ParametersNetgen::
      quadDominated (const QuadDominatedType& x)
      {
        this->quadDominated_.set (x);
      }

      const ParametersNetgen::OptSurfMeshEnableType& ParametersNetgen::
      optSurfMeshEnable () const
      {
        return this->optSurfMeshEnable_.get ();
      }

      ParametersNetgen::OptSurfMeshEnableType& ParametersNetgen::
      optSurfMeshEnable ()
      {
        return this->optSurfMeshEnable_.get ();
      }

      void ParametersNetgen::
      optSurfMeshEnable (const OptSurfMeshEnableType& x)
      {
        this->optSurfMeshEnable_.set (x);
      }

      const ParametersNetgen::OptVolMeshEnableType& ParametersNetgen::
      optVolMeshEnable () const
      {
        return this->optVolMeshEnable_.get ();
      }

      ParametersNetgen::OptVolMeshEnableType& ParametersNetgen::
      optVolMeshEnable ()
      {
        return this->optVolMeshEnable_.get ();
      }

      void ParametersNetgen::
      optVolMeshEnable (const OptVolMeshEnableType& x)
      {
        this->optVolMeshEnable_.set (x);
      }

      const ParametersNetgen::OptSteps2dType& ParametersNetgen::
      optSteps2d () const
      {
        return this->optSteps2d_.get ();
      }

      ParametersNetgen::OptSteps2dType& ParametersNetgen::
      optSteps2d ()
      {
        return this->optSteps2d_.get ();
      }

      void ParametersNetgen::
      optSteps2d (const OptSteps2dType& x)
      {
        this->optSteps2d_.set (x);
      }

      const ParametersNetgen::OptSteps3dType& ParametersNetgen::
      optSteps3d () const
      {
        return this->optSteps3d_.get ();
      }

      ParametersNetgen::OptSteps3dType& ParametersNetgen::
      optSteps3d ()
      {
        return this->optSteps3d_.get ();
      }

      void ParametersNetgen::
      optSteps3d (const OptSteps3dType& x)
      {
        this->optSteps3d_.set (x);
      }

      const ParametersNetgen::InvertTetsType& ParametersNetgen::
      invertTets () const
      {
        return this->invertTets_.get ();
      }

      ParametersNetgen::InvertTetsType& ParametersNetgen::
      invertTets ()
      {
        return this->invertTets_.get ();
      }

      void ParametersNetgen::
      invertTets (const InvertTetsType& x)
      {
        this->invertTets_.set (x);
      }

      const ParametersNetgen::InvertTrigsType& ParametersNetgen::
      invertTrigs () const
      {
        return this->invertTrigs_.get ();
      }

      ParametersNetgen::InvertTrigsType& ParametersNetgen::
      invertTrigs ()
      {
        return this->invertTrigs_.get ();
      }

      void ParametersNetgen::
      invertTrigs (const InvertTrigsType& x)
      {
        this->invertTrigs_.set (x);
      }

      const ParametersNetgen::CheckOverlapType& ParametersNetgen::
      checkOverlap () const
      {
        return this->checkOverlap_.get ();
      }

      ParametersNetgen::CheckOverlapType& ParametersNetgen::
      checkOverlap ()
      {
        return this->checkOverlap_.get ();
      }

      void ParametersNetgen::
      checkOverlap (const CheckOverlapType& x)
      {
        this->checkOverlap_.set (x);
      }

      const ParametersNetgen::CheckOverlappingBoundaryType& ParametersNetgen::
      checkOverlappingBoundary () const
      {
        return this->checkOverlappingBoundary_.get ();
      }

      ParametersNetgen::CheckOverlappingBoundaryType& ParametersNetgen::
      checkOverlappingBoundary ()
      {
        return this->checkOverlappingBoundary_.get ();
      }

      void ParametersNetgen::
      checkOverlappingBoundary (const CheckOverlappingBoundaryType& x)
      {
        this->checkOverlappingBoundary_.set (x);
      }


      // ParametersGMSHOption
      // 

      const ParametersGMSHOption::KeyType& ParametersGMSHOption::
      key () const
      {
        return this->key_.get ();
      }

      ParametersGMSHOption::KeyType& ParametersGMSHOption::
      key ()
      {
        return this->key_.get ();
      }

      void ParametersGMSHOption::
      key (const KeyType& x)
      {
        this->key_.set (x);
      }

      void ParametersGMSHOption::
      key (::std::unique_ptr< KeyType > x)
      {
        this->key_.set (std::move (x));
      }

      const ParametersGMSHOption::ValueType& ParametersGMSHOption::
      value () const
      {
        return this->value_.get ();
      }

      ParametersGMSHOption::ValueType& ParametersGMSHOption::
      value ()
      {
        return this->value_.get ();
      }

      void ParametersGMSHOption::
      value (const ValueType& x)
      {
        this->value_.set (x);
      }


      // ParametersGMSHOptions
      // 

      const ParametersGMSHOptions::ArraySequence& ParametersGMSHOptions::
      array () const
      {
        return this->array_;
      }

      ParametersGMSHOptions::ArraySequence& ParametersGMSHOptions::
      array ()
      {
        return this->array_;
      }

      void ParametersGMSHOptions::
      array (const ArraySequence& s)
      {
        this->array_ = s;
      }


      // ParametersGMSH
      // 

      const ParametersGMSH::OptionsType& ParametersGMSH::
      options () const
      {
        return this->options_.get ();
      }

      ParametersGMSH::OptionsType& ParametersGMSH::
      options ()
      {
        return this->options_.get ();
      }

      void ParametersGMSH::
      options (const OptionsType& x)
      {
        this->options_.set (x);
      }

      void ParametersGMSH::
      options (::std::unique_ptr< OptionsType > x)
      {
        this->options_.set (std::move (x));
      }

      const ParametersGMSH::RefineType& ParametersGMSH::
      refine () const
      {
        return this->refine_.get ();
      }

      ParametersGMSH::RefineType& ParametersGMSH::
      refine ()
      {
        return this->refine_.get ();
      }

      void ParametersGMSH::
      refine (const RefineType& x)
      {
        this->refine_.set (x);
      }


      // Point
      // 

      const Point::XType& Point::
      x () const
      {
        return this->x_.get ();
      }

      Point::XType& Point::
      x ()
      {
        return this->x_.get ();
      }

      void Point::
      x (const XType& x)
      {
        this->x_.set (x);
      }

      const Point::YType& Point::
      y () const
      {
        return this->y_.get ();
      }

      Point::YType& Point::
      y ()
      {
        return this->y_.get ();
      }

      void Point::
      y (const YType& x)
      {
        this->y_.set (x);
      }

      const Point::ZType& Point::
      z () const
      {
        return this->z_.get ();
      }

      Point::ZType& Point::
      z ()
      {
        return this->z_.get ();
      }

      void Point::
      z (const ZType& x)
      {
        this->z_.set (x);
      }


      // Points
      // 

      const Points::ArraySequence& Points::
      array () const
      {
        return this->array_;
      }

      Points::ArraySequence& Points::
      array ()
      {
        return this->array_;
      }

      void Points::
      array (const ArraySequence& s)
      {
        this->array_ = s;
      }


      // Indexes
      // 

      const Indexes::ArraySequence& Indexes::
      array () const
      {
        return this->array_;
      }

      Indexes::ArraySequence& Indexes::
      array ()
      {
        return this->array_;
      }

      void Indexes::
      array (const ArraySequence& s)
      {
        this->array_ = s;
      }


      // Face
      // 

      const Face::IndexesType& Face::
      indexes () const
      {
        return this->indexes_.get ();
      }

      Face::IndexesType& Face::
      indexes ()
      {
        return this->indexes_.get ();
      }

      void Face::
      indexes (const IndexesType& x)
      {
        this->indexes_.set (x);
      }

      void Face::
      indexes (::std::unique_ptr< IndexesType > x)
      {
        this->indexes_.set (std::move (x));
      }


      // Faces
      // 

      const Faces::ArraySequence& Faces::
      array () const
      {
        return this->array_;
      }

      Faces::ArraySequence& Faces::
      array ()
      {
        return this->array_;
      }

      void Faces::
      array (const ArraySequence& s)
      {
        this->array_ = s;
      }


      // Surface
      // 

      const Surface::PointsType& Surface::
      points () const
      {
        return this->points_.get ();
      }

      Surface::PointsType& Surface::
      points ()
      {
        return this->points_.get ();
      }

      void Surface::
      points (const PointsType& x)
      {
        this->points_.set (x);
      }

      void Surface::
      points (::std::unique_ptr< PointsType > x)
      {
        this->points_.set (std::move (x));
      }

      const Surface::FacesType& Surface::
      faces () const
      {
        return this->faces_.get ();
      }

      Surface::FacesType& Surface::
      faces ()
      {
        return this->faces_.get ();
      }

      void Surface::
      faces (const FacesType& x)
      {
        this->faces_.set (x);
      }

      void Surface::
      faces (::std::unique_ptr< FacesType > x)
      {
        this->faces_.set (std::move (x));
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace msh
    {
      // ParametersOCCT
      //

      ParametersOCCT::
      ParametersOCCT (const LinearDeflectionType& linearDeflection,
                      const AngularDeflectionType& angularDeflection,
                      const RelativeType& relative,
                      const MinAreaType& minArea)
      : ::xml_schema::Type (),
        linearDeflection_ (linearDeflection, this),
        angularDeflection_ (angularDeflection, this),
        relative_ (relative, this),
        minArea_ (minArea, this)
      {
      }

      ParametersOCCT::
      ParametersOCCT (const ParametersOCCT& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        linearDeflection_ (x.linearDeflection_, f, this),
        angularDeflection_ (x.angularDeflection_, f, this),
        relative_ (x.relative_, f, this),
        minArea_ (x.minArea_, f, this)
      {
      }

      ParametersOCCT::
      ParametersOCCT (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        linearDeflection_ (this),
        angularDeflection_ (this),
        relative_ (this),
        minArea_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void ParametersOCCT::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // linearDeflection
          //
          if (n.name () == "linearDeflection" && n.namespace_ ().empty ())
          {
            if (!linearDeflection_.present ())
            {
              this->linearDeflection_.set (LinearDeflectionTraits::create (i, f, this));
              continue;
            }
          }

          // angularDeflection
          //
          if (n.name () == "angularDeflection" && n.namespace_ ().empty ())
          {
            if (!angularDeflection_.present ())
            {
              this->angularDeflection_.set (AngularDeflectionTraits::create (i, f, this));
              continue;
            }
          }

          // relative
          //
          if (n.name () == "relative" && n.namespace_ ().empty ())
          {
            if (!relative_.present ())
            {
              this->relative_.set (RelativeTraits::create (i, f, this));
              continue;
            }
          }

          // minArea
          //
          if (n.name () == "minArea" && n.namespace_ ().empty ())
          {
            if (!minArea_.present ())
            {
              this->minArea_.set (MinAreaTraits::create (i, f, this));
              continue;
            }
          }

          break;
        }

        if (!linearDeflection_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "linearDeflection",
            "");
        }

        if (!angularDeflection_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "angularDeflection",
            "");
        }

        if (!relative_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "relative",
            "");
        }

        if (!minArea_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "minArea",
            "");
        }
      }

      ParametersOCCT* ParametersOCCT::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class ParametersOCCT (*this, f, c);
      }

      ParametersOCCT& ParametersOCCT::
      operator= (const ParametersOCCT& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->linearDeflection_ = x.linearDeflection_;
          this->angularDeflection_ = x.angularDeflection_;
          this->relative_ = x.relative_;
          this->minArea_ = x.minArea_;
        }

        return *this;
      }

      ParametersOCCT::
      ~ParametersOCCT ()
      {
      }

      // ParametersNetgen
      //

      ParametersNetgen::
      ParametersNetgen (const UseLocalHType& useLocalH,
                        const MaxHType& maxH,
                        const MinHType& minH,
                        const FinenessType& fineness,
                        const GradingType& grading,
                        const ElementsPerEdgeType& elementsPerEdge,
                        const ElementsPerCurveType& elementsPerCurve,
                        const CloseEdgeEnableType& closeEdgeEnable,
                        const CloseEdgeFactorType& closeEdgeFactor,
                        const MinEdgeLenEnableType& minEdgeLenEnable,
                        const MinEdgeLenType& minEdgeLen,
                        const SecondOrderType& secondOrder,
                        const QuadDominatedType& quadDominated,
                        const OptSurfMeshEnableType& optSurfMeshEnable,
                        const OptVolMeshEnableType& optVolMeshEnable,
                        const OptSteps2dType& optSteps2d,
                        const OptSteps3dType& optSteps3d,
                        const InvertTetsType& invertTets,
                        const InvertTrigsType& invertTrigs,
                        const CheckOverlapType& checkOverlap,
                        const CheckOverlappingBoundaryType& checkOverlappingBoundary)
      : ::xml_schema::Type (),
        useLocalH_ (useLocalH, this),
        maxH_ (maxH, this),
        minH_ (minH, this),
        fineness_ (fineness, this),
        grading_ (grading, this),
        elementsPerEdge_ (elementsPerEdge, this),
        elementsPerCurve_ (elementsPerCurve, this),
        closeEdgeEnable_ (closeEdgeEnable, this),
        closeEdgeFactor_ (closeEdgeFactor, this),
        minEdgeLenEnable_ (minEdgeLenEnable, this),
        minEdgeLen_ (minEdgeLen, this),
        secondOrder_ (secondOrder, this),
        quadDominated_ (quadDominated, this),
        optSurfMeshEnable_ (optSurfMeshEnable, this),
        optVolMeshEnable_ (optVolMeshEnable, this),
        optSteps2d_ (optSteps2d, this),
        optSteps3d_ (optSteps3d, this),
        invertTets_ (invertTets, this),
        invertTrigs_ (invertTrigs, this),
        checkOverlap_ (checkOverlap, this),
        checkOverlappingBoundary_ (checkOverlappingBoundary, this)
      {
      }

      ParametersNetgen::
      ParametersNetgen (const ParametersNetgen& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        useLocalH_ (x.useLocalH_, f, this),
        maxH_ (x.maxH_, f, this),
        minH_ (x.minH_, f, this),
        fineness_ (x.fineness_, f, this),
        grading_ (x.grading_, f, this),
        elementsPerEdge_ (x.elementsPerEdge_, f, this),
        elementsPerCurve_ (x.elementsPerCurve_, f, this),
        closeEdgeEnable_ (x.closeEdgeEnable_, f, this),
        closeEdgeFactor_ (x.closeEdgeFactor_, f, this),
        minEdgeLenEnable_ (x.minEdgeLenEnable_, f, this),
        minEdgeLen_ (x.minEdgeLen_, f, this),
        secondOrder_ (x.secondOrder_, f, this),
        quadDominated_ (x.quadDominated_, f, this),
        optSurfMeshEnable_ (x.optSurfMeshEnable_, f, this),
        optVolMeshEnable_ (x.optVolMeshEnable_, f, this),
        optSteps2d_ (x.optSteps2d_, f, this),
        optSteps3d_ (x.optSteps3d_, f, this),
        invertTets_ (x.invertTets_, f, this),
        invertTrigs_ (x.invertTrigs_, f, this),
        checkOverlap_ (x.checkOverlap_, f, this),
        checkOverlappingBoundary_ (x.checkOverlappingBoundary_, f, this)
      {
      }

      ParametersNetgen::
      ParametersNetgen (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        useLocalH_ (this),
        maxH_ (this),
        minH_ (this),
        fineness_ (this),
        grading_ (this),
        elementsPerEdge_ (this),
        elementsPerCurve_ (this),
        closeEdgeEnable_ (this),
        closeEdgeFactor_ (this),
        minEdgeLenEnable_ (this),
        minEdgeLen_ (this),
        secondOrder_ (this),
        quadDominated_ (this),
        optSurfMeshEnable_ (this),
        optVolMeshEnable_ (this),
        optSteps2d_ (this),
        optSteps3d_ (this),
        invertTets_ (this),
        invertTrigs_ (this),
        checkOverlap_ (this),
        checkOverlappingBoundary_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void ParametersNetgen::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // useLocalH
          //
          if (n.name () == "useLocalH" && n.namespace_ ().empty ())
          {
            if (!useLocalH_.present ())
            {
              this->useLocalH_.set (UseLocalHTraits::create (i, f, this));
              continue;
            }
          }

          // maxH
          //
          if (n.name () == "maxH" && n.namespace_ ().empty ())
          {
            if (!maxH_.present ())
            {
              this->maxH_.set (MaxHTraits::create (i, f, this));
              continue;
            }
          }

          // minH
          //
          if (n.name () == "minH" && n.namespace_ ().empty ())
          {
            if (!minH_.present ())
            {
              this->minH_.set (MinHTraits::create (i, f, this));
              continue;
            }
          }

          // fineness
          //
          if (n.name () == "fineness" && n.namespace_ ().empty ())
          {
            if (!fineness_.present ())
            {
              this->fineness_.set (FinenessTraits::create (i, f, this));
              continue;
            }
          }

          // grading
          //
          if (n.name () == "grading" && n.namespace_ ().empty ())
          {
            if (!grading_.present ())
            {
              this->grading_.set (GradingTraits::create (i, f, this));
              continue;
            }
          }

          // elementsPerEdge
          //
          if (n.name () == "elementsPerEdge" && n.namespace_ ().empty ())
          {
            if (!elementsPerEdge_.present ())
            {
              this->elementsPerEdge_.set (ElementsPerEdgeTraits::create (i, f, this));
              continue;
            }
          }

          // elementsPerCurve
          //
          if (n.name () == "elementsPerCurve" && n.namespace_ ().empty ())
          {
            if (!elementsPerCurve_.present ())
            {
              this->elementsPerCurve_.set (ElementsPerCurveTraits::create (i, f, this));
              continue;
            }
          }

          // closeEdgeEnable
          //
          if (n.name () == "closeEdgeEnable" && n.namespace_ ().empty ())
          {
            if (!closeEdgeEnable_.present ())
            {
              this->closeEdgeEnable_.set (CloseEdgeEnableTraits::create (i, f, this));
              continue;
            }
          }

          // closeEdgeFactor
          //
          if (n.name () == "closeEdgeFactor" && n.namespace_ ().empty ())
          {
            if (!closeEdgeFactor_.present ())
            {
              this->closeEdgeFactor_.set (CloseEdgeFactorTraits::create (i, f, this));
              continue;
            }
          }

          // minEdgeLenEnable
          //
          if (n.name () == "minEdgeLenEnable" && n.namespace_ ().empty ())
          {
            if (!minEdgeLenEnable_.present ())
            {
              this->minEdgeLenEnable_.set (MinEdgeLenEnableTraits::create (i, f, this));
              continue;
            }
          }

          // minEdgeLen
          //
          if (n.name () == "minEdgeLen" && n.namespace_ ().empty ())
          {
            if (!minEdgeLen_.present ())
            {
              this->minEdgeLen_.set (MinEdgeLenTraits::create (i, f, this));
              continue;
            }
          }

          // secondOrder
          //
          if (n.name () == "secondOrder" && n.namespace_ ().empty ())
          {
            if (!secondOrder_.present ())
            {
              this->secondOrder_.set (SecondOrderTraits::create (i, f, this));
              continue;
            }
          }

          // quadDominated
          //
          if (n.name () == "quadDominated" && n.namespace_ ().empty ())
          {
            if (!quadDominated_.present ())
            {
              this->quadDominated_.set (QuadDominatedTraits::create (i, f, this));
              continue;
            }
          }

          // optSurfMeshEnable
          //
          if (n.name () == "optSurfMeshEnable" && n.namespace_ ().empty ())
          {
            if (!optSurfMeshEnable_.present ())
            {
              this->optSurfMeshEnable_.set (OptSurfMeshEnableTraits::create (i, f, this));
              continue;
            }
          }

          // optVolMeshEnable
          //
          if (n.name () == "optVolMeshEnable" && n.namespace_ ().empty ())
          {
            if (!optVolMeshEnable_.present ())
            {
              this->optVolMeshEnable_.set (OptVolMeshEnableTraits::create (i, f, this));
              continue;
            }
          }

          // optSteps2d
          //
          if (n.name () == "optSteps2d" && n.namespace_ ().empty ())
          {
            if (!optSteps2d_.present ())
            {
              this->optSteps2d_.set (OptSteps2dTraits::create (i, f, this));
              continue;
            }
          }

          // optSteps3d
          //
          if (n.name () == "optSteps3d" && n.namespace_ ().empty ())
          {
            if (!optSteps3d_.present ())
            {
              this->optSteps3d_.set (OptSteps3dTraits::create (i, f, this));
              continue;
            }
          }

          // invertTets
          //
          if (n.name () == "invertTets" && n.namespace_ ().empty ())
          {
            if (!invertTets_.present ())
            {
              this->invertTets_.set (InvertTetsTraits::create (i, f, this));
              continue;
            }
          }

          // invertTrigs
          //
          if (n.name () == "invertTrigs" && n.namespace_ ().empty ())
          {
            if (!invertTrigs_.present ())
            {
              this->invertTrigs_.set (InvertTrigsTraits::create (i, f, this));
              continue;
            }
          }

          // checkOverlap
          //
          if (n.name () == "checkOverlap" && n.namespace_ ().empty ())
          {
            if (!checkOverlap_.present ())
            {
              this->checkOverlap_.set (CheckOverlapTraits::create (i, f, this));
              continue;
            }
          }

          // checkOverlappingBoundary
          //
          if (n.name () == "checkOverlappingBoundary" && n.namespace_ ().empty ())
          {
            if (!checkOverlappingBoundary_.present ())
            {
              this->checkOverlappingBoundary_.set (CheckOverlappingBoundaryTraits::create (i, f, this));
              continue;
            }
          }

          break;
        }

        if (!useLocalH_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "useLocalH",
            "");
        }

        if (!maxH_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "maxH",
            "");
        }

        if (!minH_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "minH",
            "");
        }

        if (!fineness_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "fineness",
            "");
        }

        if (!grading_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "grading",
            "");
        }

        if (!elementsPerEdge_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "elementsPerEdge",
            "");
        }

        if (!elementsPerCurve_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "elementsPerCurve",
            "");
        }

        if (!closeEdgeEnable_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "closeEdgeEnable",
            "");
        }

        if (!closeEdgeFactor_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "closeEdgeFactor",
            "");
        }

        if (!minEdgeLenEnable_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "minEdgeLenEnable",
            "");
        }

        if (!minEdgeLen_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "minEdgeLen",
            "");
        }

        if (!secondOrder_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "secondOrder",
            "");
        }

        if (!quadDominated_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "quadDominated",
            "");
        }

        if (!optSurfMeshEnable_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "optSurfMeshEnable",
            "");
        }

        if (!optVolMeshEnable_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "optVolMeshEnable",
            "");
        }

        if (!optSteps2d_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "optSteps2d",
            "");
        }

        if (!optSteps3d_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "optSteps3d",
            "");
        }

        if (!invertTets_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "invertTets",
            "");
        }

        if (!invertTrigs_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "invertTrigs",
            "");
        }

        if (!checkOverlap_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "checkOverlap",
            "");
        }

        if (!checkOverlappingBoundary_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "checkOverlappingBoundary",
            "");
        }
      }

      ParametersNetgen* ParametersNetgen::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class ParametersNetgen (*this, f, c);
      }

      ParametersNetgen& ParametersNetgen::
      operator= (const ParametersNetgen& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->useLocalH_ = x.useLocalH_;
          this->maxH_ = x.maxH_;
          this->minH_ = x.minH_;
          this->fineness_ = x.fineness_;
          this->grading_ = x.grading_;
          this->elementsPerEdge_ = x.elementsPerEdge_;
          this->elementsPerCurve_ = x.elementsPerCurve_;
          this->closeEdgeEnable_ = x.closeEdgeEnable_;
          this->closeEdgeFactor_ = x.closeEdgeFactor_;
          this->minEdgeLenEnable_ = x.minEdgeLenEnable_;
          this->minEdgeLen_ = x.minEdgeLen_;
          this->secondOrder_ = x.secondOrder_;
          this->quadDominated_ = x.quadDominated_;
          this->optSurfMeshEnable_ = x.optSurfMeshEnable_;
          this->optVolMeshEnable_ = x.optVolMeshEnable_;
          this->optSteps2d_ = x.optSteps2d_;
          this->optSteps3d_ = x.optSteps3d_;
          this->invertTets_ = x.invertTets_;
          this->invertTrigs_ = x.invertTrigs_;
          this->checkOverlap_ = x.checkOverlap_;
          this->checkOverlappingBoundary_ = x.checkOverlappingBoundary_;
        }

        return *this;
      }

      ParametersNetgen::
      ~ParametersNetgen ()
      {
      }

      // ParametersGMSHOption
      //

      ParametersGMSHOption::
      ParametersGMSHOption (const KeyType& key,
                            const ValueType& value)
      : ::xml_schema::Type (),
        key_ (key, this),
        value_ (value, this)
      {
      }

      ParametersGMSHOption::
      ParametersGMSHOption (const ParametersGMSHOption& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        key_ (x.key_, f, this),
        value_ (x.value_, f, this)
      {
      }

      ParametersGMSHOption::
      ParametersGMSHOption (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        key_ (this),
        value_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void ParametersGMSHOption::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // key
          //
          if (n.name () == "key" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< KeyType > r (
              KeyTraits::create (i, f, this));

            if (!key_.present ())
            {
              this->key_.set (::std::move (r));
              continue;
            }
          }

          // value
          //
          if (n.name () == "value" && n.namespace_ ().empty ())
          {
            if (!value_.present ())
            {
              this->value_.set (ValueTraits::create (i, f, this));
              continue;
            }
          }

          break;
        }

        if (!key_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "key",
            "");
        }

        if (!value_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "value",
            "");
        }
      }

      ParametersGMSHOption* ParametersGMSHOption::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class ParametersGMSHOption (*this, f, c);
      }

      ParametersGMSHOption& ParametersGMSHOption::
      operator= (const ParametersGMSHOption& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->key_ = x.key_;
          this->value_ = x.value_;
        }

        return *this;
      }

      ParametersGMSHOption::
      ~ParametersGMSHOption ()
      {
      }

      // ParametersGMSHOptions
      //

      ParametersGMSHOptions::
      ParametersGMSHOptions ()
      : ::xml_schema::Type (),
        array_ (this)
      {
      }

      ParametersGMSHOptions::
      ParametersGMSHOptions (const ParametersGMSHOptions& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        array_ (x.array_, f, this)
      {
      }

      ParametersGMSHOptions::
      ParametersGMSHOptions (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        array_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void ParametersGMSHOptions::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // array
          //
          if (n.name () == "array" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ArrayType > r (
              ArrayTraits::create (i, f, this));

            this->array_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      ParametersGMSHOptions* ParametersGMSHOptions::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class ParametersGMSHOptions (*this, f, c);
      }

      ParametersGMSHOptions& ParametersGMSHOptions::
      operator= (const ParametersGMSHOptions& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->array_ = x.array_;
        }

        return *this;
      }

      ParametersGMSHOptions::
      ~ParametersGMSHOptions ()
      {
      }

      // ParametersGMSH
      //

      ParametersGMSH::
      ParametersGMSH (const OptionsType& options,
                      const RefineType& refine)
      : ::xml_schema::Type (),
        options_ (options, this),
        refine_ (refine, this)
      {
      }

      ParametersGMSH::
      ParametersGMSH (::std::unique_ptr< OptionsType > options,
                      const RefineType& refine)
      : ::xml_schema::Type (),
        options_ (std::move (options), this),
        refine_ (refine, this)
      {
      }

      ParametersGMSH::
      ParametersGMSH (const ParametersGMSH& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        options_ (x.options_, f, this),
        refine_ (x.refine_, f, this)
      {
      }

      ParametersGMSH::
      ParametersGMSH (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        options_ (this),
        refine_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void ParametersGMSH::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // options
          //
          if (n.name () == "options" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< OptionsType > r (
              OptionsTraits::create (i, f, this));

            if (!options_.present ())
            {
              this->options_.set (::std::move (r));
              continue;
            }
          }

          // refine
          //
          if (n.name () == "refine" && n.namespace_ ().empty ())
          {
            if (!refine_.present ())
            {
              this->refine_.set (RefineTraits::create (i, f, this));
              continue;
            }
          }

          break;
        }

        if (!options_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "options",
            "");
        }

        if (!refine_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "refine",
            "");
        }
      }

      ParametersGMSH* ParametersGMSH::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class ParametersGMSH (*this, f, c);
      }

      ParametersGMSH& ParametersGMSH::
      operator= (const ParametersGMSH& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->options_ = x.options_;
          this->refine_ = x.refine_;
        }

        return *this;
      }

      ParametersGMSH::
      ~ParametersGMSH ()
      {
      }

      // Point
      //

      Point::
      Point (const XType& x,
             const YType& y,
             const ZType& z)
      : ::xml_schema::Type (),
        x_ (x, this),
        y_ (y, this),
        z_ (z, this)
      {
      }

      Point::
      Point (const Point& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        x_ (x.x_, f, this),
        y_ (x.y_, f, this),
        z_ (x.z_, f, this)
      {
      }

      Point::
      Point (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        x_ (this),
        y_ (this),
        z_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Point::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // x
          //
          if (n.name () == "x" && n.namespace_ ().empty ())
          {
            if (!x_.present ())
            {
              this->x_.set (XTraits::create (i, f, this));
              continue;
            }
          }

          // y
          //
          if (n.name () == "y" && n.namespace_ ().empty ())
          {
            if (!y_.present ())
            {
              this->y_.set (YTraits::create (i, f, this));
              continue;
            }
          }

          // z
          //
          if (n.name () == "z" && n.namespace_ ().empty ())
          {
            if (!z_.present ())
            {
              this->z_.set (ZTraits::create (i, f, this));
              continue;
            }
          }

          break;
        }

        if (!x_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "x",
            "");
        }

        if (!y_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "y",
            "");
        }

        if (!z_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "z",
            "");
        }
      }

      Point* Point::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Point (*this, f, c);
      }

      Point& Point::
      operator= (const Point& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->x_ = x.x_;
          this->y_ = x.y_;
          this->z_ = x.z_;
        }

        return *this;
      }

      Point::
      ~Point ()
      {
      }

      // Points
      //

      Points::
      Points ()
      : ::xml_schema::Type (),
        array_ (this)
      {
      }

      Points::
      Points (const Points& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        array_ (x.array_, f, this)
      {
      }

      Points::
      Points (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        array_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Points::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // array
          //
          if (n.name () == "array" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ArrayType > r (
              ArrayTraits::create (i, f, this));

            this->array_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      Points* Points::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Points (*this, f, c);
      }

      Points& Points::
      operator= (const Points& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->array_ = x.array_;
        }

        return *this;
      }

      Points::
      ~Points ()
      {
      }

      // Indexes
      //

      Indexes::
      Indexes ()
      : ::xml_schema::Type (),
        array_ (this)
      {
      }

      Indexes::
      Indexes (const Indexes& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        array_ (x.array_, f, this)
      {
      }

      Indexes::
      Indexes (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        array_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Indexes::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // array
          //
          if (n.name () == "array" && n.namespace_ ().empty ())
          {
            this->array_.push_back (ArrayTraits::create (i, f, this));
            continue;
          }

          break;
        }
      }

      Indexes* Indexes::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Indexes (*this, f, c);
      }

      Indexes& Indexes::
      operator= (const Indexes& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->array_ = x.array_;
        }

        return *this;
      }

      Indexes::
      ~Indexes ()
      {
      }

      // Face
      //

      Face::
      Face (const IndexesType& indexes)
      : ::xml_schema::Type (),
        indexes_ (indexes, this)
      {
      }

      Face::
      Face (::std::unique_ptr< IndexesType > indexes)
      : ::xml_schema::Type (),
        indexes_ (std::move (indexes), this)
      {
      }

      Face::
      Face (const Face& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        indexes_ (x.indexes_, f, this)
      {
      }

      Face::
      Face (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        indexes_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Face::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // indexes
          //
          if (n.name () == "indexes" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< IndexesType > r (
              IndexesTraits::create (i, f, this));

            if (!indexes_.present ())
            {
              this->indexes_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!indexes_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "indexes",
            "");
        }
      }

      Face* Face::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Face (*this, f, c);
      }

      Face& Face::
      operator= (const Face& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->indexes_ = x.indexes_;
        }

        return *this;
      }

      Face::
      ~Face ()
      {
      }

      // Faces
      //

      Faces::
      Faces ()
      : ::xml_schema::Type (),
        array_ (this)
      {
      }

      Faces::
      Faces (const Faces& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        array_ (x.array_, f, this)
      {
      }

      Faces::
      Faces (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        array_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Faces::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // array
          //
          if (n.name () == "array" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ArrayType > r (
              ArrayTraits::create (i, f, this));

            this->array_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      Faces* Faces::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Faces (*this, f, c);
      }

      Faces& Faces::
      operator= (const Faces& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->array_ = x.array_;
        }

        return *this;
      }

      Faces::
      ~Faces ()
      {
      }

      // Surface
      //

      Surface::
      Surface (const PointsType& points,
               const FacesType& faces)
      : ::xml_schema::Type (),
        points_ (points, this),
        faces_ (faces, this)
      {
      }

      Surface::
      Surface (::std::unique_ptr< PointsType > points,
               ::std::unique_ptr< FacesType > faces)
      : ::xml_schema::Type (),
        points_ (std::move (points), this),
        faces_ (std::move (faces), this)
      {
      }

      Surface::
      Surface (const Surface& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        points_ (x.points_, f, this),
        faces_ (x.faces_, f, this)
      {
      }

      Surface::
      Surface (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        points_ (this),
        faces_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Surface::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // points
          //
          if (n.name () == "points" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< PointsType > r (
              PointsTraits::create (i, f, this));

            if (!points_.present ())
            {
              this->points_.set (::std::move (r));
              continue;
            }
          }

          // faces
          //
          if (n.name () == "faces" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< FacesType > r (
              FacesTraits::create (i, f, this));

            if (!faces_.present ())
            {
              this->faces_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!points_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "points",
            "");
        }

        if (!faces_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "faces",
            "");
        }
      }

      Surface* Surface::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Surface (*this, f, c);
      }

      Surface& Surface::
      operator= (const Surface& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->points_ = x.points_;
          this->faces_ = x.faces_;
        }

        return *this;
      }

      Surface::
      ~Surface ()
      {
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace prj
{
  namespace srl
  {
    namespace msh
    {
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace msh
    {
      void
      operator<< (::xercesc::DOMElement& e, const ParametersOCCT& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // linearDeflection
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "linearDeflection",
              e));

          s << ::xml_schema::AsDouble(i.linearDeflection ());
        }

        // angularDeflection
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "angularDeflection",
              e));

          s << ::xml_schema::AsDouble(i.angularDeflection ());
        }

        // relative
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "relative",
              e));

          s << i.relative ();
        }

        // minArea
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "minArea",
              e));

          s << ::xml_schema::AsDouble(i.minArea ());
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const ParametersNetgen& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // useLocalH
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "useLocalH",
              e));

          s << i.useLocalH ();
        }

        // maxH
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "maxH",
              e));

          s << ::xml_schema::AsDouble(i.maxH ());
        }

        // minH
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "minH",
              e));

          s << ::xml_schema::AsDouble(i.minH ());
        }

        // fineness
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "fineness",
              e));

          s << ::xml_schema::AsDouble(i.fineness ());
        }

        // grading
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "grading",
              e));

          s << ::xml_schema::AsDouble(i.grading ());
        }

        // elementsPerEdge
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "elementsPerEdge",
              e));

          s << ::xml_schema::AsDouble(i.elementsPerEdge ());
        }

        // elementsPerCurve
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "elementsPerCurve",
              e));

          s << ::xml_schema::AsDouble(i.elementsPerCurve ());
        }

        // closeEdgeEnable
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "closeEdgeEnable",
              e));

          s << ::xml_schema::AsDouble(i.closeEdgeEnable ());
        }

        // closeEdgeFactor
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "closeEdgeFactor",
              e));

          s << ::xml_schema::AsDouble(i.closeEdgeFactor ());
        }

        // minEdgeLenEnable
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "minEdgeLenEnable",
              e));

          s << i.minEdgeLenEnable ();
        }

        // minEdgeLen
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "minEdgeLen",
              e));

          s << ::xml_schema::AsDouble(i.minEdgeLen ());
        }

        // secondOrder
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "secondOrder",
              e));

          s << i.secondOrder ();
        }

        // quadDominated
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "quadDominated",
              e));

          s << i.quadDominated ();
        }

        // optSurfMeshEnable
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "optSurfMeshEnable",
              e));

          s << i.optSurfMeshEnable ();
        }

        // optVolMeshEnable
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "optVolMeshEnable",
              e));

          s << i.optVolMeshEnable ();
        }

        // optSteps2d
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "optSteps2d",
              e));

          s << i.optSteps2d ();
        }

        // optSteps3d
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "optSteps3d",
              e));

          s << i.optSteps3d ();
        }

        // invertTets
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "invertTets",
              e));

          s << i.invertTets ();
        }

        // invertTrigs
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "invertTrigs",
              e));

          s << i.invertTrigs ();
        }

        // checkOverlap
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "checkOverlap",
              e));

          s << i.checkOverlap ();
        }

        // checkOverlappingBoundary
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "checkOverlappingBoundary",
              e));

          s << i.checkOverlappingBoundary ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const ParametersGMSHOption& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // key
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "key",
              e));

          s << i.key ();
        }

        // value
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "value",
              e));

          s << ::xml_schema::AsDouble(i.value ());
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const ParametersGMSHOptions& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // array
        //
        for (ParametersGMSHOptions::ArrayConstIterator
             b (i.array ().begin ()), n (i.array ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "array",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const ParametersGMSH& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // options
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "options",
              e));

          s << i.options ();
        }

        // refine
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "refine",
              e));

          s << i.refine ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Point& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // x
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "x",
              e));

          s << ::xml_schema::AsDouble(i.x ());
        }

        // y
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "y",
              e));

          s << ::xml_schema::AsDouble(i.y ());
        }

        // z
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "z",
              e));

          s << ::xml_schema::AsDouble(i.z ());
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Points& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // array
        //
        for (Points::ArrayConstIterator
             b (i.array ().begin ()), n (i.array ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "array",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Indexes& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // array
        //
        for (Indexes::ArrayConstIterator
             b (i.array ().begin ()), n (i.array ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "array",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Face& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // indexes
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "indexes",
              e));

          s << i.indexes ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Faces& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // array
        //
        for (Faces::ArrayConstIterator
             b (i.array ().begin ()), n (i.array ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "array",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Surface& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // points
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "points",
              e));

          s << i.points ();
        }

        // faces
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "faces",
              e));

          s << i.faces ();
        }
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

