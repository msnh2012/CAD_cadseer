// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "prjsrlqtsquote.h"

namespace prj
{
  namespace srl
  {
    namespace qts
    {
      // Quote
      // 

      const Quote::BaseType& Quote::
      base () const
      {
        return this->base_.get ();
      }

      Quote::BaseType& Quote::
      base ()
      {
        return this->base_.get ();
      }

      void Quote::
      base (const BaseType& x)
      {
        this->base_.set (x);
      }

      void Quote::
      base (::std::unique_ptr< BaseType > x)
      {
        this->base_.set (std::move (x));
      }

      const Quote::TemplateFileType& Quote::
      templateFile () const
      {
        return this->templateFile_.get ();
      }

      Quote::TemplateFileType& Quote::
      templateFile ()
      {
        return this->templateFile_.get ();
      }

      void Quote::
      templateFile (const TemplateFileType& x)
      {
        this->templateFile_.set (x);
      }

      void Quote::
      templateFile (::std::unique_ptr< TemplateFileType > x)
      {
        this->templateFile_.set (std::move (x));
      }

      const Quote::OutFileType& Quote::
      outFile () const
      {
        return this->outFile_.get ();
      }

      Quote::OutFileType& Quote::
      outFile ()
      {
        return this->outFile_.get ();
      }

      void Quote::
      outFile (const OutFileType& x)
      {
        this->outFile_.set (x);
      }

      void Quote::
      outFile (::std::unique_ptr< OutFileType > x)
      {
        this->outFile_.set (std::move (x));
      }

      const Quote::PictureFileType& Quote::
      pictureFile () const
      {
        return this->pictureFile_.get ();
      }

      Quote::PictureFileType& Quote::
      pictureFile ()
      {
        return this->pictureFile_.get ();
      }

      void Quote::
      pictureFile (const PictureFileType& x)
      {
        this->pictureFile_.set (x);
      }

      void Quote::
      pictureFile (::std::unique_ptr< PictureFileType > x)
      {
        this->pictureFile_.set (std::move (x));
      }

      const Quote::QuoteNumberType& Quote::
      quoteNumber () const
      {
        return this->quoteNumber_.get ();
      }

      Quote::QuoteNumberType& Quote::
      quoteNumber ()
      {
        return this->quoteNumber_.get ();
      }

      void Quote::
      quoteNumber (const QuoteNumberType& x)
      {
        this->quoteNumber_.set (x);
      }

      const Quote::CustomerNameType& Quote::
      customerName () const
      {
        return this->customerName_.get ();
      }

      Quote::CustomerNameType& Quote::
      customerName ()
      {
        return this->customerName_.get ();
      }

      void Quote::
      customerName (const CustomerNameType& x)
      {
        this->customerName_.set (x);
      }

      void Quote::
      customerName (::std::unique_ptr< CustomerNameType > x)
      {
        this->customerName_.set (std::move (x));
      }

      const Quote::CustomerIdType& Quote::
      customerId () const
      {
        return this->customerId_.get ();
      }

      Quote::CustomerIdType& Quote::
      customerId ()
      {
        return this->customerId_.get ();
      }

      void Quote::
      customerId (const CustomerIdType& x)
      {
        this->customerId_.set (x);
      }

      void Quote::
      customerId (::std::unique_ptr< CustomerIdType > x)
      {
        this->customerId_.set (std::move (x));
      }

      const Quote::PartNameType& Quote::
      partName () const
      {
        return this->partName_.get ();
      }

      Quote::PartNameType& Quote::
      partName ()
      {
        return this->partName_.get ();
      }

      void Quote::
      partName (const PartNameType& x)
      {
        this->partName_.set (x);
      }

      void Quote::
      partName (::std::unique_ptr< PartNameType > x)
      {
        this->partName_.set (std::move (x));
      }

      const Quote::PartNumberType& Quote::
      partNumber () const
      {
        return this->partNumber_.get ();
      }

      Quote::PartNumberType& Quote::
      partNumber ()
      {
        return this->partNumber_.get ();
      }

      void Quote::
      partNumber (const PartNumberType& x)
      {
        this->partNumber_.set (x);
      }

      void Quote::
      partNumber (::std::unique_ptr< PartNumberType > x)
      {
        this->partNumber_.set (std::move (x));
      }

      const Quote::PartSetupType& Quote::
      partSetup () const
      {
        return this->partSetup_.get ();
      }

      Quote::PartSetupType& Quote::
      partSetup ()
      {
        return this->partSetup_.get ();
      }

      void Quote::
      partSetup (const PartSetupType& x)
      {
        this->partSetup_.set (x);
      }

      void Quote::
      partSetup (::std::unique_ptr< PartSetupType > x)
      {
        this->partSetup_.set (std::move (x));
      }

      const Quote::PartRevisionType& Quote::
      partRevision () const
      {
        return this->partRevision_.get ();
      }

      Quote::PartRevisionType& Quote::
      partRevision ()
      {
        return this->partRevision_.get ();
      }

      void Quote::
      partRevision (const PartRevisionType& x)
      {
        this->partRevision_.set (x);
      }

      void Quote::
      partRevision (::std::unique_ptr< PartRevisionType > x)
      {
        this->partRevision_.set (std::move (x));
      }

      const Quote::MaterialTypeType& Quote::
      materialType () const
      {
        return this->materialType_.get ();
      }

      Quote::MaterialTypeType& Quote::
      materialType ()
      {
        return this->materialType_.get ();
      }

      void Quote::
      materialType (const MaterialTypeType& x)
      {
        this->materialType_.set (x);
      }

      void Quote::
      materialType (::std::unique_ptr< MaterialTypeType > x)
      {
        this->materialType_.set (std::move (x));
      }

      const Quote::MaterialThicknessType& Quote::
      materialThickness () const
      {
        return this->materialThickness_.get ();
      }

      Quote::MaterialThicknessType& Quote::
      materialThickness ()
      {
        return this->materialThickness_.get ();
      }

      void Quote::
      materialThickness (const MaterialThicknessType& x)
      {
        this->materialThickness_.set (x);
      }

      const Quote::ProcessTypeType& Quote::
      processType () const
      {
        return this->processType_.get ();
      }

      Quote::ProcessTypeType& Quote::
      processType ()
      {
        return this->processType_.get ();
      }

      void Quote::
      processType (const ProcessTypeType& x)
      {
        this->processType_.set (x);
      }

      void Quote::
      processType (::std::unique_ptr< ProcessTypeType > x)
      {
        this->processType_.set (std::move (x));
      }

      const Quote::AnnualVolumeType& Quote::
      annualVolume () const
      {
        return this->annualVolume_.get ();
      }

      Quote::AnnualVolumeType& Quote::
      annualVolume ()
      {
        return this->annualVolume_.get ();
      }

      void Quote::
      annualVolume (const AnnualVolumeType& x)
      {
        this->annualVolume_.set (x);
      }

      const Quote::TLabelType& Quote::
      tLabel () const
      {
        return this->tLabel_.get ();
      }

      Quote::TLabelType& Quote::
      tLabel ()
      {
        return this->tLabel_.get ();
      }

      void Quote::
      tLabel (const TLabelType& x)
      {
        this->tLabel_.set (x);
      }

      void Quote::
      tLabel (::std::unique_ptr< TLabelType > x)
      {
        this->tLabel_.set (std::move (x));
      }

      const Quote::OLabelType& Quote::
      oLabel () const
      {
        return this->oLabel_.get ();
      }

      Quote::OLabelType& Quote::
      oLabel ()
      {
        return this->oLabel_.get ();
      }

      void Quote::
      oLabel (const OLabelType& x)
      {
        this->oLabel_.set (x);
      }

      void Quote::
      oLabel (::std::unique_ptr< OLabelType > x)
      {
        this->oLabel_.set (std::move (x));
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace qts
    {
      // Quote
      //

      Quote::
      Quote (const BaseType& base,
             const TemplateFileType& templateFile,
             const OutFileType& outFile,
             const PictureFileType& pictureFile,
             const QuoteNumberType& quoteNumber,
             const CustomerNameType& customerName,
             const CustomerIdType& customerId,
             const PartNameType& partName,
             const PartNumberType& partNumber,
             const PartSetupType& partSetup,
             const PartRevisionType& partRevision,
             const MaterialTypeType& materialType,
             const MaterialThicknessType& materialThickness,
             const ProcessTypeType& processType,
             const AnnualVolumeType& annualVolume,
             const TLabelType& tLabel,
             const OLabelType& oLabel)
      : ::xml_schema::Type (),
        base_ (base, this),
        templateFile_ (templateFile, this),
        outFile_ (outFile, this),
        pictureFile_ (pictureFile, this),
        quoteNumber_ (quoteNumber, this),
        customerName_ (customerName, this),
        customerId_ (customerId, this),
        partName_ (partName, this),
        partNumber_ (partNumber, this),
        partSetup_ (partSetup, this),
        partRevision_ (partRevision, this),
        materialType_ (materialType, this),
        materialThickness_ (materialThickness, this),
        processType_ (processType, this),
        annualVolume_ (annualVolume, this),
        tLabel_ (tLabel, this),
        oLabel_ (oLabel, this)
      {
      }

      Quote::
      Quote (::std::unique_ptr< BaseType > base,
             ::std::unique_ptr< TemplateFileType > templateFile,
             ::std::unique_ptr< OutFileType > outFile,
             const PictureFileType& pictureFile,
             const QuoteNumberType& quoteNumber,
             const CustomerNameType& customerName,
             const CustomerIdType& customerId,
             const PartNameType& partName,
             const PartNumberType& partNumber,
             const PartSetupType& partSetup,
             const PartRevisionType& partRevision,
             const MaterialTypeType& materialType,
             const MaterialThicknessType& materialThickness,
             const ProcessTypeType& processType,
             const AnnualVolumeType& annualVolume,
             ::std::unique_ptr< TLabelType > tLabel,
             ::std::unique_ptr< OLabelType > oLabel)
      : ::xml_schema::Type (),
        base_ (std::move (base), this),
        templateFile_ (std::move (templateFile), this),
        outFile_ (std::move (outFile), this),
        pictureFile_ (pictureFile, this),
        quoteNumber_ (quoteNumber, this),
        customerName_ (customerName, this),
        customerId_ (customerId, this),
        partName_ (partName, this),
        partNumber_ (partNumber, this),
        partSetup_ (partSetup, this),
        partRevision_ (partRevision, this),
        materialType_ (materialType, this),
        materialThickness_ (materialThickness, this),
        processType_ (processType, this),
        annualVolume_ (annualVolume, this),
        tLabel_ (std::move (tLabel), this),
        oLabel_ (std::move (oLabel), this)
      {
      }

      Quote::
      Quote (const Quote& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        base_ (x.base_, f, this),
        templateFile_ (x.templateFile_, f, this),
        outFile_ (x.outFile_, f, this),
        pictureFile_ (x.pictureFile_, f, this),
        quoteNumber_ (x.quoteNumber_, f, this),
        customerName_ (x.customerName_, f, this),
        customerId_ (x.customerId_, f, this),
        partName_ (x.partName_, f, this),
        partNumber_ (x.partNumber_, f, this),
        partSetup_ (x.partSetup_, f, this),
        partRevision_ (x.partRevision_, f, this),
        materialType_ (x.materialType_, f, this),
        materialThickness_ (x.materialThickness_, f, this),
        processType_ (x.processType_, f, this),
        annualVolume_ (x.annualVolume_, f, this),
        tLabel_ (x.tLabel_, f, this),
        oLabel_ (x.oLabel_, f, this)
      {
      }

      Quote::
      Quote (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        base_ (this),
        templateFile_ (this),
        outFile_ (this),
        pictureFile_ (this),
        quoteNumber_ (this),
        customerName_ (this),
        customerId_ (this),
        partName_ (this),
        partNumber_ (this),
        partSetup_ (this),
        partRevision_ (this),
        materialType_ (this),
        materialThickness_ (this),
        processType_ (this),
        annualVolume_ (this),
        tLabel_ (this),
        oLabel_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Quote::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // base
          //
          if (n.name () == "base" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< BaseType > r (
              BaseTraits::create (i, f, this));

            if (!base_.present ())
            {
              this->base_.set (::std::move (r));
              continue;
            }
          }

          // templateFile
          //
          if (n.name () == "templateFile" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< TemplateFileType > r (
              TemplateFileTraits::create (i, f, this));

            if (!templateFile_.present ())
            {
              this->templateFile_.set (::std::move (r));
              continue;
            }
          }

          // outFile
          //
          if (n.name () == "outFile" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< OutFileType > r (
              OutFileTraits::create (i, f, this));

            if (!outFile_.present ())
            {
              this->outFile_.set (::std::move (r));
              continue;
            }
          }

          // pictureFile
          //
          if (n.name () == "pictureFile" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< PictureFileType > r (
              PictureFileTraits::create (i, f, this));

            if (!pictureFile_.present ())
            {
              this->pictureFile_.set (::std::move (r));
              continue;
            }
          }

          // quoteNumber
          //
          if (n.name () == "quoteNumber" && n.namespace_ ().empty ())
          {
            if (!quoteNumber_.present ())
            {
              this->quoteNumber_.set (QuoteNumberTraits::create (i, f, this));
              continue;
            }
          }

          // customerName
          //
          if (n.name () == "customerName" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< CustomerNameType > r (
              CustomerNameTraits::create (i, f, this));

            if (!customerName_.present ())
            {
              this->customerName_.set (::std::move (r));
              continue;
            }
          }

          // customerId
          //
          if (n.name () == "customerId" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< CustomerIdType > r (
              CustomerIdTraits::create (i, f, this));

            if (!customerId_.present ())
            {
              this->customerId_.set (::std::move (r));
              continue;
            }
          }

          // partName
          //
          if (n.name () == "partName" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< PartNameType > r (
              PartNameTraits::create (i, f, this));

            if (!partName_.present ())
            {
              this->partName_.set (::std::move (r));
              continue;
            }
          }

          // partNumber
          //
          if (n.name () == "partNumber" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< PartNumberType > r (
              PartNumberTraits::create (i, f, this));

            if (!partNumber_.present ())
            {
              this->partNumber_.set (::std::move (r));
              continue;
            }
          }

          // partSetup
          //
          if (n.name () == "partSetup" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< PartSetupType > r (
              PartSetupTraits::create (i, f, this));

            if (!partSetup_.present ())
            {
              this->partSetup_.set (::std::move (r));
              continue;
            }
          }

          // partRevision
          //
          if (n.name () == "partRevision" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< PartRevisionType > r (
              PartRevisionTraits::create (i, f, this));

            if (!partRevision_.present ())
            {
              this->partRevision_.set (::std::move (r));
              continue;
            }
          }

          // materialType
          //
          if (n.name () == "materialType" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< MaterialTypeType > r (
              MaterialTypeTraits::create (i, f, this));

            if (!materialType_.present ())
            {
              this->materialType_.set (::std::move (r));
              continue;
            }
          }

          // materialThickness
          //
          if (n.name () == "materialThickness" && n.namespace_ ().empty ())
          {
            if (!materialThickness_.present ())
            {
              this->materialThickness_.set (MaterialThicknessTraits::create (i, f, this));
              continue;
            }
          }

          // processType
          //
          if (n.name () == "processType" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ProcessTypeType > r (
              ProcessTypeTraits::create (i, f, this));

            if (!processType_.present ())
            {
              this->processType_.set (::std::move (r));
              continue;
            }
          }

          // annualVolume
          //
          if (n.name () == "annualVolume" && n.namespace_ ().empty ())
          {
            if (!annualVolume_.present ())
            {
              this->annualVolume_.set (AnnualVolumeTraits::create (i, f, this));
              continue;
            }
          }

          // tLabel
          //
          if (n.name () == "tLabel" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< TLabelType > r (
              TLabelTraits::create (i, f, this));

            if (!tLabel_.present ())
            {
              this->tLabel_.set (::std::move (r));
              continue;
            }
          }

          // oLabel
          //
          if (n.name () == "oLabel" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< OLabelType > r (
              OLabelTraits::create (i, f, this));

            if (!oLabel_.present ())
            {
              this->oLabel_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!base_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "base",
            "");
        }

        if (!templateFile_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "templateFile",
            "");
        }

        if (!outFile_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "outFile",
            "");
        }

        if (!pictureFile_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "pictureFile",
            "");
        }

        if (!quoteNumber_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "quoteNumber",
            "");
        }

        if (!customerName_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "customerName",
            "");
        }

        if (!customerId_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "customerId",
            "");
        }

        if (!partName_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "partName",
            "");
        }

        if (!partNumber_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "partNumber",
            "");
        }

        if (!partSetup_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "partSetup",
            "");
        }

        if (!partRevision_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "partRevision",
            "");
        }

        if (!materialType_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "materialType",
            "");
        }

        if (!materialThickness_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "materialThickness",
            "");
        }

        if (!processType_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "processType",
            "");
        }

        if (!annualVolume_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "annualVolume",
            "");
        }

        if (!tLabel_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "tLabel",
            "");
        }

        if (!oLabel_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "oLabel",
            "");
        }
      }

      Quote* Quote::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Quote (*this, f, c);
      }

      Quote& Quote::
      operator= (const Quote& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->base_ = x.base_;
          this->templateFile_ = x.templateFile_;
          this->outFile_ = x.outFile_;
          this->pictureFile_ = x.pictureFile_;
          this->quoteNumber_ = x.quoteNumber_;
          this->customerName_ = x.customerName_;
          this->customerId_ = x.customerId_;
          this->partName_ = x.partName_;
          this->partNumber_ = x.partNumber_;
          this->partSetup_ = x.partSetup_;
          this->partRevision_ = x.partRevision_;
          this->materialType_ = x.materialType_;
          this->materialThickness_ = x.materialThickness_;
          this->processType_ = x.processType_;
          this->annualVolume_ = x.annualVolume_;
          this->tLabel_ = x.tLabel_;
          this->oLabel_ = x.oLabel_;
        }

        return *this;
      }

      Quote::
      ~Quote ()
      {
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace prj
{
  namespace srl
  {
    namespace qts
    {
      ::std::unique_ptr< ::prj::srl::qts::Quote >
      quote (const ::std::string& u,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::prj::srl::qts::Quote > (
          ::prj::srl::qts::quote (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::qts::Quote >
      quote (const ::std::string& u,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::prj::srl::qts::Quote > (
          ::prj::srl::qts::quote (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::qts::Quote >
      quote (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::prj::srl::qts::Quote > (
          ::prj::srl::qts::quote (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::qts::Quote >
      quote (::std::istream& is,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::prj::srl::qts::quote (isrc, f, p);
      }

      ::std::unique_ptr< ::prj::srl::qts::Quote >
      quote (::std::istream& is,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::prj::srl::qts::quote (isrc, h, f, p);
      }

      ::std::unique_ptr< ::prj::srl::qts::Quote >
      quote (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::prj::srl::qts::quote (isrc, h, f, p);
      }

      ::std::unique_ptr< ::prj::srl::qts::Quote >
      quote (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::prj::srl::qts::quote (isrc, f, p);
      }

      ::std::unique_ptr< ::prj::srl::qts::Quote >
      quote (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::prj::srl::qts::quote (isrc, h, f, p);
      }

      ::std::unique_ptr< ::prj::srl::qts::Quote >
      quote (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::prj::srl::qts::quote (isrc, h, f, p);
      }

      ::std::unique_ptr< ::prj::srl::qts::Quote >
      quote (::xercesc::InputSource& i,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::prj::srl::qts::Quote > (
          ::prj::srl::qts::quote (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::qts::Quote >
      quote (::xercesc::InputSource& i,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::prj::srl::qts::Quote > (
          ::prj::srl::qts::quote (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::qts::Quote >
      quote (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::prj::srl::qts::Quote > (
          ::prj::srl::qts::quote (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::qts::Quote >
      quote (const ::xercesc::DOMDocument& doc,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        if (f & ::xml_schema::Flags::keep_dom)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::prj::srl::qts::Quote > (
            ::prj::srl::qts::quote (
              std::move (d), f | ::xml_schema::Flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "quote" &&
            n.namespace_ () == "http://www.cadseer.com/prj/srl/qts")
        {
          ::std::unique_ptr< ::prj::srl::qts::Quote > r (
            ::xsd::cxx::tree::traits< ::prj::srl::qts::Quote, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "quote",
          "http://www.cadseer.com/prj/srl/qts");
      }

      ::std::unique_ptr< ::prj::srl::qts::Quote >
      quote (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties&)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::xml_schema::Flags::keep_dom) &&
           !(f & ::xml_schema::Flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::xml_schema::Flags::keep_dom)
          doc.setUserData (::xml_schema::dom::tree_node_key,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "quote" &&
            n.namespace_ () == "http://www.cadseer.com/prj/srl/qts")
        {
          ::std::unique_ptr< ::prj::srl::qts::Quote > r (
            ::xsd::cxx::tree::traits< ::prj::srl::qts::Quote, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "quote",
          "http://www.cadseer.com/prj/srl/qts");
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace qts
    {
      void
      operator<< (::xercesc::DOMElement& e, const Quote& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // base
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "base",
              e));

          s << i.base ();
        }

        // templateFile
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "templateFile",
              e));

          s << i.templateFile ();
        }

        // outFile
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "outFile",
              e));

          s << i.outFile ();
        }

        // pictureFile
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "pictureFile",
              e));

          s << i.pictureFile ();
        }

        // quoteNumber
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "quoteNumber",
              e));

          s << i.quoteNumber ();
        }

        // customerName
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "customerName",
              e));

          s << i.customerName ();
        }

        // customerId
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "customerId",
              e));

          s << i.customerId ();
        }

        // partName
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "partName",
              e));

          s << i.partName ();
        }

        // partNumber
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "partNumber",
              e));

          s << i.partNumber ();
        }

        // partSetup
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "partSetup",
              e));

          s << i.partSetup ();
        }

        // partRevision
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "partRevision",
              e));

          s << i.partRevision ();
        }

        // materialType
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "materialType",
              e));

          s << i.materialType ();
        }

        // materialThickness
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "materialThickness",
              e));

          s << ::xml_schema::AsDouble(i.materialThickness ());
        }

        // processType
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "processType",
              e));

          s << i.processType ();
        }

        // annualVolume
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "annualVolume",
              e));

          s << i.annualVolume ();
        }

        // tLabel
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "tLabel",
              e));

          s << i.tLabel ();
        }

        // oLabel
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "oLabel",
              e));

          s << i.oLabel ();
        }
      }

      void
      quote (::std::ostream& o,
             const ::prj::srl::qts::Quote& s,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::qts::quote (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      quote (::std::ostream& o,
             const ::prj::srl::qts::Quote& s,
             ::xml_schema::ErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::qts::quote (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      quote (::std::ostream& o,
             const ::prj::srl::qts::Quote& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::qts::quote (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      quote (::xercesc::XMLFormatTarget& t,
             const ::prj::srl::qts::Quote& s,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::qts::quote (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      quote (::xercesc::XMLFormatTarget& t,
             const ::prj::srl::qts::Quote& s,
             ::xml_schema::ErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::qts::quote (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      quote (::xercesc::XMLFormatTarget& t,
             const ::prj::srl::qts::Quote& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::qts::quote (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      quote (::xercesc::DOMDocument& d,
             const ::prj::srl::qts::Quote& s,
             ::xml_schema::Flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "quote" &&
            n.namespace_ () == "http://www.cadseer.com/prj/srl/qts")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "quote",
            "http://www.cadseer.com/prj/srl/qts");
        }
      }

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
      quote (const ::prj::srl::qts::Quote& s,
             const ::xml_schema::NamespaceInfomap& m,
             ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "quote",
            "http://www.cadseer.com/prj/srl/qts",
            m, f));

        ::prj::srl::qts::quote (*d, s, f);
        return d;
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

