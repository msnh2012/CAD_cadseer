// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "prjsrlsptcolor.h"

namespace prj
{
  namespace srl
  {
    namespace spt
    {
      // ColorValue
      // 


      // Color
      // 

      const Color::RType& Color::
      r () const
      {
        return this->r_.get ();
      }

      Color::RType& Color::
      r ()
      {
        return this->r_.get ();
      }

      void Color::
      r (const RType& x)
      {
        this->r_.set (x);
      }

      void Color::
      r (::std::unique_ptr< RType > x)
      {
        this->r_.set (std::move (x));
      }

      const Color::GType& Color::
      g () const
      {
        return this->g_.get ();
      }

      Color::GType& Color::
      g ()
      {
        return this->g_.get ();
      }

      void Color::
      g (const GType& x)
      {
        this->g_.set (x);
      }

      void Color::
      g (::std::unique_ptr< GType > x)
      {
        this->g_.set (std::move (x));
      }

      const Color::BType& Color::
      b () const
      {
        return this->b_.get ();
      }

      Color::BType& Color::
      b ()
      {
        return this->b_.get ();
      }

      void Color::
      b (const BType& x)
      {
        this->b_.set (x);
      }

      void Color::
      b (::std::unique_ptr< BType > x)
      {
        this->b_.set (std::move (x));
      }

      const Color::AType& Color::
      a () const
      {
        return this->a_.get ();
      }

      Color::AType& Color::
      a ()
      {
        return this->a_.get ();
      }

      void Color::
      a (const AType& x)
      {
        this->a_.set (x);
      }

      void Color::
      a (::std::unique_ptr< AType > x)
      {
        this->a_.set (std::move (x));
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace spt
    {
      // ColorValue
      //

      ColorValue::
      ColorValue (const ::xml_schema::Decimal& _xsd_Decimal_base)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (_xsd_Decimal_base)
      {
      }

      ColorValue::
      ColorValue (const ColorValue& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
      {
      }

      ColorValue::
      ColorValue (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
      {
      }

      ColorValue::
      ColorValue (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
      {
      }

      ColorValue::
      ColorValue (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
      : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
      {
      }

      ColorValue* ColorValue::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class ColorValue (*this, f, c);
      }

      ColorValue::
      ~ColorValue ()
      {
      }

      // Color
      //

      Color::
      Color (const RType& r,
             const GType& g,
             const BType& b,
             const AType& a)
      : ::xml_schema::Type (),
        r_ (r, this),
        g_ (g, this),
        b_ (b, this),
        a_ (a, this)
      {
      }

      Color::
      Color (const Color& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        r_ (x.r_, f, this),
        g_ (x.g_, f, this),
        b_ (x.b_, f, this),
        a_ (x.a_, f, this)
      {
      }

      Color::
      Color (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        r_ (this),
        g_ (this),
        b_ (this),
        a_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Color::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // r
          //
          if (n.name () == "r" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< RType > r (
              RTraits::create (i, f, this));

            if (!r_.present ())
            {
              this->r_.set (::std::move (r));
              continue;
            }
          }

          // g
          //
          if (n.name () == "g" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< GType > r (
              GTraits::create (i, f, this));

            if (!g_.present ())
            {
              this->g_.set (::std::move (r));
              continue;
            }
          }

          // b
          //
          if (n.name () == "b" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< BType > r (
              BTraits::create (i, f, this));

            if (!b_.present ())
            {
              this->b_.set (::std::move (r));
              continue;
            }
          }

          // a
          //
          if (n.name () == "a" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< AType > r (
              ATraits::create (i, f, this));

            if (!a_.present ())
            {
              this->a_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!r_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "r",
            "");
        }

        if (!g_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "g",
            "");
        }

        if (!b_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "b",
            "");
        }

        if (!a_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "a",
            "");
        }
      }

      Color* Color::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Color (*this, f, c);
      }

      Color& Color::
      operator= (const Color& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->r_ = x.r_;
          this->g_ = x.g_;
          this->b_ = x.b_;
          this->a_ = x.a_;
        }

        return *this;
      }

      Color::
      ~Color ()
      {
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace prj
{
  namespace srl
  {
    namespace spt
    {
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace spt
    {
      void
      operator<< (::xercesc::DOMElement& e, const ColorValue& i)
      {
        e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const ColorValue& i)
      {
        a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);
      }

      void
      operator<< (::xml_schema::ListStream& l,
                  const ColorValue& i)
      {
        l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);
      }

      void
      operator<< (::xercesc::DOMElement& e, const Color& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // r
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "r",
              e));

          s << i.r ();
        }

        // g
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "g",
              e));

          s << i.g ();
        }

        // b
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "b",
              e));

          s << i.b ();
        }

        // a
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "a",
              e));

          s << i.a ();
        }
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

