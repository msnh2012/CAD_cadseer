// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "prjsrlsptseershape.h"

namespace prj
{
  namespace srl
  {
    namespace spt
    {
      // ShapeIdRecord
      // 

      const ShapeIdRecord::IdType& ShapeIdRecord::
      id () const
      {
        return this->id_.get ();
      }

      ShapeIdRecord::IdType& ShapeIdRecord::
      id ()
      {
        return this->id_.get ();
      }

      void ShapeIdRecord::
      id (const IdType& x)
      {
        this->id_.set (x);
      }

      void ShapeIdRecord::
      id (::std::unique_ptr< IdType > x)
      {
        this->id_.set (std::move (x));
      }

      const ShapeIdRecord::IdType& ShapeIdRecord::
      id_default_value ()
      {
        return id_default_value_;
      }

      const ShapeIdRecord::ShapeOffsetType& ShapeIdRecord::
      shapeOffset () const
      {
        return this->shapeOffset_.get ();
      }

      ShapeIdRecord::ShapeOffsetType& ShapeIdRecord::
      shapeOffset ()
      {
        return this->shapeOffset_.get ();
      }

      void ShapeIdRecord::
      shapeOffset (const ShapeOffsetType& x)
      {
        this->shapeOffset_.set (x);
      }

      ShapeIdRecord::ShapeOffsetType ShapeIdRecord::
      shapeOffset_default_value ()
      {
        return ShapeOffsetType (18446744073709551615ULL);
      }


      // EvolveRecord
      // 

      const EvolveRecord::IdInType& EvolveRecord::
      idIn () const
      {
        return this->idIn_.get ();
      }

      EvolveRecord::IdInType& EvolveRecord::
      idIn ()
      {
        return this->idIn_.get ();
      }

      void EvolveRecord::
      idIn (const IdInType& x)
      {
        this->idIn_.set (x);
      }

      void EvolveRecord::
      idIn (::std::unique_ptr< IdInType > x)
      {
        this->idIn_.set (std::move (x));
      }

      const EvolveRecord::IdInType& EvolveRecord::
      idIn_default_value ()
      {
        return idIn_default_value_;
      }

      const EvolveRecord::IdOutType& EvolveRecord::
      idOut () const
      {
        return this->idOut_.get ();
      }

      EvolveRecord::IdOutType& EvolveRecord::
      idOut ()
      {
        return this->idOut_.get ();
      }

      void EvolveRecord::
      idOut (const IdOutType& x)
      {
        this->idOut_.set (x);
      }

      void EvolveRecord::
      idOut (::std::unique_ptr< IdOutType > x)
      {
        this->idOut_.set (std::move (x));
      }

      const EvolveRecord::IdOutType& EvolveRecord::
      idOut_default_value ()
      {
        return idOut_default_value_;
      }


      // FeatureTagRecord
      // 

      const FeatureTagRecord::IdType& FeatureTagRecord::
      id () const
      {
        return this->id_.get ();
      }

      FeatureTagRecord::IdType& FeatureTagRecord::
      id ()
      {
        return this->id_.get ();
      }

      void FeatureTagRecord::
      id (const IdType& x)
      {
        this->id_.set (x);
      }

      void FeatureTagRecord::
      id (::std::unique_ptr< IdType > x)
      {
        this->id_.set (std::move (x));
      }

      const FeatureTagRecord::IdType& FeatureTagRecord::
      id_default_value ()
      {
        return id_default_value_;
      }

      const FeatureTagRecord::TagType& FeatureTagRecord::
      tag () const
      {
        return this->tag_.get ();
      }

      FeatureTagRecord::TagType& FeatureTagRecord::
      tag ()
      {
        return this->tag_.get ();
      }

      void FeatureTagRecord::
      tag (const TagType& x)
      {
        this->tag_.set (x);
      }

      void FeatureTagRecord::
      tag (::std::unique_ptr< TagType > x)
      {
        this->tag_.set (std::move (x));
      }

      const FeatureTagRecord::TagType& FeatureTagRecord::
      tag_default_value ()
      {
        return tag_default_value_;
      }


      // DerivedRecord
      // 

      const DerivedRecord::IdSetSequence& DerivedRecord::
      idSet () const
      {
        return this->idSet_;
      }

      DerivedRecord::IdSetSequence& DerivedRecord::
      idSet ()
      {
        return this->idSet_;
      }

      void DerivedRecord::
      idSet (const IdSetSequence& s)
      {
        this->idSet_ = s;
      }

      const DerivedRecord::IdType& DerivedRecord::
      id () const
      {
        return this->id_.get ();
      }

      DerivedRecord::IdType& DerivedRecord::
      id ()
      {
        return this->id_.get ();
      }

      void DerivedRecord::
      id (const IdType& x)
      {
        this->id_.set (x);
      }

      void DerivedRecord::
      id (::std::unique_ptr< IdType > x)
      {
        this->id_.set (std::move (x));
      }

      const DerivedRecord::IdType& DerivedRecord::
      id_default_value ()
      {
        return id_default_value_;
      }


      // SeerShape
      // 

      const SeerShape::RootShapeIdType& SeerShape::
      rootShapeId () const
      {
        return this->rootShapeId_.get ();
      }

      SeerShape::RootShapeIdType& SeerShape::
      rootShapeId ()
      {
        return this->rootShapeId_.get ();
      }

      void SeerShape::
      rootShapeId (const RootShapeIdType& x)
      {
        this->rootShapeId_.set (x);
      }

      void SeerShape::
      rootShapeId (::std::unique_ptr< RootShapeIdType > x)
      {
        this->rootShapeId_.set (std::move (x));
      }

      const SeerShape::RootShapeIdType& SeerShape::
      rootShapeId_default_value ()
      {
        return rootShapeId_default_value_;
      }

      const SeerShape::ShapeIdContainerSequence& SeerShape::
      shapeIdContainer () const
      {
        return this->shapeIdContainer_;
      }

      SeerShape::ShapeIdContainerSequence& SeerShape::
      shapeIdContainer ()
      {
        return this->shapeIdContainer_;
      }

      void SeerShape::
      shapeIdContainer (const ShapeIdContainerSequence& s)
      {
        this->shapeIdContainer_ = s;
      }

      const SeerShape::EvolveContainerSequence& SeerShape::
      evolveContainer () const
      {
        return this->evolveContainer_;
      }

      SeerShape::EvolveContainerSequence& SeerShape::
      evolveContainer ()
      {
        return this->evolveContainer_;
      }

      void SeerShape::
      evolveContainer (const EvolveContainerSequence& s)
      {
        this->evolveContainer_ = s;
      }

      const SeerShape::FeatureTagContainerSequence& SeerShape::
      featureTagContainer () const
      {
        return this->featureTagContainer_;
      }

      SeerShape::FeatureTagContainerSequence& SeerShape::
      featureTagContainer ()
      {
        return this->featureTagContainer_;
      }

      void SeerShape::
      featureTagContainer (const FeatureTagContainerSequence& s)
      {
        this->featureTagContainer_ = s;
      }

      const SeerShape::DerivedContainerSequence& SeerShape::
      derivedContainer () const
      {
        return this->derivedContainer_;
      }

      SeerShape::DerivedContainerSequence& SeerShape::
      derivedContainer ()
      {
        return this->derivedContainer_;
      }

      void SeerShape::
      derivedContainer (const DerivedContainerSequence& s)
      {
        this->derivedContainer_ = s;
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace spt
    {
      // ShapeIdRecord
      //

      const ShapeIdRecord::IdType ShapeIdRecord::id_default_value_ (
        "00000000-0000-0000-0000-000000000000");

      ShapeIdRecord::
      ShapeIdRecord (const IdType& id,
                     const ShapeOffsetType& shapeOffset)
      : ::xml_schema::Type (),
        id_ (id, this),
        shapeOffset_ (shapeOffset, this)
      {
      }

      ShapeIdRecord::
      ShapeIdRecord (const ShapeIdRecord& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        id_ (x.id_, f, this),
        shapeOffset_ (x.shapeOffset_, f, this)
      {
      }

      ShapeIdRecord::
      ShapeIdRecord (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        id_ (this),
        shapeOffset_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void ShapeIdRecord::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // id
          //
          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< IdType > r (
              IdTraits::create (i, f, this));

            if (!id_.present ())
            {
              this->id_.set (::std::move (r));
              continue;
            }
          }

          // shapeOffset
          //
          if (n.name () == "shapeOffset" && n.namespace_ ().empty ())
          {
            if (!shapeOffset_.present ())
            {
              this->shapeOffset_.set (ShapeOffsetTraits::create (i, f, this));
              continue;
            }
          }

          break;
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "id",
            "");
        }

        if (!shapeOffset_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "shapeOffset",
            "");
        }
      }

      ShapeIdRecord* ShapeIdRecord::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class ShapeIdRecord (*this, f, c);
      }

      ShapeIdRecord& ShapeIdRecord::
      operator= (const ShapeIdRecord& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->id_ = x.id_;
          this->shapeOffset_ = x.shapeOffset_;
        }

        return *this;
      }

      ShapeIdRecord::
      ~ShapeIdRecord ()
      {
      }

      // EvolveRecord
      //

      const EvolveRecord::IdInType EvolveRecord::idIn_default_value_ (
        "00000000-0000-0000-0000-000000000000");

      const EvolveRecord::IdOutType EvolveRecord::idOut_default_value_ (
        "00000000-0000-0000-0000-000000000000");

      EvolveRecord::
      EvolveRecord (const IdInType& idIn,
                    const IdOutType& idOut)
      : ::xml_schema::Type (),
        idIn_ (idIn, this),
        idOut_ (idOut, this)
      {
      }

      EvolveRecord::
      EvolveRecord (const EvolveRecord& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        idIn_ (x.idIn_, f, this),
        idOut_ (x.idOut_, f, this)
      {
      }

      EvolveRecord::
      EvolveRecord (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        idIn_ (this),
        idOut_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void EvolveRecord::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // idIn
          //
          if (n.name () == "idIn" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< IdInType > r (
              IdInTraits::create (i, f, this));

            if (!idIn_.present ())
            {
              this->idIn_.set (::std::move (r));
              continue;
            }
          }

          // idOut
          //
          if (n.name () == "idOut" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< IdOutType > r (
              IdOutTraits::create (i, f, this));

            if (!idOut_.present ())
            {
              this->idOut_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!idIn_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "idIn",
            "");
        }

        if (!idOut_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "idOut",
            "");
        }
      }

      EvolveRecord* EvolveRecord::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class EvolveRecord (*this, f, c);
      }

      EvolveRecord& EvolveRecord::
      operator= (const EvolveRecord& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->idIn_ = x.idIn_;
          this->idOut_ = x.idOut_;
        }

        return *this;
      }

      EvolveRecord::
      ~EvolveRecord ()
      {
      }

      // FeatureTagRecord
      //

      const FeatureTagRecord::IdType FeatureTagRecord::id_default_value_ (
        "00000000-0000-0000-0000-000000000000");

      const FeatureTagRecord::TagType FeatureTagRecord::tag_default_value_ (
        "");

      FeatureTagRecord::
      FeatureTagRecord (const IdType& id,
                        const TagType& tag)
      : ::xml_schema::Type (),
        id_ (id, this),
        tag_ (tag, this)
      {
      }

      FeatureTagRecord::
      FeatureTagRecord (const FeatureTagRecord& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        id_ (x.id_, f, this),
        tag_ (x.tag_, f, this)
      {
      }

      FeatureTagRecord::
      FeatureTagRecord (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        id_ (this),
        tag_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void FeatureTagRecord::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // id
          //
          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< IdType > r (
              IdTraits::create (i, f, this));

            if (!id_.present ())
            {
              this->id_.set (::std::move (r));
              continue;
            }
          }

          // tag
          //
          if (n.name () == "tag" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< TagType > r (
              TagTraits::create (i, f, this));

            if (!tag_.present ())
            {
              this->tag_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "id",
            "");
        }

        if (!tag_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "tag",
            "");
        }
      }

      FeatureTagRecord* FeatureTagRecord::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class FeatureTagRecord (*this, f, c);
      }

      FeatureTagRecord& FeatureTagRecord::
      operator= (const FeatureTagRecord& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->id_ = x.id_;
          this->tag_ = x.tag_;
        }

        return *this;
      }

      FeatureTagRecord::
      ~FeatureTagRecord ()
      {
      }

      // DerivedRecord
      //

      const DerivedRecord::IdType DerivedRecord::id_default_value_ (
        "00000000-0000-0000-0000-000000000000");

      DerivedRecord::
      DerivedRecord (const IdType& id)
      : ::xml_schema::Type (),
        idSet_ (this),
        id_ (id, this)
      {
      }

      DerivedRecord::
      DerivedRecord (const DerivedRecord& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        idSet_ (x.idSet_, f, this),
        id_ (x.id_, f, this)
      {
      }

      DerivedRecord::
      DerivedRecord (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        idSet_ (this),
        id_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void DerivedRecord::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // idSet
          //
          if (n.name () == "idSet" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< IdSetType > r (
              IdSetTraits::create (i, f, this));

            this->idSet_.push_back (::std::move (r));
            continue;
          }

          // id
          //
          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< IdType > r (
              IdTraits::create (i, f, this));

            if (!id_.present ())
            {
              this->id_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "id",
            "");
        }
      }

      DerivedRecord* DerivedRecord::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class DerivedRecord (*this, f, c);
      }

      DerivedRecord& DerivedRecord::
      operator= (const DerivedRecord& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->idSet_ = x.idSet_;
          this->id_ = x.id_;
        }

        return *this;
      }

      DerivedRecord::
      ~DerivedRecord ()
      {
      }

      // SeerShape
      //

      const SeerShape::RootShapeIdType SeerShape::rootShapeId_default_value_ (
        "00000000-0000-0000-0000-000000000000");

      SeerShape::
      SeerShape (const RootShapeIdType& rootShapeId)
      : ::xml_schema::Type (),
        rootShapeId_ (rootShapeId, this),
        shapeIdContainer_ (this),
        evolveContainer_ (this),
        featureTagContainer_ (this),
        derivedContainer_ (this)
      {
      }

      SeerShape::
      SeerShape (const SeerShape& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        rootShapeId_ (x.rootShapeId_, f, this),
        shapeIdContainer_ (x.shapeIdContainer_, f, this),
        evolveContainer_ (x.evolveContainer_, f, this),
        featureTagContainer_ (x.featureTagContainer_, f, this),
        derivedContainer_ (x.derivedContainer_, f, this)
      {
      }

      SeerShape::
      SeerShape (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        rootShapeId_ (this),
        shapeIdContainer_ (this),
        evolveContainer_ (this),
        featureTagContainer_ (this),
        derivedContainer_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void SeerShape::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // rootShapeId
          //
          if (n.name () == "rootShapeId" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< RootShapeIdType > r (
              RootShapeIdTraits::create (i, f, this));

            if (!rootShapeId_.present ())
            {
              this->rootShapeId_.set (::std::move (r));
              continue;
            }
          }

          // shapeIdContainer
          //
          if (n.name () == "shapeIdContainer" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ShapeIdContainerType > r (
              ShapeIdContainerTraits::create (i, f, this));

            this->shapeIdContainer_.push_back (::std::move (r));
            continue;
          }

          // evolveContainer
          //
          if (n.name () == "evolveContainer" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< EvolveContainerType > r (
              EvolveContainerTraits::create (i, f, this));

            this->evolveContainer_.push_back (::std::move (r));
            continue;
          }

          // featureTagContainer
          //
          if (n.name () == "featureTagContainer" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< FeatureTagContainerType > r (
              FeatureTagContainerTraits::create (i, f, this));

            this->featureTagContainer_.push_back (::std::move (r));
            continue;
          }

          // derivedContainer
          //
          if (n.name () == "derivedContainer" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< DerivedContainerType > r (
              DerivedContainerTraits::create (i, f, this));

            this->derivedContainer_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        if (!rootShapeId_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "rootShapeId",
            "");
        }
      }

      SeerShape* SeerShape::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class SeerShape (*this, f, c);
      }

      SeerShape& SeerShape::
      operator= (const SeerShape& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->rootShapeId_ = x.rootShapeId_;
          this->shapeIdContainer_ = x.shapeIdContainer_;
          this->evolveContainer_ = x.evolveContainer_;
          this->featureTagContainer_ = x.featureTagContainer_;
          this->derivedContainer_ = x.derivedContainer_;
        }

        return *this;
      }

      SeerShape::
      ~SeerShape ()
      {
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace prj
{
  namespace srl
  {
    namespace spt
    {
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace spt
    {
      void
      operator<< (::xercesc::DOMElement& e, const ShapeIdRecord& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // id
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << i.id ();
        }

        // shapeOffset
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "shapeOffset",
              e));

          s << i.shapeOffset ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const EvolveRecord& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // idIn
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "idIn",
              e));

          s << i.idIn ();
        }

        // idOut
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "idOut",
              e));

          s << i.idOut ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const FeatureTagRecord& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // id
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << i.id ();
        }

        // tag
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "tag",
              e));

          s << i.tag ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const DerivedRecord& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // idSet
        //
        for (DerivedRecord::IdSetConstIterator
             b (i.idSet ().begin ()), n (i.idSet ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "idSet",
              e));

          s << *b;
        }

        // id
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << i.id ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const SeerShape& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // rootShapeId
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "rootShapeId",
              e));

          s << i.rootShapeId ();
        }

        // shapeIdContainer
        //
        for (SeerShape::ShapeIdContainerConstIterator
             b (i.shapeIdContainer ().begin ()), n (i.shapeIdContainer ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "shapeIdContainer",
              e));

          s << *b;
        }

        // evolveContainer
        //
        for (SeerShape::EvolveContainerConstIterator
             b (i.evolveContainer ().begin ()), n (i.evolveContainer ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "evolveContainer",
              e));

          s << *b;
        }

        // featureTagContainer
        //
        for (SeerShape::FeatureTagContainerConstIterator
             b (i.featureTagContainer ().begin ()), n (i.featureTagContainer ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "featureTagContainer",
              e));

          s << *b;
        }

        // derivedContainer
        //
        for (SeerShape::DerivedContainerConstIterator
             b (i.derivedContainer ().begin ()), n (i.derivedContainer ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "derivedContainer",
              e));

          s << *b;
        }
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

