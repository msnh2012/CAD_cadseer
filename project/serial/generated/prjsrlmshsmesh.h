// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef PRJ_SRL_MSHS_PRJSRLMSHSMESH_H
#define PRJ_SRL_MSHS_PRJSRLMSHSMESH_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include "../../../xmlbase.h"

// Forward declarations.
//
namespace prj
{
  namespace srl
  {
    namespace mshs
    {
      class ParametersOCCT;
      class ParametersNetgen;
      class ParametersGMSHOption;
      class ParametersGMSH;
      class Face;
      class Surface;
    }
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "prjsrlsptvectormath.h"

namespace prj
{
  namespace srl
  {
    namespace mshs
    {
      class ParametersOCCT: public ::xml_schema::Type
      {
        public:
        // angle
        //
        typedef ::xml_schema::Double AngleType;
        typedef ::xsd::cxx::tree::traits< AngleType, char, ::xsd::cxx::tree::schema_type::double_ > AngleTraits;

        const AngleType&
        angle () const;

        AngleType&
        angle ();

        void
        angle (const AngleType& x);

        // deflection
        //
        typedef ::xml_schema::Double DeflectionType;
        typedef ::xsd::cxx::tree::traits< DeflectionType, char, ::xsd::cxx::tree::schema_type::double_ > DeflectionTraits;

        const DeflectionType&
        deflection () const;

        DeflectionType&
        deflection ();

        void
        deflection (const DeflectionType& x);

        // angleInterior
        //
        typedef ::xml_schema::Double AngleInteriorType;
        typedef ::xsd::cxx::tree::traits< AngleInteriorType, char, ::xsd::cxx::tree::schema_type::double_ > AngleInteriorTraits;

        const AngleInteriorType&
        angleInterior () const;

        AngleInteriorType&
        angleInterior ();

        void
        angleInterior (const AngleInteriorType& x);

        // deflectionInterior
        //
        typedef ::xml_schema::Double DeflectionInteriorType;
        typedef ::xsd::cxx::tree::traits< DeflectionInteriorType, char, ::xsd::cxx::tree::schema_type::double_ > DeflectionInteriorTraits;

        const DeflectionInteriorType&
        deflectionInterior () const;

        DeflectionInteriorType&
        deflectionInterior ();

        void
        deflectionInterior (const DeflectionInteriorType& x);

        // minSize
        //
        typedef ::xml_schema::Double MinSizeType;
        typedef ::xsd::cxx::tree::traits< MinSizeType, char, ::xsd::cxx::tree::schema_type::double_ > MinSizeTraits;

        const MinSizeType&
        minSize () const;

        MinSizeType&
        minSize ();

        void
        minSize (const MinSizeType& x);

        // inParallel
        //
        typedef ::xml_schema::Boolean InParallelType;
        typedef ::xsd::cxx::tree::traits< InParallelType, char > InParallelTraits;

        const InParallelType&
        inParallel () const;

        InParallelType&
        inParallel ();

        void
        inParallel (const InParallelType& x);

        // relative
        //
        typedef ::xml_schema::Boolean RelativeType;
        typedef ::xsd::cxx::tree::traits< RelativeType, char > RelativeTraits;

        const RelativeType&
        relative () const;

        RelativeType&
        relative ();

        void
        relative (const RelativeType& x);

        // internalVerticesMode
        //
        typedef ::xml_schema::Boolean InternalVerticesModeType;
        typedef ::xsd::cxx::tree::traits< InternalVerticesModeType, char > InternalVerticesModeTraits;

        const InternalVerticesModeType&
        internalVerticesMode () const;

        InternalVerticesModeType&
        internalVerticesMode ();

        void
        internalVerticesMode (const InternalVerticesModeType& x);

        // controlSurfaceDeflection
        //
        typedef ::xml_schema::Boolean ControlSurfaceDeflectionType;
        typedef ::xsd::cxx::tree::traits< ControlSurfaceDeflectionType, char > ControlSurfaceDeflectionTraits;

        const ControlSurfaceDeflectionType&
        controlSurfaceDeflection () const;

        ControlSurfaceDeflectionType&
        controlSurfaceDeflection ();

        void
        controlSurfaceDeflection (const ControlSurfaceDeflectionType& x);

        // cleanModel
        //
        typedef ::xml_schema::Boolean CleanModelType;
        typedef ::xsd::cxx::tree::traits< CleanModelType, char > CleanModelTraits;

        const CleanModelType&
        cleanModel () const;

        CleanModelType&
        cleanModel ();

        void
        cleanModel (const CleanModelType& x);

        // adjustMinSize
        //
        typedef ::xml_schema::Boolean AdjustMinSizeType;
        typedef ::xsd::cxx::tree::traits< AdjustMinSizeType, char > AdjustMinSizeTraits;

        const AdjustMinSizeType&
        adjustMinSize () const;

        AdjustMinSizeType&
        adjustMinSize ();

        void
        adjustMinSize (const AdjustMinSizeType& x);

        // Constructors.
        //
        ParametersOCCT (const AngleType&,
                        const DeflectionType&,
                        const AngleInteriorType&,
                        const DeflectionInteriorType&,
                        const MinSizeType&,
                        const InParallelType&,
                        const RelativeType&,
                        const InternalVerticesModeType&,
                        const ControlSurfaceDeflectionType&,
                        const CleanModelType&,
                        const AdjustMinSizeType&);

        ParametersOCCT (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

        ParametersOCCT (const ParametersOCCT& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

        virtual ParametersOCCT*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        ParametersOCCT&
        operator= (const ParametersOCCT& x);

        virtual 
        ~ParametersOCCT ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< AngleType > angle_;
        ::xsd::cxx::tree::one< DeflectionType > deflection_;
        ::xsd::cxx::tree::one< AngleInteriorType > angleInterior_;
        ::xsd::cxx::tree::one< DeflectionInteriorType > deflectionInterior_;
        ::xsd::cxx::tree::one< MinSizeType > minSize_;
        ::xsd::cxx::tree::one< InParallelType > inParallel_;
        ::xsd::cxx::tree::one< RelativeType > relative_;
        ::xsd::cxx::tree::one< InternalVerticesModeType > internalVerticesMode_;
        ::xsd::cxx::tree::one< ControlSurfaceDeflectionType > controlSurfaceDeflection_;
        ::xsd::cxx::tree::one< CleanModelType > cleanModel_;
        ::xsd::cxx::tree::one< AdjustMinSizeType > adjustMinSize_;
      };

      class ParametersNetgen: public ::xml_schema::Type
      {
        public:
        // useLocalH
        //
        typedef ::xml_schema::Boolean UseLocalHType;
        typedef ::xsd::cxx::tree::traits< UseLocalHType, char > UseLocalHTraits;

        const UseLocalHType&
        useLocalH () const;

        UseLocalHType&
        useLocalH ();

        void
        useLocalH (const UseLocalHType& x);

        // maxH
        //
        typedef ::xml_schema::Double MaxHType;
        typedef ::xsd::cxx::tree::traits< MaxHType, char, ::xsd::cxx::tree::schema_type::double_ > MaxHTraits;

        const MaxHType&
        maxH () const;

        MaxHType&
        maxH ();

        void
        maxH (const MaxHType& x);

        // minH
        //
        typedef ::xml_schema::Double MinHType;
        typedef ::xsd::cxx::tree::traits< MinHType, char, ::xsd::cxx::tree::schema_type::double_ > MinHTraits;

        const MinHType&
        minH () const;

        MinHType&
        minH ();

        void
        minH (const MinHType& x);

        // fineness
        //
        typedef ::xml_schema::Double FinenessType;
        typedef ::xsd::cxx::tree::traits< FinenessType, char, ::xsd::cxx::tree::schema_type::double_ > FinenessTraits;

        const FinenessType&
        fineness () const;

        FinenessType&
        fineness ();

        void
        fineness (const FinenessType& x);

        // grading
        //
        typedef ::xml_schema::Double GradingType;
        typedef ::xsd::cxx::tree::traits< GradingType, char, ::xsd::cxx::tree::schema_type::double_ > GradingTraits;

        const GradingType&
        grading () const;

        GradingType&
        grading ();

        void
        grading (const GradingType& x);

        // elementsPerEdge
        //
        typedef ::xml_schema::Double ElementsPerEdgeType;
        typedef ::xsd::cxx::tree::traits< ElementsPerEdgeType, char, ::xsd::cxx::tree::schema_type::double_ > ElementsPerEdgeTraits;

        const ElementsPerEdgeType&
        elementsPerEdge () const;

        ElementsPerEdgeType&
        elementsPerEdge ();

        void
        elementsPerEdge (const ElementsPerEdgeType& x);

        // elementsPerCurve
        //
        typedef ::xml_schema::Double ElementsPerCurveType;
        typedef ::xsd::cxx::tree::traits< ElementsPerCurveType, char, ::xsd::cxx::tree::schema_type::double_ > ElementsPerCurveTraits;

        const ElementsPerCurveType&
        elementsPerCurve () const;

        ElementsPerCurveType&
        elementsPerCurve ();

        void
        elementsPerCurve (const ElementsPerCurveType& x);

        // closeEdgeEnable
        //
        typedef ::xml_schema::Double CloseEdgeEnableType;
        typedef ::xsd::cxx::tree::traits< CloseEdgeEnableType, char, ::xsd::cxx::tree::schema_type::double_ > CloseEdgeEnableTraits;

        const CloseEdgeEnableType&
        closeEdgeEnable () const;

        CloseEdgeEnableType&
        closeEdgeEnable ();

        void
        closeEdgeEnable (const CloseEdgeEnableType& x);

        // closeEdgeFactor
        //
        typedef ::xml_schema::Double CloseEdgeFactorType;
        typedef ::xsd::cxx::tree::traits< CloseEdgeFactorType, char, ::xsd::cxx::tree::schema_type::double_ > CloseEdgeFactorTraits;

        const CloseEdgeFactorType&
        closeEdgeFactor () const;

        CloseEdgeFactorType&
        closeEdgeFactor ();

        void
        closeEdgeFactor (const CloseEdgeFactorType& x);

        // minEdgeLenEnable
        //
        typedef ::xml_schema::Boolean MinEdgeLenEnableType;
        typedef ::xsd::cxx::tree::traits< MinEdgeLenEnableType, char > MinEdgeLenEnableTraits;

        const MinEdgeLenEnableType&
        minEdgeLenEnable () const;

        MinEdgeLenEnableType&
        minEdgeLenEnable ();

        void
        minEdgeLenEnable (const MinEdgeLenEnableType& x);

        // minEdgeLen
        //
        typedef ::xml_schema::Double MinEdgeLenType;
        typedef ::xsd::cxx::tree::traits< MinEdgeLenType, char, ::xsd::cxx::tree::schema_type::double_ > MinEdgeLenTraits;

        const MinEdgeLenType&
        minEdgeLen () const;

        MinEdgeLenType&
        minEdgeLen ();

        void
        minEdgeLen (const MinEdgeLenType& x);

        // secondOrder
        //
        typedef ::xml_schema::Boolean SecondOrderType;
        typedef ::xsd::cxx::tree::traits< SecondOrderType, char > SecondOrderTraits;

        const SecondOrderType&
        secondOrder () const;

        SecondOrderType&
        secondOrder ();

        void
        secondOrder (const SecondOrderType& x);

        // quadDominated
        //
        typedef ::xml_schema::Boolean QuadDominatedType;
        typedef ::xsd::cxx::tree::traits< QuadDominatedType, char > QuadDominatedTraits;

        const QuadDominatedType&
        quadDominated () const;

        QuadDominatedType&
        quadDominated ();

        void
        quadDominated (const QuadDominatedType& x);

        // optSurfMeshEnable
        //
        typedef ::xml_schema::Boolean OptSurfMeshEnableType;
        typedef ::xsd::cxx::tree::traits< OptSurfMeshEnableType, char > OptSurfMeshEnableTraits;

        const OptSurfMeshEnableType&
        optSurfMeshEnable () const;

        OptSurfMeshEnableType&
        optSurfMeshEnable ();

        void
        optSurfMeshEnable (const OptSurfMeshEnableType& x);

        // optVolMeshEnable
        //
        typedef ::xml_schema::Boolean OptVolMeshEnableType;
        typedef ::xsd::cxx::tree::traits< OptVolMeshEnableType, char > OptVolMeshEnableTraits;

        const OptVolMeshEnableType&
        optVolMeshEnable () const;

        OptVolMeshEnableType&
        optVolMeshEnable ();

        void
        optVolMeshEnable (const OptVolMeshEnableType& x);

        // optSteps2d
        //
        typedef ::xml_schema::Int OptSteps2dType;
        typedef ::xsd::cxx::tree::traits< OptSteps2dType, char > OptSteps2dTraits;

        const OptSteps2dType&
        optSteps2d () const;

        OptSteps2dType&
        optSteps2d ();

        void
        optSteps2d (const OptSteps2dType& x);

        // optSteps3d
        //
        typedef ::xml_schema::Int OptSteps3dType;
        typedef ::xsd::cxx::tree::traits< OptSteps3dType, char > OptSteps3dTraits;

        const OptSteps3dType&
        optSteps3d () const;

        OptSteps3dType&
        optSteps3d ();

        void
        optSteps3d (const OptSteps3dType& x);

        // invertTets
        //
        typedef ::xml_schema::Boolean InvertTetsType;
        typedef ::xsd::cxx::tree::traits< InvertTetsType, char > InvertTetsTraits;

        const InvertTetsType&
        invertTets () const;

        InvertTetsType&
        invertTets ();

        void
        invertTets (const InvertTetsType& x);

        // invertTrigs
        //
        typedef ::xml_schema::Boolean InvertTrigsType;
        typedef ::xsd::cxx::tree::traits< InvertTrigsType, char > InvertTrigsTraits;

        const InvertTrigsType&
        invertTrigs () const;

        InvertTrigsType&
        invertTrigs ();

        void
        invertTrigs (const InvertTrigsType& x);

        // checkOverlap
        //
        typedef ::xml_schema::Boolean CheckOverlapType;
        typedef ::xsd::cxx::tree::traits< CheckOverlapType, char > CheckOverlapTraits;

        const CheckOverlapType&
        checkOverlap () const;

        CheckOverlapType&
        checkOverlap ();

        void
        checkOverlap (const CheckOverlapType& x);

        // checkOverlappingBoundary
        //
        typedef ::xml_schema::Boolean CheckOverlappingBoundaryType;
        typedef ::xsd::cxx::tree::traits< CheckOverlappingBoundaryType, char > CheckOverlappingBoundaryTraits;

        const CheckOverlappingBoundaryType&
        checkOverlappingBoundary () const;

        CheckOverlappingBoundaryType&
        checkOverlappingBoundary ();

        void
        checkOverlappingBoundary (const CheckOverlappingBoundaryType& x);

        // Constructors.
        //
        ParametersNetgen (const UseLocalHType&,
                          const MaxHType&,
                          const MinHType&,
                          const FinenessType&,
                          const GradingType&,
                          const ElementsPerEdgeType&,
                          const ElementsPerCurveType&,
                          const CloseEdgeEnableType&,
                          const CloseEdgeFactorType&,
                          const MinEdgeLenEnableType&,
                          const MinEdgeLenType&,
                          const SecondOrderType&,
                          const QuadDominatedType&,
                          const OptSurfMeshEnableType&,
                          const OptVolMeshEnableType&,
                          const OptSteps2dType&,
                          const OptSteps3dType&,
                          const InvertTetsType&,
                          const InvertTrigsType&,
                          const CheckOverlapType&,
                          const CheckOverlappingBoundaryType&);

        ParametersNetgen (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

        ParametersNetgen (const ParametersNetgen& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

        virtual ParametersNetgen*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        ParametersNetgen&
        operator= (const ParametersNetgen& x);

        virtual 
        ~ParametersNetgen ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< UseLocalHType > useLocalH_;
        ::xsd::cxx::tree::one< MaxHType > maxH_;
        ::xsd::cxx::tree::one< MinHType > minH_;
        ::xsd::cxx::tree::one< FinenessType > fineness_;
        ::xsd::cxx::tree::one< GradingType > grading_;
        ::xsd::cxx::tree::one< ElementsPerEdgeType > elementsPerEdge_;
        ::xsd::cxx::tree::one< ElementsPerCurveType > elementsPerCurve_;
        ::xsd::cxx::tree::one< CloseEdgeEnableType > closeEdgeEnable_;
        ::xsd::cxx::tree::one< CloseEdgeFactorType > closeEdgeFactor_;
        ::xsd::cxx::tree::one< MinEdgeLenEnableType > minEdgeLenEnable_;
        ::xsd::cxx::tree::one< MinEdgeLenType > minEdgeLen_;
        ::xsd::cxx::tree::one< SecondOrderType > secondOrder_;
        ::xsd::cxx::tree::one< QuadDominatedType > quadDominated_;
        ::xsd::cxx::tree::one< OptSurfMeshEnableType > optSurfMeshEnable_;
        ::xsd::cxx::tree::one< OptVolMeshEnableType > optVolMeshEnable_;
        ::xsd::cxx::tree::one< OptSteps2dType > optSteps2d_;
        ::xsd::cxx::tree::one< OptSteps3dType > optSteps3d_;
        ::xsd::cxx::tree::one< InvertTetsType > invertTets_;
        ::xsd::cxx::tree::one< InvertTrigsType > invertTrigs_;
        ::xsd::cxx::tree::one< CheckOverlapType > checkOverlap_;
        ::xsd::cxx::tree::one< CheckOverlappingBoundaryType > checkOverlappingBoundary_;
      };

      class ParametersGMSHOption: public ::xml_schema::Type
      {
        public:
        // key
        //
        typedef ::xml_schema::String KeyType;
        typedef ::xsd::cxx::tree::traits< KeyType, char > KeyTraits;

        const KeyType&
        key () const;

        KeyType&
        key ();

        void
        key (const KeyType& x);

        void
        key (::std::unique_ptr< KeyType > p);

        // value
        //
        typedef ::xml_schema::Double ValueType;
        typedef ::xsd::cxx::tree::traits< ValueType, char, ::xsd::cxx::tree::schema_type::double_ > ValueTraits;

        const ValueType&
        value () const;

        ValueType&
        value ();

        void
        value (const ValueType& x);

        // Constructors.
        //
        ParametersGMSHOption (const KeyType&,
                              const ValueType&);

        ParametersGMSHOption (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

        ParametersGMSHOption (const ParametersGMSHOption& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

        virtual ParametersGMSHOption*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        ParametersGMSHOption&
        operator= (const ParametersGMSHOption& x);

        virtual 
        ~ParametersGMSHOption ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< KeyType > key_;
        ::xsd::cxx::tree::one< ValueType > value_;
      };

      class ParametersGMSH: public ::xml_schema::Type
      {
        public:
        // options
        //
        typedef ::prj::srl::mshs::ParametersGMSHOption OptionsType;
        typedef ::xsd::cxx::tree::sequence< OptionsType > OptionsSequence;
        typedef OptionsSequence::iterator OptionsIterator;
        typedef OptionsSequence::const_iterator OptionsConstIterator;
        typedef ::xsd::cxx::tree::traits< OptionsType, char > OptionsTraits;

        const OptionsSequence&
        options () const;

        OptionsSequence&
        options ();

        void
        options (const OptionsSequence& s);

        // refine
        //
        typedef ::xml_schema::Boolean RefineType;
        typedef ::xsd::cxx::tree::traits< RefineType, char > RefineTraits;

        const RefineType&
        refine () const;

        RefineType&
        refine ();

        void
        refine (const RefineType& x);

        // Constructors.
        //
        ParametersGMSH (const RefineType&);

        ParametersGMSH (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

        ParametersGMSH (const ParametersGMSH& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

        virtual ParametersGMSH*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        ParametersGMSH&
        operator= (const ParametersGMSH& x);

        virtual 
        ~ParametersGMSH ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        OptionsSequence options_;
        ::xsd::cxx::tree::one< RefineType > refine_;
      };

      class Face: public ::xml_schema::Type
      {
        public:
        // indexes
        //
        typedef ::xml_schema::UnsignedLong IndexesType;
        typedef ::xsd::cxx::tree::sequence< IndexesType > IndexesSequence;
        typedef IndexesSequence::iterator IndexesIterator;
        typedef IndexesSequence::const_iterator IndexesConstIterator;
        typedef ::xsd::cxx::tree::traits< IndexesType, char > IndexesTraits;

        const IndexesSequence&
        indexes () const;

        IndexesSequence&
        indexes ();

        void
        indexes (const IndexesSequence& s);

        // Constructors.
        //
        Face ();

        Face (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

        Face (const Face& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

        virtual Face*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        Face&
        operator= (const Face& x);

        virtual 
        ~Face ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        IndexesSequence indexes_;
      };

      class Surface: public ::xml_schema::Type
      {
        public:
        // points
        //
        typedef ::prj::srl::spt::Vec3d PointsType;
        typedef ::xsd::cxx::tree::sequence< PointsType > PointsSequence;
        typedef PointsSequence::iterator PointsIterator;
        typedef PointsSequence::const_iterator PointsConstIterator;
        typedef ::xsd::cxx::tree::traits< PointsType, char > PointsTraits;

        const PointsSequence&
        points () const;

        PointsSequence&
        points ();

        void
        points (const PointsSequence& s);

        // faces
        //
        typedef ::prj::srl::mshs::Face FacesType;
        typedef ::xsd::cxx::tree::sequence< FacesType > FacesSequence;
        typedef FacesSequence::iterator FacesIterator;
        typedef FacesSequence::const_iterator FacesConstIterator;
        typedef ::xsd::cxx::tree::traits< FacesType, char > FacesTraits;

        const FacesSequence&
        faces () const;

        FacesSequence&
        faces ();

        void
        faces (const FacesSequence& s);

        // Constructors.
        //
        Surface ();

        Surface (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

        Surface (const Surface& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

        virtual Surface*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        Surface&
        operator= (const Surface& x);

        virtual 
        ~Surface ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        PointsSequence points_;
        FacesSequence faces_;
      };
    }
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace prj
{
  namespace srl
  {
    namespace mshs
    {
    }
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace prj
{
  namespace srl
  {
    namespace mshs
    {
      void
      operator<< (::xercesc::DOMElement&, const ParametersOCCT&);

      void
      operator<< (::xercesc::DOMElement&, const ParametersNetgen&);

      void
      operator<< (::xercesc::DOMElement&, const ParametersGMSHOption&);

      void
      operator<< (::xercesc::DOMElement&, const ParametersGMSH&);

      void
      operator<< (::xercesc::DOMElement&, const Face&);

      void
      operator<< (::xercesc::DOMElement&, const Surface&);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // PRJ_SRL_MSHS_PRJSRLMSHSMESH_H
