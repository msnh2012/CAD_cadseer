// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef PRJ_SRL_VWS_PRJSRLVWSVIEW_H
#define PRJ_SRL_VWS_PRJSRLVWSVIEW_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include "../../../xmlbase.h"

// Forward declarations.
//
namespace prj
{
  namespace srl
  {
    namespace vws
    {
      class State;
      class Ortho;
      class View;
    }
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "prjsrlsptvectormath.h"

namespace prj
{
  namespace srl
  {
    namespace vws
    {
      class State: public ::xml_schema::Type
      {
        public:
        // id
        //
        typedef ::xml_schema::String IdType;
        typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

        const IdType&
        id () const;

        IdType&
        id ();

        void
        id (const IdType& x);

        void
        id (::std::unique_ptr< IdType > p);

        static const IdType&
        id_default_value ();

        // visible
        //
        typedef ::xml_schema::Boolean VisibleType;
        typedef ::xsd::cxx::tree::traits< VisibleType, char > VisibleTraits;

        const VisibleType&
        visible () const;

        VisibleType&
        visible ();

        void
        visible (const VisibleType& x);

        static VisibleType
        visible_default_value ();

        // Constructors.
        //
        State (const IdType&,
               const VisibleType&);

        State (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

        State (const State& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

        virtual State*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        State&
        operator= (const State& x);

        virtual 
        ~State ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< IdType > id_;
        static const IdType id_default_value_;
        ::xsd::cxx::tree::one< VisibleType > visible_;
      };

      class Ortho: public ::xml_schema::Type
      {
        public:
        // left
        //
        typedef ::xml_schema::Double LeftType;
        typedef ::xsd::cxx::tree::traits< LeftType, char, ::xsd::cxx::tree::schema_type::double_ > LeftTraits;

        const LeftType&
        left () const;

        LeftType&
        left ();

        void
        left (const LeftType& x);

        // right
        //
        typedef ::xml_schema::Double RightType;
        typedef ::xsd::cxx::tree::traits< RightType, char, ::xsd::cxx::tree::schema_type::double_ > RightTraits;

        const RightType&
        right () const;

        RightType&
        right ();

        void
        right (const RightType& x);

        // bottom
        //
        typedef ::xml_schema::Double BottomType;
        typedef ::xsd::cxx::tree::traits< BottomType, char, ::xsd::cxx::tree::schema_type::double_ > BottomTraits;

        const BottomType&
        bottom () const;

        BottomType&
        bottom ();

        void
        bottom (const BottomType& x);

        // top
        //
        typedef ::xml_schema::Double TopType;
        typedef ::xsd::cxx::tree::traits< TopType, char, ::xsd::cxx::tree::schema_type::double_ > TopTraits;

        const TopType&
        top () const;

        TopType&
        top ();

        void
        top (const TopType& x);

        // near
        //
        typedef ::xml_schema::Double NearType;
        typedef ::xsd::cxx::tree::traits< NearType, char, ::xsd::cxx::tree::schema_type::double_ > NearTraits;

        const NearType&
        near () const;

        NearType&
        near ();

        void
        near (const NearType& x);

        // far
        //
        typedef ::xml_schema::Double FarType;
        typedef ::xsd::cxx::tree::traits< FarType, char, ::xsd::cxx::tree::schema_type::double_ > FarTraits;

        const FarType&
        far () const;

        FarType&
        far ();

        void
        far (const FarType& x);

        // Constructors.
        //
        Ortho (const LeftType&,
               const RightType&,
               const BottomType&,
               const TopType&,
               const NearType&,
               const FarType&);

        Ortho (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

        Ortho (const Ortho& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

        virtual Ortho*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        Ortho&
        operator= (const Ortho& x);

        virtual 
        ~Ortho ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< LeftType > left_;
        ::xsd::cxx::tree::one< RightType > right_;
        ::xsd::cxx::tree::one< BottomType > bottom_;
        ::xsd::cxx::tree::one< TopType > top_;
        ::xsd::cxx::tree::one< NearType > near_;
        ::xsd::cxx::tree::one< FarType > far_;
      };

      class View: public ::xml_schema::Type
      {
        public:
        // states
        //
        typedef ::prj::srl::vws::State StatesType;
        typedef ::xsd::cxx::tree::sequence< StatesType > StatesSequence;
        typedef StatesSequence::iterator StatesIterator;
        typedef StatesSequence::const_iterator StatesConstIterator;
        typedef ::xsd::cxx::tree::traits< StatesType, char > StatesTraits;

        const StatesSequence&
        states () const;

        StatesSequence&
        states ();

        void
        states (const StatesSequence& s);

        // csys
        //
        typedef ::prj::srl::spt::Matrixd CsysType;
        typedef ::xsd::cxx::tree::traits< CsysType, char > CsysTraits;

        const CsysType&
        csys () const;

        CsysType&
        csys ();

        void
        csys (const CsysType& x);

        void
        csys (::std::unique_ptr< CsysType > p);

        // ortho
        //
        typedef ::prj::srl::vws::Ortho OrthoType;
        typedef ::xsd::cxx::tree::optional< OrthoType > OrthoOptional;
        typedef ::xsd::cxx::tree::traits< OrthoType, char > OrthoTraits;

        const OrthoOptional&
        ortho () const;

        OrthoOptional&
        ortho ();

        void
        ortho (const OrthoType& x);

        void
        ortho (const OrthoOptional& x);

        void
        ortho (::std::unique_ptr< OrthoType > p);

        // Constructors.
        //
        View (const CsysType&);

        View (::std::unique_ptr< CsysType >);

        View (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

        View (const View& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

        virtual View*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        View&
        operator= (const View& x);

        virtual 
        ~View ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        StatesSequence states_;
        ::xsd::cxx::tree::one< CsysType > csys_;
        OrthoOptional ortho_;
      };
    }
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace prj
{
  namespace srl
  {
    namespace vws
    {
      // Parse a URI or a local file.
      //

      ::std::unique_ptr< ::prj::srl::vws::View >
      view (const ::std::string& uri,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::vws::View >
      view (const ::std::string& uri,
            ::xml_schema::ErrorHandler& eh,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::vws::View >
      view (const ::std::string& uri,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      // Parse std::istream.
      //

      ::std::unique_ptr< ::prj::srl::vws::View >
      view (::std::istream& is,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::vws::View >
      view (::std::istream& is,
            ::xml_schema::ErrorHandler& eh,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::vws::View >
      view (::std::istream& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::vws::View >
      view (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::vws::View >
      view (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::ErrorHandler& eh,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::vws::View >
      view (::std::istream& is,
            const ::std::string& id,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      // Parse xercesc::InputSource.
      //

      ::std::unique_ptr< ::prj::srl::vws::View >
      view (::xercesc::InputSource& is,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::vws::View >
      view (::xercesc::InputSource& is,
            ::xml_schema::ErrorHandler& eh,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::vws::View >
      view (::xercesc::InputSource& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      // Parse xercesc::DOMDocument.
      //

      ::std::unique_ptr< ::prj::srl::vws::View >
      view (const ::xercesc::DOMDocument& d,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::vws::View >
      view (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());
    }
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace prj
{
  namespace srl
  {
    namespace vws
    {
      void
      operator<< (::xercesc::DOMElement&, const State&);

      void
      operator<< (::xercesc::DOMElement&, const Ortho&);

      void
      operator<< (::xercesc::DOMElement&, const View&);

      // Serialize to std::ostream.
      //

      void
      view (::std::ostream& os,
            const ::prj::srl::vws::View& x, 
            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::Flags f = 0);

      void
      view (::std::ostream& os,
            const ::prj::srl::vws::View& x, 
            ::xml_schema::ErrorHandler& eh,
            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::Flags f = 0);

      void
      view (::std::ostream& os,
            const ::prj::srl::vws::View& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::Flags f = 0);

      // Serialize to xercesc::XMLFormatTarget.
      //

      void
      view (::xercesc::XMLFormatTarget& ft,
            const ::prj::srl::vws::View& x, 
            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::Flags f = 0);

      void
      view (::xercesc::XMLFormatTarget& ft,
            const ::prj::srl::vws::View& x, 
            ::xml_schema::ErrorHandler& eh,
            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::Flags f = 0);

      void
      view (::xercesc::XMLFormatTarget& ft,
            const ::prj::srl::vws::View& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::Flags f = 0);

      // Serialize to an existing xercesc::DOMDocument.
      //

      void
      view (::xercesc::DOMDocument& d,
            const ::prj::srl::vws::View& x,
            ::xml_schema::Flags f = 0);

      // Serialize to a new xercesc::DOMDocument.
      //

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
      view (const ::prj::srl::vws::View& x, 
            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
            ::xml_schema::Flags f = 0);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // PRJ_SRL_VWS_PRJSRLVWSVIEW_H
