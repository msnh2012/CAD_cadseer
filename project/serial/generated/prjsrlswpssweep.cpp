// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "prjsrlswpssweep.h"

namespace prj
{
  namespace srl
  {
    namespace swps
    {
      // SweepProfile
      // 

      const SweepProfile::PickType& SweepProfile::
      pick () const
      {
        return this->pick_.get ();
      }

      SweepProfile::PickType& SweepProfile::
      pick ()
      {
        return this->pick_.get ();
      }

      void SweepProfile::
      pick (const PickType& x)
      {
        this->pick_.set (x);
      }

      void SweepProfile::
      pick (::std::unique_ptr< PickType > x)
      {
        this->pick_.set (std::move (x));
      }

      const SweepProfile::ContactType& SweepProfile::
      contact () const
      {
        return this->contact_.get ();
      }

      SweepProfile::ContactType& SweepProfile::
      contact ()
      {
        return this->contact_.get ();
      }

      void SweepProfile::
      contact (const ContactType& x)
      {
        this->contact_.set (x);
      }

      void SweepProfile::
      contact (::std::unique_ptr< ContactType > x)
      {
        this->contact_.set (std::move (x));
      }

      const SweepProfile::CorrectionType& SweepProfile::
      correction () const
      {
        return this->correction_.get ();
      }

      SweepProfile::CorrectionType& SweepProfile::
      correction ()
      {
        return this->correction_.get ();
      }

      void SweepProfile::
      correction (const CorrectionType& x)
      {
        this->correction_.set (x);
      }

      void SweepProfile::
      correction (::std::unique_ptr< CorrectionType > x)
      {
        this->correction_.set (std::move (x));
      }

      const SweepProfile::ContactLabelType& SweepProfile::
      contactLabel () const
      {
        return this->contactLabel_.get ();
      }

      SweepProfile::ContactLabelType& SweepProfile::
      contactLabel ()
      {
        return this->contactLabel_.get ();
      }

      void SweepProfile::
      contactLabel (const ContactLabelType& x)
      {
        this->contactLabel_.set (x);
      }

      void SweepProfile::
      contactLabel (::std::unique_ptr< ContactLabelType > x)
      {
        this->contactLabel_.set (std::move (x));
      }

      const SweepProfile::CorrectionLabelType& SweepProfile::
      correctionLabel () const
      {
        return this->correctionLabel_.get ();
      }

      SweepProfile::CorrectionLabelType& SweepProfile::
      correctionLabel ()
      {
        return this->correctionLabel_.get ();
      }

      void SweepProfile::
      correctionLabel (const CorrectionLabelType& x)
      {
        this->correctionLabel_.set (x);
      }

      void SweepProfile::
      correctionLabel (::std::unique_ptr< CorrectionLabelType > x)
      {
        this->correctionLabel_.set (std::move (x));
      }


      // SweepAuxiliary
      // 

      const SweepAuxiliary::PickType& SweepAuxiliary::
      pick () const
      {
        return this->pick_.get ();
      }

      SweepAuxiliary::PickType& SweepAuxiliary::
      pick ()
      {
        return this->pick_.get ();
      }

      void SweepAuxiliary::
      pick (const PickType& x)
      {
        this->pick_.set (x);
      }

      void SweepAuxiliary::
      pick (::std::unique_ptr< PickType > x)
      {
        this->pick_.set (std::move (x));
      }

      const SweepAuxiliary::CurvilinearEquivalenceType& SweepAuxiliary::
      curvilinearEquivalence () const
      {
        return this->curvilinearEquivalence_.get ();
      }

      SweepAuxiliary::CurvilinearEquivalenceType& SweepAuxiliary::
      curvilinearEquivalence ()
      {
        return this->curvilinearEquivalence_.get ();
      }

      void SweepAuxiliary::
      curvilinearEquivalence (const CurvilinearEquivalenceType& x)
      {
        this->curvilinearEquivalence_.set (x);
      }

      void SweepAuxiliary::
      curvilinearEquivalence (::std::unique_ptr< CurvilinearEquivalenceType > x)
      {
        this->curvilinearEquivalence_.set (std::move (x));
      }

      const SweepAuxiliary::ContactTypeType& SweepAuxiliary::
      contactType () const
      {
        return this->contactType_.get ();
      }

      SweepAuxiliary::ContactTypeType& SweepAuxiliary::
      contactType ()
      {
        return this->contactType_.get ();
      }

      void SweepAuxiliary::
      contactType (const ContactTypeType& x)
      {
        this->contactType_.set (x);
      }

      void SweepAuxiliary::
      contactType (::std::unique_ptr< ContactTypeType > x)
      {
        this->contactType_.set (std::move (x));
      }

      const SweepAuxiliary::CurvilinearEquivalenceLabelType& SweepAuxiliary::
      curvilinearEquivalenceLabel () const
      {
        return this->curvilinearEquivalenceLabel_.get ();
      }

      SweepAuxiliary::CurvilinearEquivalenceLabelType& SweepAuxiliary::
      curvilinearEquivalenceLabel ()
      {
        return this->curvilinearEquivalenceLabel_.get ();
      }

      void SweepAuxiliary::
      curvilinearEquivalenceLabel (const CurvilinearEquivalenceLabelType& x)
      {
        this->curvilinearEquivalenceLabel_.set (x);
      }

      void SweepAuxiliary::
      curvilinearEquivalenceLabel (::std::unique_ptr< CurvilinearEquivalenceLabelType > x)
      {
        this->curvilinearEquivalenceLabel_.set (std::move (x));
      }

      const SweepAuxiliary::ContactTypeLabelType& SweepAuxiliary::
      contactTypeLabel () const
      {
        return this->contactTypeLabel_.get ();
      }

      SweepAuxiliary::ContactTypeLabelType& SweepAuxiliary::
      contactTypeLabel ()
      {
        return this->contactTypeLabel_.get ();
      }

      void SweepAuxiliary::
      contactTypeLabel (const ContactTypeLabelType& x)
      {
        this->contactTypeLabel_.set (x);
      }

      void SweepAuxiliary::
      contactTypeLabel (::std::unique_ptr< ContactTypeLabelType > x)
      {
        this->contactTypeLabel_.set (std::move (x));
      }


      // SweepBinormal
      // 

      const SweepBinormal::PicksSequence& SweepBinormal::
      picks () const
      {
        return this->picks_;
      }

      SweepBinormal::PicksSequence& SweepBinormal::
      picks ()
      {
        return this->picks_;
      }

      void SweepBinormal::
      picks (const PicksSequence& s)
      {
        this->picks_ = s;
      }

      const SweepBinormal::BinormalType& SweepBinormal::
      binormal () const
      {
        return this->binormal_.get ();
      }

      SweepBinormal::BinormalType& SweepBinormal::
      binormal ()
      {
        return this->binormal_.get ();
      }

      void SweepBinormal::
      binormal (const BinormalType& x)
      {
        this->binormal_.set (x);
      }

      void SweepBinormal::
      binormal (::std::unique_ptr< BinormalType > x)
      {
        this->binormal_.set (std::move (x));
      }

      const SweepBinormal::BinormalLabelType& SweepBinormal::
      binormalLabel () const
      {
        return this->binormalLabel_.get ();
      }

      SweepBinormal::BinormalLabelType& SweepBinormal::
      binormalLabel ()
      {
        return this->binormalLabel_.get ();
      }

      void SweepBinormal::
      binormalLabel (const BinormalLabelType& x)
      {
        this->binormalLabel_.set (x);
      }

      void SweepBinormal::
      binormalLabel (::std::unique_ptr< BinormalLabelType > x)
      {
        this->binormalLabel_.set (std::move (x));
      }


      // Instance
      // 

      const Instance::KeyType& Instance::
      key () const
      {
        return this->key_.get ();
      }

      Instance::KeyType& Instance::
      key ()
      {
        return this->key_.get ();
      }

      void Instance::
      key (const KeyType& x)
      {
        this->key_.set (x);
      }

      void Instance::
      key (::std::unique_ptr< KeyType > x)
      {
        this->key_.set (std::move (x));
      }

      const Instance::ValuesSequence& Instance::
      values () const
      {
        return this->values_;
      }

      Instance::ValuesSequence& Instance::
      values ()
      {
        return this->values_;
      }

      void Instance::
      values (const ValuesSequence& s)
      {
        this->values_ = s;
      }


      // Sweep
      // 

      const Sweep::BaseType& Sweep::
      base () const
      {
        return this->base_.get ();
      }

      Sweep::BaseType& Sweep::
      base ()
      {
        return this->base_.get ();
      }

      void Sweep::
      base (const BaseType& x)
      {
        this->base_.set (x);
      }

      void Sweep::
      base (::std::unique_ptr< BaseType > x)
      {
        this->base_.set (std::move (x));
      }

      const Sweep::SeerShapeType& Sweep::
      seerShape () const
      {
        return this->seerShape_.get ();
      }

      Sweep::SeerShapeType& Sweep::
      seerShape ()
      {
        return this->seerShape_.get ();
      }

      void Sweep::
      seerShape (const SeerShapeType& x)
      {
        this->seerShape_.set (x);
      }

      void Sweep::
      seerShape (::std::unique_ptr< SeerShapeType > x)
      {
        this->seerShape_.set (std::move (x));
      }

      const Sweep::LawFunctionType& Sweep::
      lawFunction () const
      {
        return this->lawFunction_.get ();
      }

      Sweep::LawFunctionType& Sweep::
      lawFunction ()
      {
        return this->lawFunction_.get ();
      }

      void Sweep::
      lawFunction (const LawFunctionType& x)
      {
        this->lawFunction_.set (x);
      }

      void Sweep::
      lawFunction (::std::unique_ptr< LawFunctionType > x)
      {
        this->lawFunction_.set (std::move (x));
      }

      const Sweep::TrihedronType& Sweep::
      trihedron () const
      {
        return this->trihedron_.get ();
      }

      Sweep::TrihedronType& Sweep::
      trihedron ()
      {
        return this->trihedron_.get ();
      }

      void Sweep::
      trihedron (const TrihedronType& x)
      {
        this->trihedron_.set (x);
      }

      void Sweep::
      trihedron (::std::unique_ptr< TrihedronType > x)
      {
        this->trihedron_.set (std::move (x));
      }

      const Sweep::TransitionType& Sweep::
      transition () const
      {
        return this->transition_.get ();
      }

      Sweep::TransitionType& Sweep::
      transition ()
      {
        return this->transition_.get ();
      }

      void Sweep::
      transition (const TransitionType& x)
      {
        this->transition_.set (x);
      }

      void Sweep::
      transition (::std::unique_ptr< TransitionType > x)
      {
        this->transition_.set (std::move (x));
      }

      const Sweep::ForceC1Type& Sweep::
      forceC1 () const
      {
        return this->forceC1_.get ();
      }

      Sweep::ForceC1Type& Sweep::
      forceC1 ()
      {
        return this->forceC1_.get ();
      }

      void Sweep::
      forceC1 (const ForceC1Type& x)
      {
        this->forceC1_.set (x);
      }

      void Sweep::
      forceC1 (::std::unique_ptr< ForceC1Type > x)
      {
        this->forceC1_.set (std::move (x));
      }

      const Sweep::SolidType& Sweep::
      solid () const
      {
        return this->solid_.get ();
      }

      Sweep::SolidType& Sweep::
      solid ()
      {
        return this->solid_.get ();
      }

      void Sweep::
      solid (const SolidType& x)
      {
        this->solid_.set (x);
      }

      void Sweep::
      solid (::std::unique_ptr< SolidType > x)
      {
        this->solid_.set (std::move (x));
      }

      const Sweep::UseLawType& Sweep::
      useLaw () const
      {
        return this->useLaw_.get ();
      }

      Sweep::UseLawType& Sweep::
      useLaw ()
      {
        return this->useLaw_.get ();
      }

      void Sweep::
      useLaw (const UseLawType& x)
      {
        this->useLaw_.set (x);
      }

      void Sweep::
      useLaw (::std::unique_ptr< UseLawType > x)
      {
        this->useLaw_.set (std::move (x));
      }

      const Sweep::SpineType& Sweep::
      spine () const
      {
        return this->spine_.get ();
      }

      Sweep::SpineType& Sweep::
      spine ()
      {
        return this->spine_.get ();
      }

      void Sweep::
      spine (const SpineType& x)
      {
        this->spine_.set (x);
      }

      void Sweep::
      spine (::std::unique_ptr< SpineType > x)
      {
        this->spine_.set (std::move (x));
      }

      const Sweep::ProfilesSequence& Sweep::
      profiles () const
      {
        return this->profiles_;
      }

      Sweep::ProfilesSequence& Sweep::
      profiles ()
      {
        return this->profiles_;
      }

      void Sweep::
      profiles (const ProfilesSequence& s)
      {
        this->profiles_ = s;
      }

      const Sweep::AuxiliaryType& Sweep::
      auxiliary () const
      {
        return this->auxiliary_.get ();
      }

      Sweep::AuxiliaryType& Sweep::
      auxiliary ()
      {
        return this->auxiliary_.get ();
      }

      void Sweep::
      auxiliary (const AuxiliaryType& x)
      {
        this->auxiliary_.set (x);
      }

      void Sweep::
      auxiliary (::std::unique_ptr< AuxiliaryType > x)
      {
        this->auxiliary_.set (std::move (x));
      }

      const Sweep::SupportType& Sweep::
      support () const
      {
        return this->support_.get ();
      }

      Sweep::SupportType& Sweep::
      support ()
      {
        return this->support_.get ();
      }

      void Sweep::
      support (const SupportType& x)
      {
        this->support_.set (x);
      }

      void Sweep::
      support (::std::unique_ptr< SupportType > x)
      {
        this->support_.set (std::move (x));
      }

      const Sweep::BinormalType& Sweep::
      binormal () const
      {
        return this->binormal_.get ();
      }

      Sweep::BinormalType& Sweep::
      binormal ()
      {
        return this->binormal_.get ();
      }

      void Sweep::
      binormal (const BinormalType& x)
      {
        this->binormal_.set (x);
      }

      void Sweep::
      binormal (::std::unique_ptr< BinormalType > x)
      {
        this->binormal_.set (std::move (x));
      }

      const Sweep::TrihedronLabelType& Sweep::
      trihedronLabel () const
      {
        return this->trihedronLabel_.get ();
      }

      Sweep::TrihedronLabelType& Sweep::
      trihedronLabel ()
      {
        return this->trihedronLabel_.get ();
      }

      void Sweep::
      trihedronLabel (const TrihedronLabelType& x)
      {
        this->trihedronLabel_.set (x);
      }

      void Sweep::
      trihedronLabel (::std::unique_ptr< TrihedronLabelType > x)
      {
        this->trihedronLabel_.set (std::move (x));
      }

      const Sweep::TransitionLabelType& Sweep::
      transitionLabel () const
      {
        return this->transitionLabel_.get ();
      }

      Sweep::TransitionLabelType& Sweep::
      transitionLabel ()
      {
        return this->transitionLabel_.get ();
      }

      void Sweep::
      transitionLabel (const TransitionLabelType& x)
      {
        this->transitionLabel_.set (x);
      }

      void Sweep::
      transitionLabel (::std::unique_ptr< TransitionLabelType > x)
      {
        this->transitionLabel_.set (std::move (x));
      }

      const Sweep::ForceC1LabelType& Sweep::
      forceC1Label () const
      {
        return this->forceC1Label_.get ();
      }

      Sweep::ForceC1LabelType& Sweep::
      forceC1Label ()
      {
        return this->forceC1Label_.get ();
      }

      void Sweep::
      forceC1Label (const ForceC1LabelType& x)
      {
        this->forceC1Label_.set (x);
      }

      void Sweep::
      forceC1Label (::std::unique_ptr< ForceC1LabelType > x)
      {
        this->forceC1Label_.set (std::move (x));
      }

      const Sweep::SolidLabelType& Sweep::
      solidLabel () const
      {
        return this->solidLabel_.get ();
      }

      Sweep::SolidLabelType& Sweep::
      solidLabel ()
      {
        return this->solidLabel_.get ();
      }

      void Sweep::
      solidLabel (const SolidLabelType& x)
      {
        this->solidLabel_.set (x);
      }

      void Sweep::
      solidLabel (::std::unique_ptr< SolidLabelType > x)
      {
        this->solidLabel_.set (std::move (x));
      }

      const Sweep::UseLawLabelType& Sweep::
      useLawLabel () const
      {
        return this->useLawLabel_.get ();
      }

      Sweep::UseLawLabelType& Sweep::
      useLawLabel ()
      {
        return this->useLawLabel_.get ();
      }

      void Sweep::
      useLawLabel (const UseLawLabelType& x)
      {
        this->useLawLabel_.set (x);
      }

      void Sweep::
      useLawLabel (::std::unique_ptr< UseLawLabelType > x)
      {
        this->useLawLabel_.set (std::move (x));
      }

      const Sweep::LawVizMatrixType& Sweep::
      lawVizMatrix () const
      {
        return this->lawVizMatrix_.get ();
      }

      Sweep::LawVizMatrixType& Sweep::
      lawVizMatrix ()
      {
        return this->lawVizMatrix_.get ();
      }

      void Sweep::
      lawVizMatrix (const LawVizMatrixType& x)
      {
        this->lawVizMatrix_.set (x);
      }

      void Sweep::
      lawVizMatrix (::std::unique_ptr< LawVizMatrixType > x)
      {
        this->lawVizMatrix_.set (std::move (x));
      }

      const Sweep::LawVizScaleType& Sweep::
      lawVizScale () const
      {
        return this->lawVizScale_.get ();
      }

      Sweep::LawVizScaleType& Sweep::
      lawVizScale ()
      {
        return this->lawVizScale_.get ();
      }

      void Sweep::
      lawVizScale (const LawVizScaleType& x)
      {
        this->lawVizScale_.set (x);
      }

      const Sweep::SolidIdType& Sweep::
      solidId () const
      {
        return this->solidId_.get ();
      }

      Sweep::SolidIdType& Sweep::
      solidId ()
      {
        return this->solidId_.get ();
      }

      void Sweep::
      solidId (const SolidIdType& x)
      {
        this->solidId_.set (x);
      }

      void Sweep::
      solidId (::std::unique_ptr< SolidIdType > x)
      {
        this->solidId_.set (std::move (x));
      }

      const Sweep::ShellIdType& Sweep::
      shellId () const
      {
        return this->shellId_.get ();
      }

      Sweep::ShellIdType& Sweep::
      shellId ()
      {
        return this->shellId_.get ();
      }

      void Sweep::
      shellId (const ShellIdType& x)
      {
        this->shellId_.set (x);
      }

      void Sweep::
      shellId (::std::unique_ptr< ShellIdType > x)
      {
        this->shellId_.set (std::move (x));
      }

      const Sweep::FirstFaceIdType& Sweep::
      firstFaceId () const
      {
        return this->firstFaceId_.get ();
      }

      Sweep::FirstFaceIdType& Sweep::
      firstFaceId ()
      {
        return this->firstFaceId_.get ();
      }

      void Sweep::
      firstFaceId (const FirstFaceIdType& x)
      {
        this->firstFaceId_.set (x);
      }

      void Sweep::
      firstFaceId (::std::unique_ptr< FirstFaceIdType > x)
      {
        this->firstFaceId_.set (std::move (x));
      }

      const Sweep::LastFaceIdType& Sweep::
      lastFaceId () const
      {
        return this->lastFaceId_.get ();
      }

      Sweep::LastFaceIdType& Sweep::
      lastFaceId ()
      {
        return this->lastFaceId_.get ();
      }

      void Sweep::
      lastFaceId (const LastFaceIdType& x)
      {
        this->lastFaceId_.set (x);
      }

      void Sweep::
      lastFaceId (::std::unique_ptr< LastFaceIdType > x)
      {
        this->lastFaceId_.set (std::move (x));
      }

      const Sweep::OuterWireMapSequence& Sweep::
      outerWireMap () const
      {
        return this->outerWireMap_;
      }

      Sweep::OuterWireMapSequence& Sweep::
      outerWireMap ()
      {
        return this->outerWireMap_;
      }

      void Sweep::
      outerWireMap (const OuterWireMapSequence& s)
      {
        this->outerWireMap_ = s;
      }

      const Sweep::InstanceMapSequence& Sweep::
      instanceMap () const
      {
        return this->instanceMap_;
      }

      Sweep::InstanceMapSequence& Sweep::
      instanceMap ()
      {
        return this->instanceMap_;
      }

      void Sweep::
      instanceMap (const InstanceMapSequence& s)
      {
        this->instanceMap_ = s;
      }

      const Sweep::FirstShapeMapSequence& Sweep::
      firstShapeMap () const
      {
        return this->firstShapeMap_;
      }

      Sweep::FirstShapeMapSequence& Sweep::
      firstShapeMap ()
      {
        return this->firstShapeMap_;
      }

      void Sweep::
      firstShapeMap (const FirstShapeMapSequence& s)
      {
        this->firstShapeMap_ = s;
      }

      const Sweep::LastShapeMapSequence& Sweep::
      lastShapeMap () const
      {
        return this->lastShapeMap_;
      }

      Sweep::LastShapeMapSequence& Sweep::
      lastShapeMap ()
      {
        return this->lastShapeMap_;
      }

      void Sweep::
      lastShapeMap (const LastShapeMapSequence& s)
      {
        this->lastShapeMap_ = s;
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace swps
    {
      // SweepProfile
      //

      SweepProfile::
      SweepProfile (const PickType& pick,
                    const ContactType& contact,
                    const CorrectionType& correction,
                    const ContactLabelType& contactLabel,
                    const CorrectionLabelType& correctionLabel)
      : ::xml_schema::Type (),
        pick_ (pick, this),
        contact_ (contact, this),
        correction_ (correction, this),
        contactLabel_ (contactLabel, this),
        correctionLabel_ (correctionLabel, this)
      {
      }

      SweepProfile::
      SweepProfile (::std::unique_ptr< PickType > pick,
                    ::std::unique_ptr< ContactType > contact,
                    ::std::unique_ptr< CorrectionType > correction,
                    ::std::unique_ptr< ContactLabelType > contactLabel,
                    ::std::unique_ptr< CorrectionLabelType > correctionLabel)
      : ::xml_schema::Type (),
        pick_ (std::move (pick), this),
        contact_ (std::move (contact), this),
        correction_ (std::move (correction), this),
        contactLabel_ (std::move (contactLabel), this),
        correctionLabel_ (std::move (correctionLabel), this)
      {
      }

      SweepProfile::
      SweepProfile (const SweepProfile& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        pick_ (x.pick_, f, this),
        contact_ (x.contact_, f, this),
        correction_ (x.correction_, f, this),
        contactLabel_ (x.contactLabel_, f, this),
        correctionLabel_ (x.correctionLabel_, f, this)
      {
      }

      SweepProfile::
      SweepProfile (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        pick_ (this),
        contact_ (this),
        correction_ (this),
        contactLabel_ (this),
        correctionLabel_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void SweepProfile::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // pick
          //
          if (n.name () == "pick" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< PickType > r (
              PickTraits::create (i, f, this));

            if (!pick_.present ())
            {
              this->pick_.set (::std::move (r));
              continue;
            }
          }

          // contact
          //
          if (n.name () == "contact" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ContactType > r (
              ContactTraits::create (i, f, this));

            if (!contact_.present ())
            {
              this->contact_.set (::std::move (r));
              continue;
            }
          }

          // correction
          //
          if (n.name () == "correction" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< CorrectionType > r (
              CorrectionTraits::create (i, f, this));

            if (!correction_.present ())
            {
              this->correction_.set (::std::move (r));
              continue;
            }
          }

          // contactLabel
          //
          if (n.name () == "contactLabel" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ContactLabelType > r (
              ContactLabelTraits::create (i, f, this));

            if (!contactLabel_.present ())
            {
              this->contactLabel_.set (::std::move (r));
              continue;
            }
          }

          // correctionLabel
          //
          if (n.name () == "correctionLabel" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< CorrectionLabelType > r (
              CorrectionLabelTraits::create (i, f, this));

            if (!correctionLabel_.present ())
            {
              this->correctionLabel_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!pick_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "pick",
            "");
        }

        if (!contact_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "contact",
            "");
        }

        if (!correction_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "correction",
            "");
        }

        if (!contactLabel_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "contactLabel",
            "");
        }

        if (!correctionLabel_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "correctionLabel",
            "");
        }
      }

      SweepProfile* SweepProfile::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class SweepProfile (*this, f, c);
      }

      SweepProfile& SweepProfile::
      operator= (const SweepProfile& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->pick_ = x.pick_;
          this->contact_ = x.contact_;
          this->correction_ = x.correction_;
          this->contactLabel_ = x.contactLabel_;
          this->correctionLabel_ = x.correctionLabel_;
        }

        return *this;
      }

      SweepProfile::
      ~SweepProfile ()
      {
      }

      // SweepAuxiliary
      //

      SweepAuxiliary::
      SweepAuxiliary (const PickType& pick,
                      const CurvilinearEquivalenceType& curvilinearEquivalence,
                      const ContactTypeType& contactType,
                      const CurvilinearEquivalenceLabelType& curvilinearEquivalenceLabel,
                      const ContactTypeLabelType& contactTypeLabel)
      : ::xml_schema::Type (),
        pick_ (pick, this),
        curvilinearEquivalence_ (curvilinearEquivalence, this),
        contactType_ (contactType, this),
        curvilinearEquivalenceLabel_ (curvilinearEquivalenceLabel, this),
        contactTypeLabel_ (contactTypeLabel, this)
      {
      }

      SweepAuxiliary::
      SweepAuxiliary (::std::unique_ptr< PickType > pick,
                      ::std::unique_ptr< CurvilinearEquivalenceType > curvilinearEquivalence,
                      ::std::unique_ptr< ContactTypeType > contactType,
                      ::std::unique_ptr< CurvilinearEquivalenceLabelType > curvilinearEquivalenceLabel,
                      ::std::unique_ptr< ContactTypeLabelType > contactTypeLabel)
      : ::xml_schema::Type (),
        pick_ (std::move (pick), this),
        curvilinearEquivalence_ (std::move (curvilinearEquivalence), this),
        contactType_ (std::move (contactType), this),
        curvilinearEquivalenceLabel_ (std::move (curvilinearEquivalenceLabel), this),
        contactTypeLabel_ (std::move (contactTypeLabel), this)
      {
      }

      SweepAuxiliary::
      SweepAuxiliary (const SweepAuxiliary& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        pick_ (x.pick_, f, this),
        curvilinearEquivalence_ (x.curvilinearEquivalence_, f, this),
        contactType_ (x.contactType_, f, this),
        curvilinearEquivalenceLabel_ (x.curvilinearEquivalenceLabel_, f, this),
        contactTypeLabel_ (x.contactTypeLabel_, f, this)
      {
      }

      SweepAuxiliary::
      SweepAuxiliary (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        pick_ (this),
        curvilinearEquivalence_ (this),
        contactType_ (this),
        curvilinearEquivalenceLabel_ (this),
        contactTypeLabel_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void SweepAuxiliary::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // pick
          //
          if (n.name () == "pick" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< PickType > r (
              PickTraits::create (i, f, this));

            if (!pick_.present ())
            {
              this->pick_.set (::std::move (r));
              continue;
            }
          }

          // curvilinearEquivalence
          //
          if (n.name () == "curvilinearEquivalence" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< CurvilinearEquivalenceType > r (
              CurvilinearEquivalenceTraits::create (i, f, this));

            if (!curvilinearEquivalence_.present ())
            {
              this->curvilinearEquivalence_.set (::std::move (r));
              continue;
            }
          }

          // contactType
          //
          if (n.name () == "contactType" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ContactTypeType > r (
              ContactTypeTraits::create (i, f, this));

            if (!contactType_.present ())
            {
              this->contactType_.set (::std::move (r));
              continue;
            }
          }

          // curvilinearEquivalenceLabel
          //
          if (n.name () == "curvilinearEquivalenceLabel" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< CurvilinearEquivalenceLabelType > r (
              CurvilinearEquivalenceLabelTraits::create (i, f, this));

            if (!curvilinearEquivalenceLabel_.present ())
            {
              this->curvilinearEquivalenceLabel_.set (::std::move (r));
              continue;
            }
          }

          // contactTypeLabel
          //
          if (n.name () == "contactTypeLabel" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ContactTypeLabelType > r (
              ContactTypeLabelTraits::create (i, f, this));

            if (!contactTypeLabel_.present ())
            {
              this->contactTypeLabel_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!pick_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "pick",
            "");
        }

        if (!curvilinearEquivalence_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "curvilinearEquivalence",
            "");
        }

        if (!contactType_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "contactType",
            "");
        }

        if (!curvilinearEquivalenceLabel_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "curvilinearEquivalenceLabel",
            "");
        }

        if (!contactTypeLabel_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "contactTypeLabel",
            "");
        }
      }

      SweepAuxiliary* SweepAuxiliary::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class SweepAuxiliary (*this, f, c);
      }

      SweepAuxiliary& SweepAuxiliary::
      operator= (const SweepAuxiliary& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->pick_ = x.pick_;
          this->curvilinearEquivalence_ = x.curvilinearEquivalence_;
          this->contactType_ = x.contactType_;
          this->curvilinearEquivalenceLabel_ = x.curvilinearEquivalenceLabel_;
          this->contactTypeLabel_ = x.contactTypeLabel_;
        }

        return *this;
      }

      SweepAuxiliary::
      ~SweepAuxiliary ()
      {
      }

      // SweepBinormal
      //

      SweepBinormal::
      SweepBinormal (const BinormalType& binormal,
                     const BinormalLabelType& binormalLabel)
      : ::xml_schema::Type (),
        picks_ (this),
        binormal_ (binormal, this),
        binormalLabel_ (binormalLabel, this)
      {
      }

      SweepBinormal::
      SweepBinormal (::std::unique_ptr< BinormalType > binormal,
                     ::std::unique_ptr< BinormalLabelType > binormalLabel)
      : ::xml_schema::Type (),
        picks_ (this),
        binormal_ (std::move (binormal), this),
        binormalLabel_ (std::move (binormalLabel), this)
      {
      }

      SweepBinormal::
      SweepBinormal (const SweepBinormal& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        picks_ (x.picks_, f, this),
        binormal_ (x.binormal_, f, this),
        binormalLabel_ (x.binormalLabel_, f, this)
      {
      }

      SweepBinormal::
      SweepBinormal (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        picks_ (this),
        binormal_ (this),
        binormalLabel_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void SweepBinormal::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // picks
          //
          if (n.name () == "picks" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< PicksType > r (
              PicksTraits::create (i, f, this));

            this->picks_.push_back (::std::move (r));
            continue;
          }

          // binormal
          //
          if (n.name () == "binormal" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< BinormalType > r (
              BinormalTraits::create (i, f, this));

            if (!binormal_.present ())
            {
              this->binormal_.set (::std::move (r));
              continue;
            }
          }

          // binormalLabel
          //
          if (n.name () == "binormalLabel" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< BinormalLabelType > r (
              BinormalLabelTraits::create (i, f, this));

            if (!binormalLabel_.present ())
            {
              this->binormalLabel_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!binormal_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "binormal",
            "");
        }

        if (!binormalLabel_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "binormalLabel",
            "");
        }
      }

      SweepBinormal* SweepBinormal::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class SweepBinormal (*this, f, c);
      }

      SweepBinormal& SweepBinormal::
      operator= (const SweepBinormal& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->picks_ = x.picks_;
          this->binormal_ = x.binormal_;
          this->binormalLabel_ = x.binormalLabel_;
        }

        return *this;
      }

      SweepBinormal::
      ~SweepBinormal ()
      {
      }

      // Instance
      //

      Instance::
      Instance (const KeyType& key)
      : ::xml_schema::Type (),
        key_ (key, this),
        values_ (this)
      {
      }

      Instance::
      Instance (const Instance& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        key_ (x.key_, f, this),
        values_ (x.values_, f, this)
      {
      }

      Instance::
      Instance (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        key_ (this),
        values_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Instance::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // key
          //
          if (n.name () == "key" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< KeyType > r (
              KeyTraits::create (i, f, this));

            if (!key_.present ())
            {
              this->key_.set (::std::move (r));
              continue;
            }
          }

          // values
          //
          if (n.name () == "values" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ValuesType > r (
              ValuesTraits::create (i, f, this));

            this->values_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        if (!key_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "key",
            "");
        }
      }

      Instance* Instance::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Instance (*this, f, c);
      }

      Instance& Instance::
      operator= (const Instance& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->key_ = x.key_;
          this->values_ = x.values_;
        }

        return *this;
      }

      Instance::
      ~Instance ()
      {
      }

      // Sweep
      //

      Sweep::
      Sweep (const BaseType& base,
             const SeerShapeType& seerShape,
             const LawFunctionType& lawFunction,
             const TrihedronType& trihedron,
             const TransitionType& transition,
             const ForceC1Type& forceC1,
             const SolidType& solid,
             const UseLawType& useLaw,
             const SpineType& spine,
             const AuxiliaryType& auxiliary,
             const SupportType& support,
             const BinormalType& binormal,
             const TrihedronLabelType& trihedronLabel,
             const TransitionLabelType& transitionLabel,
             const ForceC1LabelType& forceC1Label,
             const SolidLabelType& solidLabel,
             const UseLawLabelType& useLawLabel,
             const LawVizMatrixType& lawVizMatrix,
             const LawVizScaleType& lawVizScale,
             const SolidIdType& solidId,
             const ShellIdType& shellId,
             const FirstFaceIdType& firstFaceId,
             const LastFaceIdType& lastFaceId)
      : ::xml_schema::Type (),
        base_ (base, this),
        seerShape_ (seerShape, this),
        lawFunction_ (lawFunction, this),
        trihedron_ (trihedron, this),
        transition_ (transition, this),
        forceC1_ (forceC1, this),
        solid_ (solid, this),
        useLaw_ (useLaw, this),
        spine_ (spine, this),
        profiles_ (this),
        auxiliary_ (auxiliary, this),
        support_ (support, this),
        binormal_ (binormal, this),
        trihedronLabel_ (trihedronLabel, this),
        transitionLabel_ (transitionLabel, this),
        forceC1Label_ (forceC1Label, this),
        solidLabel_ (solidLabel, this),
        useLawLabel_ (useLawLabel, this),
        lawVizMatrix_ (lawVizMatrix, this),
        lawVizScale_ (lawVizScale, this),
        solidId_ (solidId, this),
        shellId_ (shellId, this),
        firstFaceId_ (firstFaceId, this),
        lastFaceId_ (lastFaceId, this),
        outerWireMap_ (this),
        instanceMap_ (this),
        firstShapeMap_ (this),
        lastShapeMap_ (this)
      {
      }

      Sweep::
      Sweep (::std::unique_ptr< BaseType > base,
             ::std::unique_ptr< SeerShapeType > seerShape,
             ::std::unique_ptr< LawFunctionType > lawFunction,
             ::std::unique_ptr< TrihedronType > trihedron,
             ::std::unique_ptr< TransitionType > transition,
             ::std::unique_ptr< ForceC1Type > forceC1,
             ::std::unique_ptr< SolidType > solid,
             ::std::unique_ptr< UseLawType > useLaw,
             ::std::unique_ptr< SpineType > spine,
             ::std::unique_ptr< AuxiliaryType > auxiliary,
             ::std::unique_ptr< SupportType > support,
             ::std::unique_ptr< BinormalType > binormal,
             ::std::unique_ptr< TrihedronLabelType > trihedronLabel,
             ::std::unique_ptr< TransitionLabelType > transitionLabel,
             ::std::unique_ptr< ForceC1LabelType > forceC1Label,
             ::std::unique_ptr< SolidLabelType > solidLabel,
             ::std::unique_ptr< UseLawLabelType > useLawLabel,
             ::std::unique_ptr< LawVizMatrixType > lawVizMatrix,
             const LawVizScaleType& lawVizScale,
             const SolidIdType& solidId,
             const ShellIdType& shellId,
             const FirstFaceIdType& firstFaceId,
             const LastFaceIdType& lastFaceId)
      : ::xml_schema::Type (),
        base_ (std::move (base), this),
        seerShape_ (std::move (seerShape), this),
        lawFunction_ (std::move (lawFunction), this),
        trihedron_ (std::move (trihedron), this),
        transition_ (std::move (transition), this),
        forceC1_ (std::move (forceC1), this),
        solid_ (std::move (solid), this),
        useLaw_ (std::move (useLaw), this),
        spine_ (std::move (spine), this),
        profiles_ (this),
        auxiliary_ (std::move (auxiliary), this),
        support_ (std::move (support), this),
        binormal_ (std::move (binormal), this),
        trihedronLabel_ (std::move (trihedronLabel), this),
        transitionLabel_ (std::move (transitionLabel), this),
        forceC1Label_ (std::move (forceC1Label), this),
        solidLabel_ (std::move (solidLabel), this),
        useLawLabel_ (std::move (useLawLabel), this),
        lawVizMatrix_ (std::move (lawVizMatrix), this),
        lawVizScale_ (lawVizScale, this),
        solidId_ (solidId, this),
        shellId_ (shellId, this),
        firstFaceId_ (firstFaceId, this),
        lastFaceId_ (lastFaceId, this),
        outerWireMap_ (this),
        instanceMap_ (this),
        firstShapeMap_ (this),
        lastShapeMap_ (this)
      {
      }

      Sweep::
      Sweep (const Sweep& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        base_ (x.base_, f, this),
        seerShape_ (x.seerShape_, f, this),
        lawFunction_ (x.lawFunction_, f, this),
        trihedron_ (x.trihedron_, f, this),
        transition_ (x.transition_, f, this),
        forceC1_ (x.forceC1_, f, this),
        solid_ (x.solid_, f, this),
        useLaw_ (x.useLaw_, f, this),
        spine_ (x.spine_, f, this),
        profiles_ (x.profiles_, f, this),
        auxiliary_ (x.auxiliary_, f, this),
        support_ (x.support_, f, this),
        binormal_ (x.binormal_, f, this),
        trihedronLabel_ (x.trihedronLabel_, f, this),
        transitionLabel_ (x.transitionLabel_, f, this),
        forceC1Label_ (x.forceC1Label_, f, this),
        solidLabel_ (x.solidLabel_, f, this),
        useLawLabel_ (x.useLawLabel_, f, this),
        lawVizMatrix_ (x.lawVizMatrix_, f, this),
        lawVizScale_ (x.lawVizScale_, f, this),
        solidId_ (x.solidId_, f, this),
        shellId_ (x.shellId_, f, this),
        firstFaceId_ (x.firstFaceId_, f, this),
        lastFaceId_ (x.lastFaceId_, f, this),
        outerWireMap_ (x.outerWireMap_, f, this),
        instanceMap_ (x.instanceMap_, f, this),
        firstShapeMap_ (x.firstShapeMap_, f, this),
        lastShapeMap_ (x.lastShapeMap_, f, this)
      {
      }

      Sweep::
      Sweep (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        base_ (this),
        seerShape_ (this),
        lawFunction_ (this),
        trihedron_ (this),
        transition_ (this),
        forceC1_ (this),
        solid_ (this),
        useLaw_ (this),
        spine_ (this),
        profiles_ (this),
        auxiliary_ (this),
        support_ (this),
        binormal_ (this),
        trihedronLabel_ (this),
        transitionLabel_ (this),
        forceC1Label_ (this),
        solidLabel_ (this),
        useLawLabel_ (this),
        lawVizMatrix_ (this),
        lawVizScale_ (this),
        solidId_ (this),
        shellId_ (this),
        firstFaceId_ (this),
        lastFaceId_ (this),
        outerWireMap_ (this),
        instanceMap_ (this),
        firstShapeMap_ (this),
        lastShapeMap_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Sweep::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // base
          //
          if (n.name () == "base" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< BaseType > r (
              BaseTraits::create (i, f, this));

            if (!base_.present ())
            {
              this->base_.set (::std::move (r));
              continue;
            }
          }

          // seerShape
          //
          if (n.name () == "seerShape" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< SeerShapeType > r (
              SeerShapeTraits::create (i, f, this));

            if (!seerShape_.present ())
            {
              this->seerShape_.set (::std::move (r));
              continue;
            }
          }

          // lawFunction
          //
          if (n.name () == "lawFunction" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< LawFunctionType > r (
              LawFunctionTraits::create (i, f, this));

            if (!lawFunction_.present ())
            {
              this->lawFunction_.set (::std::move (r));
              continue;
            }
          }

          // trihedron
          //
          if (n.name () == "trihedron" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< TrihedronType > r (
              TrihedronTraits::create (i, f, this));

            if (!trihedron_.present ())
            {
              this->trihedron_.set (::std::move (r));
              continue;
            }
          }

          // transition
          //
          if (n.name () == "transition" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< TransitionType > r (
              TransitionTraits::create (i, f, this));

            if (!transition_.present ())
            {
              this->transition_.set (::std::move (r));
              continue;
            }
          }

          // forceC1
          //
          if (n.name () == "forceC1" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ForceC1Type > r (
              ForceC1Traits::create (i, f, this));

            if (!forceC1_.present ())
            {
              this->forceC1_.set (::std::move (r));
              continue;
            }
          }

          // solid
          //
          if (n.name () == "solid" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< SolidType > r (
              SolidTraits::create (i, f, this));

            if (!solid_.present ())
            {
              this->solid_.set (::std::move (r));
              continue;
            }
          }

          // useLaw
          //
          if (n.name () == "useLaw" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< UseLawType > r (
              UseLawTraits::create (i, f, this));

            if (!useLaw_.present ())
            {
              this->useLaw_.set (::std::move (r));
              continue;
            }
          }

          // spine
          //
          if (n.name () == "spine" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< SpineType > r (
              SpineTraits::create (i, f, this));

            if (!spine_.present ())
            {
              this->spine_.set (::std::move (r));
              continue;
            }
          }

          // profiles
          //
          if (n.name () == "profiles" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ProfilesType > r (
              ProfilesTraits::create (i, f, this));

            this->profiles_.push_back (::std::move (r));
            continue;
          }

          // auxiliary
          //
          if (n.name () == "auxiliary" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< AuxiliaryType > r (
              AuxiliaryTraits::create (i, f, this));

            if (!auxiliary_.present ())
            {
              this->auxiliary_.set (::std::move (r));
              continue;
            }
          }

          // support
          //
          if (n.name () == "support" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< SupportType > r (
              SupportTraits::create (i, f, this));

            if (!support_.present ())
            {
              this->support_.set (::std::move (r));
              continue;
            }
          }

          // binormal
          //
          if (n.name () == "binormal" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< BinormalType > r (
              BinormalTraits::create (i, f, this));

            if (!binormal_.present ())
            {
              this->binormal_.set (::std::move (r));
              continue;
            }
          }

          // trihedronLabel
          //
          if (n.name () == "trihedronLabel" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< TrihedronLabelType > r (
              TrihedronLabelTraits::create (i, f, this));

            if (!trihedronLabel_.present ())
            {
              this->trihedronLabel_.set (::std::move (r));
              continue;
            }
          }

          // transitionLabel
          //
          if (n.name () == "transitionLabel" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< TransitionLabelType > r (
              TransitionLabelTraits::create (i, f, this));

            if (!transitionLabel_.present ())
            {
              this->transitionLabel_.set (::std::move (r));
              continue;
            }
          }

          // forceC1Label
          //
          if (n.name () == "forceC1Label" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ForceC1LabelType > r (
              ForceC1LabelTraits::create (i, f, this));

            if (!forceC1Label_.present ())
            {
              this->forceC1Label_.set (::std::move (r));
              continue;
            }
          }

          // solidLabel
          //
          if (n.name () == "solidLabel" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< SolidLabelType > r (
              SolidLabelTraits::create (i, f, this));

            if (!solidLabel_.present ())
            {
              this->solidLabel_.set (::std::move (r));
              continue;
            }
          }

          // useLawLabel
          //
          if (n.name () == "useLawLabel" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< UseLawLabelType > r (
              UseLawLabelTraits::create (i, f, this));

            if (!useLawLabel_.present ())
            {
              this->useLawLabel_.set (::std::move (r));
              continue;
            }
          }

          // lawVizMatrix
          //
          if (n.name () == "lawVizMatrix" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< LawVizMatrixType > r (
              LawVizMatrixTraits::create (i, f, this));

            if (!lawVizMatrix_.present ())
            {
              this->lawVizMatrix_.set (::std::move (r));
              continue;
            }
          }

          // lawVizScale
          //
          if (n.name () == "lawVizScale" && n.namespace_ ().empty ())
          {
            if (!lawVizScale_.present ())
            {
              this->lawVizScale_.set (LawVizScaleTraits::create (i, f, this));
              continue;
            }
          }

          // solidId
          //
          if (n.name () == "solidId" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< SolidIdType > r (
              SolidIdTraits::create (i, f, this));

            if (!solidId_.present ())
            {
              this->solidId_.set (::std::move (r));
              continue;
            }
          }

          // shellId
          //
          if (n.name () == "shellId" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ShellIdType > r (
              ShellIdTraits::create (i, f, this));

            if (!shellId_.present ())
            {
              this->shellId_.set (::std::move (r));
              continue;
            }
          }

          // firstFaceId
          //
          if (n.name () == "firstFaceId" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< FirstFaceIdType > r (
              FirstFaceIdTraits::create (i, f, this));

            if (!firstFaceId_.present ())
            {
              this->firstFaceId_.set (::std::move (r));
              continue;
            }
          }

          // lastFaceId
          //
          if (n.name () == "lastFaceId" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< LastFaceIdType > r (
              LastFaceIdTraits::create (i, f, this));

            if (!lastFaceId_.present ())
            {
              this->lastFaceId_.set (::std::move (r));
              continue;
            }
          }

          // outerWireMap
          //
          if (n.name () == "outerWireMap" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< OuterWireMapType > r (
              OuterWireMapTraits::create (i, f, this));

            this->outerWireMap_.push_back (::std::move (r));
            continue;
          }

          // instanceMap
          //
          if (n.name () == "instanceMap" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< InstanceMapType > r (
              InstanceMapTraits::create (i, f, this));

            this->instanceMap_.push_back (::std::move (r));
            continue;
          }

          // firstShapeMap
          //
          if (n.name () == "firstShapeMap" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< FirstShapeMapType > r (
              FirstShapeMapTraits::create (i, f, this));

            this->firstShapeMap_.push_back (::std::move (r));
            continue;
          }

          // lastShapeMap
          //
          if (n.name () == "lastShapeMap" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< LastShapeMapType > r (
              LastShapeMapTraits::create (i, f, this));

            this->lastShapeMap_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        if (!base_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "base",
            "");
        }

        if (!seerShape_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "seerShape",
            "");
        }

        if (!lawFunction_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "lawFunction",
            "");
        }

        if (!trihedron_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "trihedron",
            "");
        }

        if (!transition_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "transition",
            "");
        }

        if (!forceC1_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "forceC1",
            "");
        }

        if (!solid_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "solid",
            "");
        }

        if (!useLaw_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "useLaw",
            "");
        }

        if (!spine_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "spine",
            "");
        }

        if (!auxiliary_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "auxiliary",
            "");
        }

        if (!support_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "support",
            "");
        }

        if (!binormal_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "binormal",
            "");
        }

        if (!trihedronLabel_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "trihedronLabel",
            "");
        }

        if (!transitionLabel_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "transitionLabel",
            "");
        }

        if (!forceC1Label_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "forceC1Label",
            "");
        }

        if (!solidLabel_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "solidLabel",
            "");
        }

        if (!useLawLabel_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "useLawLabel",
            "");
        }

        if (!lawVizMatrix_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "lawVizMatrix",
            "");
        }

        if (!lawVizScale_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "lawVizScale",
            "");
        }

        if (!solidId_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "solidId",
            "");
        }

        if (!shellId_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "shellId",
            "");
        }

        if (!firstFaceId_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "firstFaceId",
            "");
        }

        if (!lastFaceId_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "lastFaceId",
            "");
        }
      }

      Sweep* Sweep::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Sweep (*this, f, c);
      }

      Sweep& Sweep::
      operator= (const Sweep& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->base_ = x.base_;
          this->seerShape_ = x.seerShape_;
          this->lawFunction_ = x.lawFunction_;
          this->trihedron_ = x.trihedron_;
          this->transition_ = x.transition_;
          this->forceC1_ = x.forceC1_;
          this->solid_ = x.solid_;
          this->useLaw_ = x.useLaw_;
          this->spine_ = x.spine_;
          this->profiles_ = x.profiles_;
          this->auxiliary_ = x.auxiliary_;
          this->support_ = x.support_;
          this->binormal_ = x.binormal_;
          this->trihedronLabel_ = x.trihedronLabel_;
          this->transitionLabel_ = x.transitionLabel_;
          this->forceC1Label_ = x.forceC1Label_;
          this->solidLabel_ = x.solidLabel_;
          this->useLawLabel_ = x.useLawLabel_;
          this->lawVizMatrix_ = x.lawVizMatrix_;
          this->lawVizScale_ = x.lawVizScale_;
          this->solidId_ = x.solidId_;
          this->shellId_ = x.shellId_;
          this->firstFaceId_ = x.firstFaceId_;
          this->lastFaceId_ = x.lastFaceId_;
          this->outerWireMap_ = x.outerWireMap_;
          this->instanceMap_ = x.instanceMap_;
          this->firstShapeMap_ = x.firstShapeMap_;
          this->lastShapeMap_ = x.lastShapeMap_;
        }

        return *this;
      }

      Sweep::
      ~Sweep ()
      {
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace prj
{
  namespace srl
  {
    namespace swps
    {
      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (const ::std::string& u,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::prj::srl::swps::Sweep > (
          ::prj::srl::swps::sweep (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (const ::std::string& u,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::prj::srl::swps::Sweep > (
          ::prj::srl::swps::sweep (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::prj::srl::swps::Sweep > (
          ::prj::srl::swps::sweep (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::std::istream& is,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::prj::srl::swps::sweep (isrc, f, p);
      }

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::std::istream& is,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::prj::srl::swps::sweep (isrc, h, f, p);
      }

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::prj::srl::swps::sweep (isrc, h, f, p);
      }

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::prj::srl::swps::sweep (isrc, f, p);
      }

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::prj::srl::swps::sweep (isrc, h, f, p);
      }

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::prj::srl::swps::sweep (isrc, h, f, p);
      }

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::xercesc::InputSource& i,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::prj::srl::swps::Sweep > (
          ::prj::srl::swps::sweep (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::xercesc::InputSource& i,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::prj::srl::swps::Sweep > (
          ::prj::srl::swps::sweep (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::prj::srl::swps::Sweep > (
          ::prj::srl::swps::sweep (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (const ::xercesc::DOMDocument& doc,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
      {
        if (f & ::xml_schema::Flags::keep_dom)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::prj::srl::swps::Sweep > (
            ::prj::srl::swps::sweep (
              std::move (d), f | ::xml_schema::Flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "sweep" &&
            n.namespace_ () == "http://www.cadseer.com/prj/srl/swps")
        {
          ::std::unique_ptr< ::prj::srl::swps::Sweep > r (
            ::xsd::cxx::tree::traits< ::prj::srl::swps::Sweep, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "sweep",
          "http://www.cadseer.com/prj/srl/swps");
      }

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties&)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::xml_schema::Flags::keep_dom) &&
           !(f & ::xml_schema::Flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::xml_schema::Flags::keep_dom)
          doc.setUserData (::xml_schema::dom::tree_node_key,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "sweep" &&
            n.namespace_ () == "http://www.cadseer.com/prj/srl/swps")
        {
          ::std::unique_ptr< ::prj::srl::swps::Sweep > r (
            ::xsd::cxx::tree::traits< ::prj::srl::swps::Sweep, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "sweep",
          "http://www.cadseer.com/prj/srl/swps");
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace swps
    {
      void
      operator<< (::xercesc::DOMElement& e, const SweepProfile& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // pick
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "pick",
              e));

          s << i.pick ();
        }

        // contact
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "contact",
              e));

          s << i.contact ();
        }

        // correction
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "correction",
              e));

          s << i.correction ();
        }

        // contactLabel
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "contactLabel",
              e));

          s << i.contactLabel ();
        }

        // correctionLabel
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "correctionLabel",
              e));

          s << i.correctionLabel ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const SweepAuxiliary& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // pick
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "pick",
              e));

          s << i.pick ();
        }

        // curvilinearEquivalence
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "curvilinearEquivalence",
              e));

          s << i.curvilinearEquivalence ();
        }

        // contactType
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "contactType",
              e));

          s << i.contactType ();
        }

        // curvilinearEquivalenceLabel
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "curvilinearEquivalenceLabel",
              e));

          s << i.curvilinearEquivalenceLabel ();
        }

        // contactTypeLabel
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "contactTypeLabel",
              e));

          s << i.contactTypeLabel ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const SweepBinormal& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // picks
        //
        for (SweepBinormal::PicksConstIterator
             b (i.picks ().begin ()), n (i.picks ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "picks",
              e));

          s << *b;
        }

        // binormal
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "binormal",
              e));

          s << i.binormal ();
        }

        // binormalLabel
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "binormalLabel",
              e));

          s << i.binormalLabel ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Instance& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // key
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "key",
              e));

          s << i.key ();
        }

        // values
        //
        for (Instance::ValuesConstIterator
             b (i.values ().begin ()), n (i.values ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "values",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Sweep& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // base
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "base",
              e));

          s << i.base ();
        }

        // seerShape
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "seerShape",
              e));

          s << i.seerShape ();
        }

        // lawFunction
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "lawFunction",
              e));

          s << i.lawFunction ();
        }

        // trihedron
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "trihedron",
              e));

          s << i.trihedron ();
        }

        // transition
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "transition",
              e));

          s << i.transition ();
        }

        // forceC1
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "forceC1",
              e));

          s << i.forceC1 ();
        }

        // solid
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "solid",
              e));

          s << i.solid ();
        }

        // useLaw
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "useLaw",
              e));

          s << i.useLaw ();
        }

        // spine
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "spine",
              e));

          s << i.spine ();
        }

        // profiles
        //
        for (Sweep::ProfilesConstIterator
             b (i.profiles ().begin ()), n (i.profiles ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "profiles",
              e));

          s << *b;
        }

        // auxiliary
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "auxiliary",
              e));

          s << i.auxiliary ();
        }

        // support
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "support",
              e));

          s << i.support ();
        }

        // binormal
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "binormal",
              e));

          s << i.binormal ();
        }

        // trihedronLabel
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "trihedronLabel",
              e));

          s << i.trihedronLabel ();
        }

        // transitionLabel
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "transitionLabel",
              e));

          s << i.transitionLabel ();
        }

        // forceC1Label
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "forceC1Label",
              e));

          s << i.forceC1Label ();
        }

        // solidLabel
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "solidLabel",
              e));

          s << i.solidLabel ();
        }

        // useLawLabel
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "useLawLabel",
              e));

          s << i.useLawLabel ();
        }

        // lawVizMatrix
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "lawVizMatrix",
              e));

          s << i.lawVizMatrix ();
        }

        // lawVizScale
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "lawVizScale",
              e));

          s << ::xml_schema::AsDouble(i.lawVizScale ());
        }

        // solidId
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "solidId",
              e));

          s << i.solidId ();
        }

        // shellId
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "shellId",
              e));

          s << i.shellId ();
        }

        // firstFaceId
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "firstFaceId",
              e));

          s << i.firstFaceId ();
        }

        // lastFaceId
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "lastFaceId",
              e));

          s << i.lastFaceId ();
        }

        // outerWireMap
        //
        for (Sweep::OuterWireMapConstIterator
             b (i.outerWireMap ().begin ()), n (i.outerWireMap ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "outerWireMap",
              e));

          s << *b;
        }

        // instanceMap
        //
        for (Sweep::InstanceMapConstIterator
             b (i.instanceMap ().begin ()), n (i.instanceMap ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "instanceMap",
              e));

          s << *b;
        }

        // firstShapeMap
        //
        for (Sweep::FirstShapeMapConstIterator
             b (i.firstShapeMap ().begin ()), n (i.firstShapeMap ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "firstShapeMap",
              e));

          s << *b;
        }

        // lastShapeMap
        //
        for (Sweep::LastShapeMapConstIterator
             b (i.lastShapeMap ().begin ()), n (i.lastShapeMap ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "lastShapeMap",
              e));

          s << *b;
        }
      }

      void
      sweep (::std::ostream& o,
             const ::prj::srl::swps::Sweep& s,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::swps::sweep (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      sweep (::std::ostream& o,
             const ::prj::srl::swps::Sweep& s,
             ::xml_schema::ErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::swps::sweep (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      sweep (::std::ostream& o,
             const ::prj::srl::swps::Sweep& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::swps::sweep (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      sweep (::xercesc::XMLFormatTarget& t,
             const ::prj::srl::swps::Sweep& s,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::swps::sweep (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      sweep (::xercesc::XMLFormatTarget& t,
             const ::prj::srl::swps::Sweep& s,
             ::xml_schema::ErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::swps::sweep (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      sweep (::xercesc::XMLFormatTarget& t,
             const ::prj::srl::swps::Sweep& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::swps::sweep (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      sweep (::xercesc::DOMDocument& d,
             const ::prj::srl::swps::Sweep& s,
             ::xml_schema::Flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "sweep" &&
            n.namespace_ () == "http://www.cadseer.com/prj/srl/swps")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "sweep",
            "http://www.cadseer.com/prj/srl/swps");
        }
      }

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
      sweep (const ::prj::srl::swps::Sweep& s,
             const ::xml_schema::NamespaceInfomap& m,
             ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "sweep",
            "http://www.cadseer.com/prj/srl/swps",
            m, f));

        ::prj::srl::swps::sweep (*d, s, f);
        return d;
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

