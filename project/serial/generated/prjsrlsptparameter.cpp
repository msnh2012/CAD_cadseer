// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "prjsrlsptparameter.h"

namespace prj
{
  namespace srl
  {
    namespace spt
    {
      // ParameterValue
      // 

      const ParameterValue::ADoubleOptional& ParameterValue::
      aDouble () const
      {
        return this->aDouble_;
      }

      ParameterValue::ADoubleOptional& ParameterValue::
      aDouble ()
      {
        return this->aDouble_;
      }

      void ParameterValue::
      aDouble (const ADoubleType& x)
      {
        this->aDouble_.set (x);
      }

      void ParameterValue::
      aDouble (const ADoubleOptional& x)
      {
        this->aDouble_ = x;
      }

      ParameterValue::ADoubleType ParameterValue::
      aDouble_default_value ()
      {
        return ADoubleType (.0);
      }

      const ParameterValue::AnIntegerOptional& ParameterValue::
      anInteger () const
      {
        return this->anInteger_;
      }

      ParameterValue::AnIntegerOptional& ParameterValue::
      anInteger ()
      {
        return this->anInteger_;
      }

      void ParameterValue::
      anInteger (const AnIntegerType& x)
      {
        this->anInteger_.set (x);
      }

      void ParameterValue::
      anInteger (const AnIntegerOptional& x)
      {
        this->anInteger_ = x;
      }

      ParameterValue::AnIntegerType ParameterValue::
      anInteger_default_value ()
      {
        return AnIntegerType (0);
      }

      const ParameterValue::ABoolOptional& ParameterValue::
      aBool () const
      {
        return this->aBool_;
      }

      ParameterValue::ABoolOptional& ParameterValue::
      aBool ()
      {
        return this->aBool_;
      }

      void ParameterValue::
      aBool (const ABoolType& x)
      {
        this->aBool_.set (x);
      }

      void ParameterValue::
      aBool (const ABoolOptional& x)
      {
        this->aBool_ = x;
      }

      ParameterValue::ABoolType ParameterValue::
      aBool_default_value ()
      {
        return ABoolType (false);
      }

      const ParameterValue::AStringOptional& ParameterValue::
      aString () const
      {
        return this->aString_;
      }

      ParameterValue::AStringOptional& ParameterValue::
      aString ()
      {
        return this->aString_;
      }

      void ParameterValue::
      aString (const AStringType& x)
      {
        this->aString_.set (x);
      }

      void ParameterValue::
      aString (const AStringOptional& x)
      {
        this->aString_ = x;
      }

      void ParameterValue::
      aString (::std::unique_ptr< AStringType > x)
      {
        this->aString_.set (std::move (x));
      }

      const ParameterValue::APathOptional& ParameterValue::
      aPath () const
      {
        return this->aPath_;
      }

      ParameterValue::APathOptional& ParameterValue::
      aPath ()
      {
        return this->aPath_;
      }

      void ParameterValue::
      aPath (const APathType& x)
      {
        this->aPath_.set (x);
      }

      void ParameterValue::
      aPath (const APathOptional& x)
      {
        this->aPath_ = x;
      }

      void ParameterValue::
      aPath (::std::unique_ptr< APathType > x)
      {
        this->aPath_.set (std::move (x));
      }

      const ParameterValue::AVec3dOptional& ParameterValue::
      aVec3d () const
      {
        return this->aVec3d_;
      }

      ParameterValue::AVec3dOptional& ParameterValue::
      aVec3d ()
      {
        return this->aVec3d_;
      }

      void ParameterValue::
      aVec3d (const AVec3dType& x)
      {
        this->aVec3d_.set (x);
      }

      void ParameterValue::
      aVec3d (const AVec3dOptional& x)
      {
        this->aVec3d_ = x;
      }

      void ParameterValue::
      aVec3d (::std::unique_ptr< AVec3dType > x)
      {
        this->aVec3d_.set (std::move (x));
      }

      const ParameterValue::AQuatOptional& ParameterValue::
      aQuat () const
      {
        return this->aQuat_;
      }

      ParameterValue::AQuatOptional& ParameterValue::
      aQuat ()
      {
        return this->aQuat_;
      }

      void ParameterValue::
      aQuat (const AQuatType& x)
      {
        this->aQuat_.set (x);
      }

      void ParameterValue::
      aQuat (const AQuatOptional& x)
      {
        this->aQuat_ = x;
      }

      void ParameterValue::
      aQuat (::std::unique_ptr< AQuatType > x)
      {
        this->aQuat_.set (std::move (x));
      }

      const ParameterValue::AMatrixdOptional& ParameterValue::
      aMatrixd () const
      {
        return this->aMatrixd_;
      }

      ParameterValue::AMatrixdOptional& ParameterValue::
      aMatrixd ()
      {
        return this->aMatrixd_;
      }

      void ParameterValue::
      aMatrixd (const AMatrixdType& x)
      {
        this->aMatrixd_.set (x);
      }

      void ParameterValue::
      aMatrixd (const AMatrixdOptional& x)
      {
        this->aMatrixd_ = x;
      }

      void ParameterValue::
      aMatrixd (::std::unique_ptr< AMatrixdType > x)
      {
        this->aMatrixd_.set (std::move (x));
      }

      const ParameterValue::APicksSequence& ParameterValue::
      aPicks () const
      {
        return this->aPicks_;
      }

      ParameterValue::APicksSequence& ParameterValue::
      aPicks ()
      {
        return this->aPicks_;
      }

      void ParameterValue::
      aPicks (const APicksSequence& s)
      {
        this->aPicks_ = s;
      }


      // Parameter
      // 

      const Parameter::IdType& Parameter::
      id () const
      {
        return this->id_.get ();
      }

      Parameter::IdType& Parameter::
      id ()
      {
        return this->id_.get ();
      }

      void Parameter::
      id (const IdType& x)
      {
        this->id_.set (x);
      }

      void Parameter::
      id (::std::unique_ptr< IdType > x)
      {
        this->id_.set (std::move (x));
      }

      const Parameter::IdType& Parameter::
      id_default_value ()
      {
        return id_default_value_;
      }

      const Parameter::NameType& Parameter::
      name () const
      {
        return this->name_.get ();
      }

      Parameter::NameType& Parameter::
      name ()
      {
        return this->name_.get ();
      }

      void Parameter::
      name (const NameType& x)
      {
        this->name_.set (x);
      }

      void Parameter::
      name (::std::unique_ptr< NameType > x)
      {
        this->name_.set (std::move (x));
      }

      const Parameter::NameType& Parameter::
      name_default_value ()
      {
        return name_default_value_;
      }

      const Parameter::TagType& Parameter::
      tag () const
      {
        return this->tag_.get ();
      }

      Parameter::TagType& Parameter::
      tag ()
      {
        return this->tag_.get ();
      }

      void Parameter::
      tag (const TagType& x)
      {
        this->tag_.set (x);
      }

      void Parameter::
      tag (::std::unique_ptr< TagType > x)
      {
        this->tag_.set (std::move (x));
      }

      const Parameter::TagType& Parameter::
      tag_default_value ()
      {
        return tag_default_value_;
      }

      const Parameter::ConstantType& Parameter::
      constant () const
      {
        return this->constant_.get ();
      }

      Parameter::ConstantType& Parameter::
      constant ()
      {
        return this->constant_.get ();
      }

      void Parameter::
      constant (const ConstantType& x)
      {
        this->constant_.set (x);
      }

      Parameter::ConstantType Parameter::
      constant_default_value ()
      {
        return ConstantType (true);
      }

      const Parameter::ActiveType& Parameter::
      active () const
      {
        return this->active_.get ();
      }

      Parameter::ActiveType& Parameter::
      active ()
      {
        return this->active_.get ();
      }

      void Parameter::
      active (const ActiveType& x)
      {
        this->active_.set (x);
      }

      Parameter::ActiveType Parameter::
      active_default_value ()
      {
        return ActiveType (true);
      }

      const Parameter::PValueType& Parameter::
      pValue () const
      {
        return this->pValue_.get ();
      }

      Parameter::PValueType& Parameter::
      pValue ()
      {
        return this->pValue_.get ();
      }

      void Parameter::
      pValue (const PValueType& x)
      {
        this->pValue_.set (x);
      }

      void Parameter::
      pValue (::std::unique_ptr< PValueType > x)
      {
        this->pValue_.set (std::move (x));
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace spt
    {
      // ParameterValue
      //

      ParameterValue::
      ParameterValue ()
      : ::xml_schema::Type (),
        aDouble_ (this),
        anInteger_ (this),
        aBool_ (this),
        aString_ (this),
        aPath_ (this),
        aVec3d_ (this),
        aQuat_ (this),
        aMatrixd_ (this),
        aPicks_ (this)
      {
      }

      ParameterValue::
      ParameterValue (const ParameterValue& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        aDouble_ (x.aDouble_, f, this),
        anInteger_ (x.anInteger_, f, this),
        aBool_ (x.aBool_, f, this),
        aString_ (x.aString_, f, this),
        aPath_ (x.aPath_, f, this),
        aVec3d_ (x.aVec3d_, f, this),
        aQuat_ (x.aQuat_, f, this),
        aMatrixd_ (x.aMatrixd_, f, this),
        aPicks_ (x.aPicks_, f, this)
      {
      }

      ParameterValue::
      ParameterValue (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        aDouble_ (this),
        anInteger_ (this),
        aBool_ (this),
        aString_ (this),
        aPath_ (this),
        aVec3d_ (this),
        aQuat_ (this),
        aMatrixd_ (this),
        aPicks_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void ParameterValue::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // aDouble
          //
          if (n.name () == "aDouble" && n.namespace_ ().empty ())
          {
            if (!this->aDouble_)
            {
              this->aDouble_.set (ADoubleTraits::create (i, f, this));
              continue;
            }
          }

          // anInteger
          //
          if (n.name () == "anInteger" && n.namespace_ ().empty ())
          {
            if (!this->anInteger_)
            {
              this->anInteger_.set (AnIntegerTraits::create (i, f, this));
              continue;
            }
          }

          // aBool
          //
          if (n.name () == "aBool" && n.namespace_ ().empty ())
          {
            if (!this->aBool_)
            {
              this->aBool_.set (ABoolTraits::create (i, f, this));
              continue;
            }
          }

          // aString
          //
          if (n.name () == "aString" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< AStringType > r (
              AStringTraits::create (i, f, this));

            if (!this->aString_)
            {
              this->aString_.set (::std::move (r));
              continue;
            }
          }

          // aPath
          //
          if (n.name () == "aPath" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< APathType > r (
              APathTraits::create (i, f, this));

            if (!this->aPath_)
            {
              this->aPath_.set (::std::move (r));
              continue;
            }
          }

          // aVec3d
          //
          if (n.name () == "aVec3d" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< AVec3dType > r (
              AVec3dTraits::create (i, f, this));

            if (!this->aVec3d_)
            {
              this->aVec3d_.set (::std::move (r));
              continue;
            }
          }

          // aQuat
          //
          if (n.name () == "aQuat" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< AQuatType > r (
              AQuatTraits::create (i, f, this));

            if (!this->aQuat_)
            {
              this->aQuat_.set (::std::move (r));
              continue;
            }
          }

          // aMatrixd
          //
          if (n.name () == "aMatrixd" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< AMatrixdType > r (
              AMatrixdTraits::create (i, f, this));

            if (!this->aMatrixd_)
            {
              this->aMatrixd_.set (::std::move (r));
              continue;
            }
          }

          // aPicks
          //
          if (n.name () == "aPicks" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< APicksType > r (
              APicksTraits::create (i, f, this));

            this->aPicks_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      ParameterValue* ParameterValue::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class ParameterValue (*this, f, c);
      }

      ParameterValue& ParameterValue::
      operator= (const ParameterValue& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->aDouble_ = x.aDouble_;
          this->anInteger_ = x.anInteger_;
          this->aBool_ = x.aBool_;
          this->aString_ = x.aString_;
          this->aPath_ = x.aPath_;
          this->aVec3d_ = x.aVec3d_;
          this->aQuat_ = x.aQuat_;
          this->aMatrixd_ = x.aMatrixd_;
          this->aPicks_ = x.aPicks_;
        }

        return *this;
      }

      ParameterValue::
      ~ParameterValue ()
      {
      }

      // Parameter
      //

      const Parameter::IdType Parameter::id_default_value_ (
        "00000000-0000-0000-0000-000000000000");

      const Parameter::NameType Parameter::name_default_value_ (
        "Name");

      const Parameter::TagType Parameter::tag_default_value_ (
        "");

      Parameter::
      Parameter (const IdType& id,
                 const NameType& name,
                 const TagType& tag,
                 const ConstantType& constant,
                 const ActiveType& active,
                 const PValueType& pValue)
      : ::xml_schema::Type (),
        id_ (id, this),
        name_ (name, this),
        tag_ (tag, this),
        constant_ (constant, this),
        active_ (active, this),
        pValue_ (pValue, this)
      {
      }

      Parameter::
      Parameter (const IdType& id,
                 const NameType& name,
                 const TagType& tag,
                 const ConstantType& constant,
                 const ActiveType& active,
                 ::std::unique_ptr< PValueType > pValue)
      : ::xml_schema::Type (),
        id_ (id, this),
        name_ (name, this),
        tag_ (tag, this),
        constant_ (constant, this),
        active_ (active, this),
        pValue_ (std::move (pValue), this)
      {
      }

      Parameter::
      Parameter (const Parameter& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        id_ (x.id_, f, this),
        name_ (x.name_, f, this),
        tag_ (x.tag_, f, this),
        constant_ (x.constant_, f, this),
        active_ (x.active_, f, this),
        pValue_ (x.pValue_, f, this)
      {
      }

      Parameter::
      Parameter (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        id_ (this),
        name_ (this),
        tag_ (this),
        constant_ (this),
        active_ (this),
        pValue_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Parameter::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // id
          //
          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< IdType > r (
              IdTraits::create (i, f, this));

            if (!id_.present ())
            {
              this->id_.set (::std::move (r));
              continue;
            }
          }

          // name
          //
          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< NameType > r (
              NameTraits::create (i, f, this));

            if (!name_.present ())
            {
              this->name_.set (::std::move (r));
              continue;
            }
          }

          // tag
          //
          if (n.name () == "tag" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< TagType > r (
              TagTraits::create (i, f, this));

            if (!tag_.present ())
            {
              this->tag_.set (::std::move (r));
              continue;
            }
          }

          // constant
          //
          if (n.name () == "constant" && n.namespace_ ().empty ())
          {
            if (!constant_.present ())
            {
              this->constant_.set (ConstantTraits::create (i, f, this));
              continue;
            }
          }

          // active
          //
          if (n.name () == "active" && n.namespace_ ().empty ())
          {
            if (!active_.present ())
            {
              this->active_.set (ActiveTraits::create (i, f, this));
              continue;
            }
          }

          // pValue
          //
          if (n.name () == "pValue" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< PValueType > r (
              PValueTraits::create (i, f, this));

            if (!pValue_.present ())
            {
              this->pValue_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "id",
            "");
        }

        if (!name_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "name",
            "");
        }

        if (!tag_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "tag",
            "");
        }

        if (!constant_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "constant",
            "");
        }

        if (!active_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "active",
            "");
        }

        if (!pValue_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "pValue",
            "");
        }
      }

      Parameter* Parameter::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Parameter (*this, f, c);
      }

      Parameter& Parameter::
      operator= (const Parameter& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->id_ = x.id_;
          this->name_ = x.name_;
          this->tag_ = x.tag_;
          this->constant_ = x.constant_;
          this->active_ = x.active_;
          this->pValue_ = x.pValue_;
        }

        return *this;
      }

      Parameter::
      ~Parameter ()
      {
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace prj
{
  namespace srl
  {
    namespace spt
    {
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace spt
    {
      void
      operator<< (::xercesc::DOMElement& e, const ParameterValue& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // aDouble
        //
        if (i.aDouble ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "aDouble",
              e));

          s << ::xml_schema::AsDouble(*i.aDouble ());
        }

        // anInteger
        //
        if (i.anInteger ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "anInteger",
              e));

          s << *i.anInteger ();
        }

        // aBool
        //
        if (i.aBool ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "aBool",
              e));

          s << *i.aBool ();
        }

        // aString
        //
        if (i.aString ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "aString",
              e));

          s << *i.aString ();
        }

        // aPath
        //
        if (i.aPath ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "aPath",
              e));

          s << *i.aPath ();
        }

        // aVec3d
        //
        if (i.aVec3d ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "aVec3d",
              e));

          s << *i.aVec3d ();
        }

        // aQuat
        //
        if (i.aQuat ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "aQuat",
              e));

          s << *i.aQuat ();
        }

        // aMatrixd
        //
        if (i.aMatrixd ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "aMatrixd",
              e));

          s << *i.aMatrixd ();
        }

        // aPicks
        //
        for (ParameterValue::APicksConstIterator
             b (i.aPicks ().begin ()), n (i.aPicks ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "aPicks",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Parameter& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // id
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << i.id ();
        }

        // name
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << i.name ();
        }

        // tag
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "tag",
              e));

          s << i.tag ();
        }

        // constant
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "constant",
              e));

          s << i.constant ();
        }

        // active
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "active",
              e));

          s << i.active ();
        }

        // pValue
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "pValue",
              e));

          s << i.pValue ();
        }
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

