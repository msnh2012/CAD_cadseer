// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef PRJ_SRL_PRJS_PRJSRLPRJSPROJECT_H
#define PRJ_SRL_PRJS_PRJSRLPRJSPROJECT_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include "../../../xmlbase.h"

// Forward declarations.
//
namespace prj
{
  namespace srl
  {
    namespace prjs
    {
      class Feature;
      class FeatureState;
      class Connection;
      class AppVersion;
      class Expression;
      class ExpressionLink;
      class ExpressionGroup;
      class Project;
    }
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "prjsrlsptshapehistory.h"

namespace prj
{
  namespace srl
  {
    namespace prjs
    {
      class Feature: public ::xml_schema::Type
      {
        public:
        // id
        //
        typedef ::xml_schema::String IdType;
        typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

        const IdType&
        id () const;

        IdType&
        id ();

        void
        id (const IdType& x);

        void
        id (::std::unique_ptr< IdType > p);

        static const IdType&
        id_default_value ();

        // type
        //
        typedef ::xml_schema::String TypeType;
        typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

        const TypeType&
        type () const;

        TypeType&
        type ();

        void
        type (const TypeType& x);

        void
        type (::std::unique_ptr< TypeType > p);

        static const TypeType&
        type_default_value ();

        // shapeOffset
        //
        typedef ::xml_schema::UnsignedLong ShapeOffsetType;
        typedef ::xsd::cxx::tree::traits< ShapeOffsetType, char > ShapeOffsetTraits;

        const ShapeOffsetType&
        shapeOffset () const;

        ShapeOffsetType&
        shapeOffset ();

        void
        shapeOffset (const ShapeOffsetType& x);

        static ShapeOffsetType
        shapeOffset_default_value ();

        // Constructors.
        //
        Feature (const IdType&,
                 const TypeType&,
                 const ShapeOffsetType&);

        Feature (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

        Feature (const Feature& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

        virtual Feature*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        Feature&
        operator= (const Feature& x);

        virtual 
        ~Feature ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< IdType > id_;
        static const IdType id_default_value_;
        ::xsd::cxx::tree::one< TypeType > type_;
        static const TypeType type_default_value_;
        ::xsd::cxx::tree::one< ShapeOffsetType > shapeOffset_;
      };

      class FeatureState: public ::xml_schema::Type
      {
        public:
        // id
        //
        typedef ::xml_schema::String IdType;
        typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

        const IdType&
        id () const;

        IdType&
        id ();

        void
        id (const IdType& x);

        void
        id (::std::unique_ptr< IdType > p);

        static const IdType&
        id_default_value ();

        // state
        //
        typedef ::xml_schema::String StateType;
        typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

        const StateType&
        state () const;

        StateType&
        state ();

        void
        state (const StateType& x);

        void
        state (::std::unique_ptr< StateType > p);

        // Constructors.
        //
        FeatureState (const IdType&,
                      const StateType&);

        FeatureState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

        FeatureState (const FeatureState& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

        virtual FeatureState*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        FeatureState&
        operator= (const FeatureState& x);

        virtual 
        ~FeatureState ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< IdType > id_;
        static const IdType id_default_value_;
        ::xsd::cxx::tree::one< StateType > state_;
      };

      class Connection: public ::xml_schema::Type
      {
        public:
        // sourceId
        //
        typedef ::xml_schema::String SourceIdType;
        typedef ::xsd::cxx::tree::traits< SourceIdType, char > SourceIdTraits;

        const SourceIdType&
        sourceId () const;

        SourceIdType&
        sourceId ();

        void
        sourceId (const SourceIdType& x);

        void
        sourceId (::std::unique_ptr< SourceIdType > p);

        static const SourceIdType&
        sourceId_default_value ();

        // targetId
        //
        typedef ::xml_schema::String TargetIdType;
        typedef ::xsd::cxx::tree::traits< TargetIdType, char > TargetIdTraits;

        const TargetIdType&
        targetId () const;

        TargetIdType&
        targetId ();

        void
        targetId (const TargetIdType& x);

        void
        targetId (::std::unique_ptr< TargetIdType > p);

        static const TargetIdType&
        targetId_default_value ();

        // inputType
        //
        typedef ::xml_schema::String InputTypeType;
        typedef ::xsd::cxx::tree::sequence< InputTypeType > InputTypeSequence;
        typedef InputTypeSequence::iterator InputTypeIterator;
        typedef InputTypeSequence::const_iterator InputTypeConstIterator;
        typedef ::xsd::cxx::tree::traits< InputTypeType, char > InputTypeTraits;

        const InputTypeSequence&
        inputType () const;

        InputTypeSequence&
        inputType ();

        void
        inputType (const InputTypeSequence& s);

        // Constructors.
        //
        Connection (const SourceIdType&,
                    const TargetIdType&);

        Connection (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

        Connection (const Connection& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

        virtual Connection*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        Connection&
        operator= (const Connection& x);

        virtual 
        ~Connection ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< SourceIdType > sourceId_;
        static const SourceIdType sourceId_default_value_;
        ::xsd::cxx::tree::one< TargetIdType > targetId_;
        static const TargetIdType targetId_default_value_;
        InputTypeSequence inputType_;
      };

      class AppVersion: public ::xml_schema::Type
      {
        public:
        // major
        //
        typedef ::xml_schema::Int MajorType;
        typedef ::xsd::cxx::tree::traits< MajorType, char > MajorTraits;

        const MajorType&
        major () const;

        MajorType&
        major ();

        void
        major (const MajorType& x);

        static MajorType
        major_default_value ();

        // minor
        //
        typedef ::xml_schema::Int MinorType;
        typedef ::xsd::cxx::tree::traits< MinorType, char > MinorTraits;

        const MinorType&
        minor () const;

        MinorType&
        minor ();

        void
        minor (const MinorType& x);

        static MinorType
        minor_default_value ();

        // maintenance
        //
        typedef ::xml_schema::Int MaintenanceType;
        typedef ::xsd::cxx::tree::traits< MaintenanceType, char > MaintenanceTraits;

        const MaintenanceType&
        maintenance () const;

        MaintenanceType&
        maintenance ();

        void
        maintenance (const MaintenanceType& x);

        static MaintenanceType
        maintenance_default_value ();

        // Constructors.
        //
        AppVersion (const MajorType&,
                    const MinorType&,
                    const MaintenanceType&);

        AppVersion (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

        AppVersion (const AppVersion& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

        virtual AppVersion*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        AppVersion&
        operator= (const AppVersion& x);

        virtual 
        ~AppVersion ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< MajorType > major_;
        ::xsd::cxx::tree::one< MinorType > minor_;
        ::xsd::cxx::tree::one< MaintenanceType > maintenance_;
      };

      class Expression: public ::xml_schema::Type
      {
        public:
        // id
        //
        typedef ::xml_schema::String IdType;
        typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

        const IdType&
        id () const;

        IdType&
        id ();

        void
        id (const IdType& x);

        void
        id (::std::unique_ptr< IdType > p);

        static const IdType&
        id_default_value ();

        // stringForm
        //
        typedef ::xml_schema::String StringFormType;
        typedef ::xsd::cxx::tree::traits< StringFormType, char > StringFormTraits;

        const StringFormType&
        stringForm () const;

        StringFormType&
        stringForm ();

        void
        stringForm (const StringFormType& x);

        void
        stringForm (::std::unique_ptr< StringFormType > p);

        static const StringFormType&
        stringForm_default_value ();

        // Constructors.
        //
        Expression (const IdType&,
                    const StringFormType&);

        Expression (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

        Expression (const Expression& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

        virtual Expression*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        Expression&
        operator= (const Expression& x);

        virtual 
        ~Expression ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< IdType > id_;
        static const IdType id_default_value_;
        ::xsd::cxx::tree::one< StringFormType > stringForm_;
        static const StringFormType stringForm_default_value_;
      };

      class ExpressionLink: public ::xml_schema::Type
      {
        public:
        // parameterId
        //
        typedef ::xml_schema::String ParameterIdType;
        typedef ::xsd::cxx::tree::traits< ParameterIdType, char > ParameterIdTraits;

        const ParameterIdType&
        parameterId () const;

        ParameterIdType&
        parameterId ();

        void
        parameterId (const ParameterIdType& x);

        void
        parameterId (::std::unique_ptr< ParameterIdType > p);

        static const ParameterIdType&
        parameterId_default_value ();

        // expressionId
        //
        typedef ::xml_schema::String ExpressionIdType;
        typedef ::xsd::cxx::tree::traits< ExpressionIdType, char > ExpressionIdTraits;

        const ExpressionIdType&
        expressionId () const;

        ExpressionIdType&
        expressionId ();

        void
        expressionId (const ExpressionIdType& x);

        void
        expressionId (::std::unique_ptr< ExpressionIdType > p);

        static const ExpressionIdType&
        expressionId_default_value ();

        // Constructors.
        //
        ExpressionLink (const ParameterIdType&,
                        const ExpressionIdType&);

        ExpressionLink (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

        ExpressionLink (const ExpressionLink& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

        virtual ExpressionLink*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        ExpressionLink&
        operator= (const ExpressionLink& x);

        virtual 
        ~ExpressionLink ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< ParameterIdType > parameterId_;
        static const ParameterIdType parameterId_default_value_;
        ::xsd::cxx::tree::one< ExpressionIdType > expressionId_;
        static const ExpressionIdType expressionId_default_value_;
      };

      class ExpressionGroup: public ::xml_schema::Type
      {
        public:
        // id
        //
        typedef ::xml_schema::String IdType;
        typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

        const IdType&
        id () const;

        IdType&
        id ();

        void
        id (const IdType& x);

        void
        id (::std::unique_ptr< IdType > p);

        static const IdType&
        id_default_value ();

        // name
        //
        typedef ::xml_schema::String NameType;
        typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

        const NameType&
        name () const;

        NameType&
        name ();

        void
        name (const NameType& x);

        void
        name (::std::unique_ptr< NameType > p);

        static const NameType&
        name_default_value ();

        // entries
        //
        typedef ::xml_schema::String EntriesType;
        typedef ::xsd::cxx::tree::sequence< EntriesType > EntriesSequence;
        typedef EntriesSequence::iterator EntriesIterator;
        typedef EntriesSequence::const_iterator EntriesConstIterator;
        typedef ::xsd::cxx::tree::traits< EntriesType, char > EntriesTraits;

        const EntriesSequence&
        entries () const;

        EntriesSequence&
        entries ();

        void
        entries (const EntriesSequence& s);

        // Constructors.
        //
        ExpressionGroup (const IdType&,
                         const NameType&);

        ExpressionGroup (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

        ExpressionGroup (const ExpressionGroup& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

        virtual ExpressionGroup*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        ExpressionGroup&
        operator= (const ExpressionGroup& x);

        virtual 
        ~ExpressionGroup ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< IdType > id_;
        static const IdType id_default_value_;
        ::xsd::cxx::tree::one< NameType > name_;
        static const NameType name_default_value_;
        EntriesSequence entries_;
      };

      class Project: public ::xml_schema::Type
      {
        public:
        // appVersion
        //
        typedef ::prj::srl::prjs::AppVersion AppVersionType;
        typedef ::xsd::cxx::tree::traits< AppVersionType, char > AppVersionTraits;

        const AppVersionType&
        appVersion () const;

        AppVersionType&
        appVersion ();

        void
        appVersion (const AppVersionType& x);

        void
        appVersion (::std::unique_ptr< AppVersionType > p);

        // fileVersion
        //
        typedef ::xml_schema::Int FileVersionType;
        typedef ::xsd::cxx::tree::traits< FileVersionType, char > FileVersionTraits;

        const FileVersionType&
        fileVersion () const;

        FileVersionType&
        fileVersion ();

        void
        fileVersion (const FileVersionType& x);

        static FileVersionType
        fileVersion_default_value ();

        // features
        //
        typedef ::prj::srl::prjs::Feature FeaturesType;
        typedef ::xsd::cxx::tree::sequence< FeaturesType > FeaturesSequence;
        typedef FeaturesSequence::iterator FeaturesIterator;
        typedef FeaturesSequence::const_iterator FeaturesConstIterator;
        typedef ::xsd::cxx::tree::traits< FeaturesType, char > FeaturesTraits;

        const FeaturesSequence&
        features () const;

        FeaturesSequence&
        features ();

        void
        features (const FeaturesSequence& s);

        // states
        //
        typedef ::prj::srl::prjs::FeatureState StatesType;
        typedef ::xsd::cxx::tree::sequence< StatesType > StatesSequence;
        typedef StatesSequence::iterator StatesIterator;
        typedef StatesSequence::const_iterator StatesConstIterator;
        typedef ::xsd::cxx::tree::traits< StatesType, char > StatesTraits;

        const StatesSequence&
        states () const;

        StatesSequence&
        states ();

        void
        states (const StatesSequence& s);

        // connections
        //
        typedef ::prj::srl::prjs::Connection ConnectionsType;
        typedef ::xsd::cxx::tree::sequence< ConnectionsType > ConnectionsSequence;
        typedef ConnectionsSequence::iterator ConnectionsIterator;
        typedef ConnectionsSequence::const_iterator ConnectionsConstIterator;
        typedef ::xsd::cxx::tree::traits< ConnectionsType, char > ConnectionsTraits;

        const ConnectionsSequence&
        connections () const;

        ConnectionsSequence&
        connections ();

        void
        connections (const ConnectionsSequence& s);

        // expressions
        //
        typedef ::prj::srl::prjs::Expression ExpressionsType;
        typedef ::xsd::cxx::tree::sequence< ExpressionsType > ExpressionsSequence;
        typedef ExpressionsSequence::iterator ExpressionsIterator;
        typedef ExpressionsSequence::const_iterator ExpressionsConstIterator;
        typedef ::xsd::cxx::tree::traits< ExpressionsType, char > ExpressionsTraits;

        const ExpressionsSequence&
        expressions () const;

        ExpressionsSequence&
        expressions ();

        void
        expressions (const ExpressionsSequence& s);

        // expressionLinks
        //
        typedef ::prj::srl::prjs::ExpressionLink ExpressionLinksType;
        typedef ::xsd::cxx::tree::sequence< ExpressionLinksType > ExpressionLinksSequence;
        typedef ExpressionLinksSequence::iterator ExpressionLinksIterator;
        typedef ExpressionLinksSequence::const_iterator ExpressionLinksConstIterator;
        typedef ::xsd::cxx::tree::traits< ExpressionLinksType, char > ExpressionLinksTraits;

        const ExpressionLinksSequence&
        expressionLinks () const;

        ExpressionLinksSequence&
        expressionLinks ();

        void
        expressionLinks (const ExpressionLinksSequence& s);

        // expressionGroups
        //
        typedef ::prj::srl::prjs::ExpressionGroup ExpressionGroupsType;
        typedef ::xsd::cxx::tree::sequence< ExpressionGroupsType > ExpressionGroupsSequence;
        typedef ExpressionGroupsSequence::iterator ExpressionGroupsIterator;
        typedef ExpressionGroupsSequence::const_iterator ExpressionGroupsConstIterator;
        typedef ::xsd::cxx::tree::traits< ExpressionGroupsType, char > ExpressionGroupsTraits;

        const ExpressionGroupsSequence&
        expressionGroups () const;

        ExpressionGroupsSequence&
        expressionGroups ();

        void
        expressionGroups (const ExpressionGroupsSequence& s);

        // shapeHistory
        //
        typedef ::prj::srl::spt::ShapeHistory ShapeHistoryType;
        typedef ::xsd::cxx::tree::traits< ShapeHistoryType, char > ShapeHistoryTraits;

        const ShapeHistoryType&
        shapeHistory () const;

        ShapeHistoryType&
        shapeHistory ();

        void
        shapeHistory (const ShapeHistoryType& x);

        void
        shapeHistory (::std::unique_ptr< ShapeHistoryType > p);

        // Constructors.
        //
        Project (const AppVersionType&,
                 const FileVersionType&,
                 const ShapeHistoryType&);

        Project (::std::unique_ptr< AppVersionType >,
                 const FileVersionType&,
                 ::std::unique_ptr< ShapeHistoryType >);

        Project (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

        Project (const Project& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

        virtual Project*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        Project&
        operator= (const Project& x);

        virtual 
        ~Project ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< AppVersionType > appVersion_;
        ::xsd::cxx::tree::one< FileVersionType > fileVersion_;
        FeaturesSequence features_;
        StatesSequence states_;
        ConnectionsSequence connections_;
        ExpressionsSequence expressions_;
        ExpressionLinksSequence expressionLinks_;
        ExpressionGroupsSequence expressionGroups_;
        ::xsd::cxx::tree::one< ShapeHistoryType > shapeHistory_;
      };
    }
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace prj
{
  namespace srl
  {
    namespace prjs
    {
      // Parse a URI or a local file.
      //

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (const ::std::string& uri,
               ::xml_schema::Flags f = 0,
               const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (const ::std::string& uri,
               ::xml_schema::ErrorHandler& eh,
               ::xml_schema::Flags f = 0,
               const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (const ::std::string& uri,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::Flags f = 0,
               const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      // Parse std::istream.
      //

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::std::istream& is,
               ::xml_schema::Flags f = 0,
               const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::std::istream& is,
               ::xml_schema::ErrorHandler& eh,
               ::xml_schema::Flags f = 0,
               const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::std::istream& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::Flags f = 0,
               const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::std::istream& is,
               const ::std::string& id,
               ::xml_schema::Flags f = 0,
               const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::std::istream& is,
               const ::std::string& id,
               ::xml_schema::ErrorHandler& eh,
               ::xml_schema::Flags f = 0,
               const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::std::istream& is,
               const ::std::string& id,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::Flags f = 0,
               const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      // Parse xercesc::InputSource.
      //

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::xercesc::InputSource& is,
               ::xml_schema::Flags f = 0,
               const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::xercesc::InputSource& is,
               ::xml_schema::ErrorHandler& eh,
               ::xml_schema::Flags f = 0,
               const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::xercesc::InputSource& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::Flags f = 0,
               const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      // Parse xercesc::DOMDocument.
      //

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (const ::xercesc::DOMDocument& d,
               ::xml_schema::Flags f = 0,
               const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::Flags f = 0,
               const ::xml_schema::Properties& p = ::xml_schema::Properties ());
    }
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace prj
{
  namespace srl
  {
    namespace prjs
    {
      void
      operator<< (::xercesc::DOMElement&, const Feature&);

      void
      operator<< (::xercesc::DOMElement&, const FeatureState&);

      void
      operator<< (::xercesc::DOMElement&, const Connection&);

      void
      operator<< (::xercesc::DOMElement&, const AppVersion&);

      void
      operator<< (::xercesc::DOMElement&, const Expression&);

      void
      operator<< (::xercesc::DOMElement&, const ExpressionLink&);

      void
      operator<< (::xercesc::DOMElement&, const ExpressionGroup&);

      void
      operator<< (::xercesc::DOMElement&, const Project&);

      // Serialize to std::ostream.
      //

      void
      project (::std::ostream& os,
               const ::prj::srl::prjs::Project& x, 
               const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::Flags f = 0);

      void
      project (::std::ostream& os,
               const ::prj::srl::prjs::Project& x, 
               ::xml_schema::ErrorHandler& eh,
               const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::Flags f = 0);

      void
      project (::std::ostream& os,
               const ::prj::srl::prjs::Project& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::Flags f = 0);

      // Serialize to xercesc::XMLFormatTarget.
      //

      void
      project (::xercesc::XMLFormatTarget& ft,
               const ::prj::srl::prjs::Project& x, 
               const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::Flags f = 0);

      void
      project (::xercesc::XMLFormatTarget& ft,
               const ::prj::srl::prjs::Project& x, 
               ::xml_schema::ErrorHandler& eh,
               const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::Flags f = 0);

      void
      project (::xercesc::XMLFormatTarget& ft,
               const ::prj::srl::prjs::Project& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::Flags f = 0);

      // Serialize to an existing xercesc::DOMDocument.
      //

      void
      project (::xercesc::DOMDocument& d,
               const ::prj::srl::prjs::Project& x,
               ::xml_schema::Flags f = 0);

      // Serialize to a new xercesc::DOMDocument.
      //

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
      project (const ::prj::srl::prjs::Project& x, 
               const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
               ::xml_schema::Flags f = 0);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // PRJ_SRL_PRJS_PRJSRLPRJSPROJECT_H
