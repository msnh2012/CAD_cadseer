// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "prjsrlprjsproject.h"

namespace prj
{
  namespace srl
  {
    namespace prjs
    {
      // Feature
      // 

      const Feature::IdType& Feature::
      id () const
      {
        return this->id_.get ();
      }

      Feature::IdType& Feature::
      id ()
      {
        return this->id_.get ();
      }

      void Feature::
      id (const IdType& x)
      {
        this->id_.set (x);
      }

      void Feature::
      id (::std::unique_ptr< IdType > x)
      {
        this->id_.set (std::move (x));
      }

      const Feature::IdType& Feature::
      id_default_value ()
      {
        return id_default_value_;
      }

      const Feature::TypeType& Feature::
      type () const
      {
        return this->type_.get ();
      }

      Feature::TypeType& Feature::
      type ()
      {
        return this->type_.get ();
      }

      void Feature::
      type (const TypeType& x)
      {
        this->type_.set (x);
      }

      void Feature::
      type (::std::unique_ptr< TypeType > x)
      {
        this->type_.set (std::move (x));
      }

      const Feature::TypeType& Feature::
      type_default_value ()
      {
        return type_default_value_;
      }

      const Feature::ShapeOffsetType& Feature::
      shapeOffset () const
      {
        return this->shapeOffset_.get ();
      }

      Feature::ShapeOffsetType& Feature::
      shapeOffset ()
      {
        return this->shapeOffset_.get ();
      }

      void Feature::
      shapeOffset (const ShapeOffsetType& x)
      {
        this->shapeOffset_.set (x);
      }

      Feature::ShapeOffsetType Feature::
      shapeOffset_default_value ()
      {
        return ShapeOffsetType (18446744073709551615ULL);
      }


      // FeatureState
      // 

      const FeatureState::IdType& FeatureState::
      id () const
      {
        return this->id_.get ();
      }

      FeatureState::IdType& FeatureState::
      id ()
      {
        return this->id_.get ();
      }

      void FeatureState::
      id (const IdType& x)
      {
        this->id_.set (x);
      }

      void FeatureState::
      id (::std::unique_ptr< IdType > x)
      {
        this->id_.set (std::move (x));
      }

      const FeatureState::IdType& FeatureState::
      id_default_value ()
      {
        return id_default_value_;
      }

      const FeatureState::StateType& FeatureState::
      state () const
      {
        return this->state_.get ();
      }

      FeatureState::StateType& FeatureState::
      state ()
      {
        return this->state_.get ();
      }

      void FeatureState::
      state (const StateType& x)
      {
        this->state_.set (x);
      }

      void FeatureState::
      state (::std::unique_ptr< StateType > x)
      {
        this->state_.set (std::move (x));
      }


      // Connection
      // 

      const Connection::SourceIdType& Connection::
      sourceId () const
      {
        return this->sourceId_.get ();
      }

      Connection::SourceIdType& Connection::
      sourceId ()
      {
        return this->sourceId_.get ();
      }

      void Connection::
      sourceId (const SourceIdType& x)
      {
        this->sourceId_.set (x);
      }

      void Connection::
      sourceId (::std::unique_ptr< SourceIdType > x)
      {
        this->sourceId_.set (std::move (x));
      }

      const Connection::SourceIdType& Connection::
      sourceId_default_value ()
      {
        return sourceId_default_value_;
      }

      const Connection::TargetIdType& Connection::
      targetId () const
      {
        return this->targetId_.get ();
      }

      Connection::TargetIdType& Connection::
      targetId ()
      {
        return this->targetId_.get ();
      }

      void Connection::
      targetId (const TargetIdType& x)
      {
        this->targetId_.set (x);
      }

      void Connection::
      targetId (::std::unique_ptr< TargetIdType > x)
      {
        this->targetId_.set (std::move (x));
      }

      const Connection::TargetIdType& Connection::
      targetId_default_value ()
      {
        return targetId_default_value_;
      }

      const Connection::InputTypeSequence& Connection::
      inputType () const
      {
        return this->inputType_;
      }

      Connection::InputTypeSequence& Connection::
      inputType ()
      {
        return this->inputType_;
      }

      void Connection::
      inputType (const InputTypeSequence& s)
      {
        this->inputType_ = s;
      }


      // AppVersion
      // 

      const AppVersion::MajorType& AppVersion::
      major () const
      {
        return this->major_.get ();
      }

      AppVersion::MajorType& AppVersion::
      major ()
      {
        return this->major_.get ();
      }

      void AppVersion::
      major (const MajorType& x)
      {
        this->major_.set (x);
      }

      AppVersion::MajorType AppVersion::
      major_default_value ()
      {
        return MajorType (0);
      }

      const AppVersion::MinorType& AppVersion::
      minor () const
      {
        return this->minor_.get ();
      }

      AppVersion::MinorType& AppVersion::
      minor ()
      {
        return this->minor_.get ();
      }

      void AppVersion::
      minor (const MinorType& x)
      {
        this->minor_.set (x);
      }

      AppVersion::MinorType AppVersion::
      minor_default_value ()
      {
        return MinorType (0);
      }

      const AppVersion::MaintenanceType& AppVersion::
      maintenance () const
      {
        return this->maintenance_.get ();
      }

      AppVersion::MaintenanceType& AppVersion::
      maintenance ()
      {
        return this->maintenance_.get ();
      }

      void AppVersion::
      maintenance (const MaintenanceType& x)
      {
        this->maintenance_.set (x);
      }

      AppVersion::MaintenanceType AppVersion::
      maintenance_default_value ()
      {
        return MaintenanceType (0);
      }


      // Expression
      // 

      const Expression::ExpressionsSequence& Expression::
      expressions () const
      {
        return this->expressions_;
      }

      Expression::ExpressionsSequence& Expression::
      expressions ()
      {
        return this->expressions_;
      }

      void Expression::
      expressions (const ExpressionsSequence& s)
      {
        this->expressions_ = s;
      }

      const Expression::GroupsSequence& Expression::
      groups () const
      {
        return this->groups_;
      }

      Expression::GroupsSequence& Expression::
      groups ()
      {
        return this->groups_;
      }

      void Expression::
      groups (const GroupsSequence& s)
      {
        this->groups_ = s;
      }

      const Expression::LinksSequence& Expression::
      links () const
      {
        return this->links_;
      }

      Expression::LinksSequence& Expression::
      links ()
      {
        return this->links_;
      }

      void Expression::
      links (const LinksSequence& s)
      {
        this->links_ = s;
      }


      // Project
      // 

      const Project::AppVersionType& Project::
      appVersion () const
      {
        return this->appVersion_.get ();
      }

      Project::AppVersionType& Project::
      appVersion ()
      {
        return this->appVersion_.get ();
      }

      void Project::
      appVersion (const AppVersionType& x)
      {
        this->appVersion_.set (x);
      }

      void Project::
      appVersion (::std::unique_ptr< AppVersionType > x)
      {
        this->appVersion_.set (std::move (x));
      }

      const Project::FileVersionType& Project::
      fileVersion () const
      {
        return this->fileVersion_.get ();
      }

      Project::FileVersionType& Project::
      fileVersion ()
      {
        return this->fileVersion_.get ();
      }

      void Project::
      fileVersion (const FileVersionType& x)
      {
        this->fileVersion_.set (x);
      }

      Project::FileVersionType Project::
      fileVersion_default_value ()
      {
        return FileVersionType (0);
      }

      const Project::FeaturesSequence& Project::
      features () const
      {
        return this->features_;
      }

      Project::FeaturesSequence& Project::
      features ()
      {
        return this->features_;
      }

      void Project::
      features (const FeaturesSequence& s)
      {
        this->features_ = s;
      }

      const Project::StatesSequence& Project::
      states () const
      {
        return this->states_;
      }

      Project::StatesSequence& Project::
      states ()
      {
        return this->states_;
      }

      void Project::
      states (const StatesSequence& s)
      {
        this->states_ = s;
      }

      const Project::ConnectionsSequence& Project::
      connections () const
      {
        return this->connections_;
      }

      Project::ConnectionsSequence& Project::
      connections ()
      {
        return this->connections_;
      }

      void Project::
      connections (const ConnectionsSequence& s)
      {
        this->connections_ = s;
      }

      const Project::ExpressionType& Project::
      expression () const
      {
        return this->expression_.get ();
      }

      Project::ExpressionType& Project::
      expression ()
      {
        return this->expression_.get ();
      }

      void Project::
      expression (const ExpressionType& x)
      {
        this->expression_.set (x);
      }

      void Project::
      expression (::std::unique_ptr< ExpressionType > x)
      {
        this->expression_.set (std::move (x));
      }


      // Expressions
      // 

      const Expressions::IdType& Expressions::
      id () const
      {
        return this->id_.get ();
      }

      Expressions::IdType& Expressions::
      id ()
      {
        return this->id_.get ();
      }

      void Expressions::
      id (const IdType& x)
      {
        this->id_.set (x);
      }

      const Expressions::StringFormType& Expressions::
      stringForm () const
      {
        return this->stringForm_.get ();
      }

      Expressions::StringFormType& Expressions::
      stringForm ()
      {
        return this->stringForm_.get ();
      }

      void Expressions::
      stringForm (const StringFormType& x)
      {
        this->stringForm_.set (x);
      }

      void Expressions::
      stringForm (::std::unique_ptr< StringFormType > x)
      {
        this->stringForm_.set (std::move (x));
      }


      // Groups
      // 

      const Groups::IdType& Groups::
      id () const
      {
        return this->id_.get ();
      }

      Groups::IdType& Groups::
      id ()
      {
        return this->id_.get ();
      }

      void Groups::
      id (const IdType& x)
      {
        this->id_.set (x);
      }

      const Groups::NameType& Groups::
      name () const
      {
        return this->name_.get ();
      }

      Groups::NameType& Groups::
      name ()
      {
        return this->name_.get ();
      }

      void Groups::
      name (const NameType& x)
      {
        this->name_.set (x);
      }

      void Groups::
      name (::std::unique_ptr< NameType > x)
      {
        this->name_.set (std::move (x));
      }

      const Groups::EntriesSequence& Groups::
      entries () const
      {
        return this->entries_;
      }

      Groups::EntriesSequence& Groups::
      entries ()
      {
        return this->entries_;
      }

      void Groups::
      entries (const EntriesSequence& s)
      {
        this->entries_ = s;
      }


      // Links
      // 

      const Links::ParameterIdType& Links::
      parameterId () const
      {
        return this->parameterId_.get ();
      }

      Links::ParameterIdType& Links::
      parameterId ()
      {
        return this->parameterId_.get ();
      }

      void Links::
      parameterId (const ParameterIdType& x)
      {
        this->parameterId_.set (x);
      }

      void Links::
      parameterId (::std::unique_ptr< ParameterIdType > x)
      {
        this->parameterId_.set (std::move (x));
      }

      const Links::ExpressionIdType& Links::
      expressionId () const
      {
        return this->expressionId_.get ();
      }

      Links::ExpressionIdType& Links::
      expressionId ()
      {
        return this->expressionId_.get ();
      }

      void Links::
      expressionId (const ExpressionIdType& x)
      {
        this->expressionId_.set (x);
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace prjs
    {
      // Feature
      //

      const Feature::IdType Feature::id_default_value_ (
        "00000000-0000-0000-0000-000000000000");

      const Feature::TypeType Feature::type_default_value_ (
        "None");

      Feature::
      Feature (const IdType& id,
               const TypeType& type,
               const ShapeOffsetType& shapeOffset)
      : ::xml_schema::Type (),
        id_ (id, this),
        type_ (type, this),
        shapeOffset_ (shapeOffset, this)
      {
      }

      Feature::
      Feature (const Feature& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        id_ (x.id_, f, this),
        type_ (x.type_, f, this),
        shapeOffset_ (x.shapeOffset_, f, this)
      {
      }

      Feature::
      Feature (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        id_ (this),
        type_ (this),
        shapeOffset_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Feature::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // id
          //
          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< IdType > r (
              IdTraits::create (i, f, this));

            if (!id_.present ())
            {
              this->id_.set (::std::move (r));
              continue;
            }
          }

          // type
          //
          if (n.name () == "type" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< TypeType > r (
              TypeTraits::create (i, f, this));

            if (!type_.present ())
            {
              this->type_.set (::std::move (r));
              continue;
            }
          }

          // shapeOffset
          //
          if (n.name () == "shapeOffset" && n.namespace_ ().empty ())
          {
            if (!shapeOffset_.present ())
            {
              this->shapeOffset_.set (ShapeOffsetTraits::create (i, f, this));
              continue;
            }
          }

          break;
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "id",
            "");
        }

        if (!type_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "type",
            "");
        }

        if (!shapeOffset_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "shapeOffset",
            "");
        }
      }

      Feature* Feature::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Feature (*this, f, c);
      }

      Feature& Feature::
      operator= (const Feature& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->id_ = x.id_;
          this->type_ = x.type_;
          this->shapeOffset_ = x.shapeOffset_;
        }

        return *this;
      }

      Feature::
      ~Feature ()
      {
      }

      // FeatureState
      //

      const FeatureState::IdType FeatureState::id_default_value_ (
        "00000000-0000-0000-0000-000000000000");

      FeatureState::
      FeatureState (const IdType& id,
                    const StateType& state)
      : ::xml_schema::Type (),
        id_ (id, this),
        state_ (state, this)
      {
      }

      FeatureState::
      FeatureState (const FeatureState& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        id_ (x.id_, f, this),
        state_ (x.state_, f, this)
      {
      }

      FeatureState::
      FeatureState (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        id_ (this),
        state_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void FeatureState::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // id
          //
          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< IdType > r (
              IdTraits::create (i, f, this));

            if (!id_.present ())
            {
              this->id_.set (::std::move (r));
              continue;
            }
          }

          // state
          //
          if (n.name () == "state" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< StateType > r (
              StateTraits::create (i, f, this));

            if (!state_.present ())
            {
              this->state_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "id",
            "");
        }

        if (!state_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "state",
            "");
        }
      }

      FeatureState* FeatureState::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class FeatureState (*this, f, c);
      }

      FeatureState& FeatureState::
      operator= (const FeatureState& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->id_ = x.id_;
          this->state_ = x.state_;
        }

        return *this;
      }

      FeatureState::
      ~FeatureState ()
      {
      }

      // Connection
      //

      const Connection::SourceIdType Connection::sourceId_default_value_ (
        "00000000-0000-0000-0000-000000000000");

      const Connection::TargetIdType Connection::targetId_default_value_ (
        "00000000-0000-0000-0000-000000000000");

      Connection::
      Connection (const SourceIdType& sourceId,
                  const TargetIdType& targetId)
      : ::xml_schema::Type (),
        sourceId_ (sourceId, this),
        targetId_ (targetId, this),
        inputType_ (this)
      {
      }

      Connection::
      Connection (const Connection& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        sourceId_ (x.sourceId_, f, this),
        targetId_ (x.targetId_, f, this),
        inputType_ (x.inputType_, f, this)
      {
      }

      Connection::
      Connection (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        sourceId_ (this),
        targetId_ (this),
        inputType_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Connection::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // sourceId
          //
          if (n.name () == "sourceId" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< SourceIdType > r (
              SourceIdTraits::create (i, f, this));

            if (!sourceId_.present ())
            {
              this->sourceId_.set (::std::move (r));
              continue;
            }
          }

          // targetId
          //
          if (n.name () == "targetId" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< TargetIdType > r (
              TargetIdTraits::create (i, f, this));

            if (!targetId_.present ())
            {
              this->targetId_.set (::std::move (r));
              continue;
            }
          }

          // inputType
          //
          if (n.name () == "inputType" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< InputTypeType > r (
              InputTypeTraits::create (i, f, this));

            this->inputType_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        if (!sourceId_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "sourceId",
            "");
        }

        if (!targetId_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "targetId",
            "");
        }
      }

      Connection* Connection::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Connection (*this, f, c);
      }

      Connection& Connection::
      operator= (const Connection& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->sourceId_ = x.sourceId_;
          this->targetId_ = x.targetId_;
          this->inputType_ = x.inputType_;
        }

        return *this;
      }

      Connection::
      ~Connection ()
      {
      }

      // AppVersion
      //

      AppVersion::
      AppVersion (const MajorType& major,
                  const MinorType& minor,
                  const MaintenanceType& maintenance)
      : ::xml_schema::Type (),
        major_ (major, this),
        minor_ (minor, this),
        maintenance_ (maintenance, this)
      {
      }

      AppVersion::
      AppVersion (const AppVersion& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        major_ (x.major_, f, this),
        minor_ (x.minor_, f, this),
        maintenance_ (x.maintenance_, f, this)
      {
      }

      AppVersion::
      AppVersion (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        major_ (this),
        minor_ (this),
        maintenance_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void AppVersion::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // major
          //
          if (n.name () == "major" && n.namespace_ ().empty ())
          {
            if (!major_.present ())
            {
              this->major_.set (MajorTraits::create (i, f, this));
              continue;
            }
          }

          // minor
          //
          if (n.name () == "minor" && n.namespace_ ().empty ())
          {
            if (!minor_.present ())
            {
              this->minor_.set (MinorTraits::create (i, f, this));
              continue;
            }
          }

          // maintenance
          //
          if (n.name () == "maintenance" && n.namespace_ ().empty ())
          {
            if (!maintenance_.present ())
            {
              this->maintenance_.set (MaintenanceTraits::create (i, f, this));
              continue;
            }
          }

          break;
        }

        if (!major_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "major",
            "");
        }

        if (!minor_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "minor",
            "");
        }

        if (!maintenance_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "maintenance",
            "");
        }
      }

      AppVersion* AppVersion::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class AppVersion (*this, f, c);
      }

      AppVersion& AppVersion::
      operator= (const AppVersion& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->major_ = x.major_;
          this->minor_ = x.minor_;
          this->maintenance_ = x.maintenance_;
        }

        return *this;
      }

      AppVersion::
      ~AppVersion ()
      {
      }

      // Expression
      //

      Expression::
      Expression ()
      : ::xml_schema::Type (),
        expressions_ (this),
        groups_ (this),
        links_ (this)
      {
      }

      Expression::
      Expression (const Expression& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        expressions_ (x.expressions_, f, this),
        groups_ (x.groups_, f, this),
        links_ (x.links_, f, this)
      {
      }

      Expression::
      Expression (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        expressions_ (this),
        groups_ (this),
        links_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Expression::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // expressions
          //
          if (n.name () == "expressions" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ExpressionsType > r (
              ExpressionsTraits::create (i, f, this));

            this->expressions_.push_back (::std::move (r));
            continue;
          }

          // groups
          //
          if (n.name () == "groups" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< GroupsType > r (
              GroupsTraits::create (i, f, this));

            this->groups_.push_back (::std::move (r));
            continue;
          }

          // links
          //
          if (n.name () == "links" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< LinksType > r (
              LinksTraits::create (i, f, this));

            this->links_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      Expression* Expression::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Expression (*this, f, c);
      }

      Expression& Expression::
      operator= (const Expression& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->expressions_ = x.expressions_;
          this->groups_ = x.groups_;
          this->links_ = x.links_;
        }

        return *this;
      }

      Expression::
      ~Expression ()
      {
      }

      // Project
      //

      Project::
      Project (const AppVersionType& appVersion,
               const FileVersionType& fileVersion,
               const ExpressionType& expression)
      : ::xml_schema::Type (),
        appVersion_ (appVersion, this),
        fileVersion_ (fileVersion, this),
        features_ (this),
        states_ (this),
        connections_ (this),
        expression_ (expression, this)
      {
      }

      Project::
      Project (::std::unique_ptr< AppVersionType > appVersion,
               const FileVersionType& fileVersion,
               ::std::unique_ptr< ExpressionType > expression)
      : ::xml_schema::Type (),
        appVersion_ (std::move (appVersion), this),
        fileVersion_ (fileVersion, this),
        features_ (this),
        states_ (this),
        connections_ (this),
        expression_ (std::move (expression), this)
      {
      }

      Project::
      Project (const Project& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        appVersion_ (x.appVersion_, f, this),
        fileVersion_ (x.fileVersion_, f, this),
        features_ (x.features_, f, this),
        states_ (x.states_, f, this),
        connections_ (x.connections_, f, this),
        expression_ (x.expression_, f, this)
      {
      }

      Project::
      Project (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        appVersion_ (this),
        fileVersion_ (this),
        features_ (this),
        states_ (this),
        connections_ (this),
        expression_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Project::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // appVersion
          //
          if (n.name () == "appVersion" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< AppVersionType > r (
              AppVersionTraits::create (i, f, this));

            if (!appVersion_.present ())
            {
              this->appVersion_.set (::std::move (r));
              continue;
            }
          }

          // fileVersion
          //
          if (n.name () == "fileVersion" && n.namespace_ ().empty ())
          {
            if (!fileVersion_.present ())
            {
              this->fileVersion_.set (FileVersionTraits::create (i, f, this));
              continue;
            }
          }

          // features
          //
          if (n.name () == "features" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< FeaturesType > r (
              FeaturesTraits::create (i, f, this));

            this->features_.push_back (::std::move (r));
            continue;
          }

          // states
          //
          if (n.name () == "states" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< StatesType > r (
              StatesTraits::create (i, f, this));

            this->states_.push_back (::std::move (r));
            continue;
          }

          // connections
          //
          if (n.name () == "connections" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ConnectionsType > r (
              ConnectionsTraits::create (i, f, this));

            this->connections_.push_back (::std::move (r));
            continue;
          }

          // expression
          //
          if (n.name () == "expression" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ExpressionType > r (
              ExpressionTraits::create (i, f, this));

            if (!expression_.present ())
            {
              this->expression_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!appVersion_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "appVersion",
            "");
        }

        if (!fileVersion_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "fileVersion",
            "");
        }

        if (!expression_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "expression",
            "");
        }
      }

      Project* Project::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Project (*this, f, c);
      }

      Project& Project::
      operator= (const Project& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->appVersion_ = x.appVersion_;
          this->fileVersion_ = x.fileVersion_;
          this->features_ = x.features_;
          this->states_ = x.states_;
          this->connections_ = x.connections_;
          this->expression_ = x.expression_;
        }

        return *this;
      }

      Project::
      ~Project ()
      {
      }

      // Expressions
      //

      Expressions::
      Expressions (const IdType& id,
                   const StringFormType& stringForm)
      : ::xml_schema::Type (),
        id_ (id, this),
        stringForm_ (stringForm, this)
      {
      }

      Expressions::
      Expressions (const Expressions& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        id_ (x.id_, f, this),
        stringForm_ (x.stringForm_, f, this)
      {
      }

      Expressions::
      Expressions (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        id_ (this),
        stringForm_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Expressions::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // id
          //
          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            if (!id_.present ())
            {
              this->id_.set (IdTraits::create (i, f, this));
              continue;
            }
          }

          // stringForm
          //
          if (n.name () == "stringForm" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< StringFormType > r (
              StringFormTraits::create (i, f, this));

            if (!stringForm_.present ())
            {
              this->stringForm_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "id",
            "");
        }

        if (!stringForm_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "stringForm",
            "");
        }
      }

      Expressions* Expressions::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Expressions (*this, f, c);
      }

      Expressions& Expressions::
      operator= (const Expressions& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->id_ = x.id_;
          this->stringForm_ = x.stringForm_;
        }

        return *this;
      }

      Expressions::
      ~Expressions ()
      {
      }

      // Groups
      //

      Groups::
      Groups (const IdType& id,
              const NameType& name)
      : ::xml_schema::Type (),
        id_ (id, this),
        name_ (name, this),
        entries_ (this)
      {
      }

      Groups::
      Groups (const Groups& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        id_ (x.id_, f, this),
        name_ (x.name_, f, this),
        entries_ (x.entries_, f, this)
      {
      }

      Groups::
      Groups (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        id_ (this),
        name_ (this),
        entries_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Groups::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // id
          //
          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            if (!id_.present ())
            {
              this->id_.set (IdTraits::create (i, f, this));
              continue;
            }
          }

          // name
          //
          if (n.name () == "name" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< NameType > r (
              NameTraits::create (i, f, this));

            if (!name_.present ())
            {
              this->name_.set (::std::move (r));
              continue;
            }
          }

          // entries
          //
          if (n.name () == "entries" && n.namespace_ ().empty ())
          {
            this->entries_.push_back (EntriesTraits::create (i, f, this));
            continue;
          }

          break;
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "id",
            "");
        }

        if (!name_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "name",
            "");
        }
      }

      Groups* Groups::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Groups (*this, f, c);
      }

      Groups& Groups::
      operator= (const Groups& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->id_ = x.id_;
          this->name_ = x.name_;
          this->entries_ = x.entries_;
        }

        return *this;
      }

      Groups::
      ~Groups ()
      {
      }

      // Links
      //

      Links::
      Links (const ParameterIdType& parameterId,
             const ExpressionIdType& expressionId)
      : ::xml_schema::Type (),
        parameterId_ (parameterId, this),
        expressionId_ (expressionId, this)
      {
      }

      Links::
      Links (const Links& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        parameterId_ (x.parameterId_, f, this),
        expressionId_ (x.expressionId_, f, this)
      {
      }

      Links::
      Links (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        parameterId_ (this),
        expressionId_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Links::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // parameterId
          //
          if (n.name () == "parameterId" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ParameterIdType > r (
              ParameterIdTraits::create (i, f, this));

            if (!parameterId_.present ())
            {
              this->parameterId_.set (::std::move (r));
              continue;
            }
          }

          // expressionId
          //
          if (n.name () == "expressionId" && n.namespace_ ().empty ())
          {
            if (!expressionId_.present ())
            {
              this->expressionId_.set (ExpressionIdTraits::create (i, f, this));
              continue;
            }
          }

          break;
        }

        if (!parameterId_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "parameterId",
            "");
        }

        if (!expressionId_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "expressionId",
            "");
        }
      }

      Links* Links::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Links (*this, f, c);
      }

      Links& Links::
      operator= (const Links& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->parameterId_ = x.parameterId_;
          this->expressionId_ = x.expressionId_;
        }

        return *this;
      }

      Links::
      ~Links ()
      {
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace prj
{
  namespace srl
  {
    namespace prjs
    {
      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (const ::std::string& u,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::prj::srl::prjs::Project > (
          ::prj::srl::prjs::project (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (const ::std::string& u,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::prj::srl::prjs::Project > (
          ::prj::srl::prjs::project (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::prj::srl::prjs::Project > (
          ::prj::srl::prjs::project (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::std::istream& is,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::prj::srl::prjs::project (isrc, f, p);
      }

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::std::istream& is,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::prj::srl::prjs::project (isrc, h, f, p);
      }

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::prj::srl::prjs::project (isrc, h, f, p);
      }

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::prj::srl::prjs::project (isrc, f, p);
      }

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::prj::srl::prjs::project (isrc, h, f, p);
      }

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::prj::srl::prjs::project (isrc, h, f, p);
      }

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::xercesc::InputSource& i,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::prj::srl::prjs::Project > (
          ::prj::srl::prjs::project (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::xercesc::InputSource& i,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::prj::srl::prjs::Project > (
          ::prj::srl::prjs::project (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::prj::srl::prjs::Project > (
          ::prj::srl::prjs::project (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (const ::xercesc::DOMDocument& doc,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
      {
        if (f & ::xml_schema::Flags::keep_dom)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::prj::srl::prjs::Project > (
            ::prj::srl::prjs::project (
              std::move (d), f | ::xml_schema::Flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "project" &&
            n.namespace_ () == "http://www.cadseer.com/prj/srl/prjs")
        {
          ::std::unique_ptr< ::prj::srl::prjs::Project > r (
            ::xsd::cxx::tree::traits< ::prj::srl::prjs::Project, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "project",
          "http://www.cadseer.com/prj/srl/prjs");
      }

      ::std::unique_ptr< ::prj::srl::prjs::Project >
      project (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties&)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::xml_schema::Flags::keep_dom) &&
           !(f & ::xml_schema::Flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::xml_schema::Flags::keep_dom)
          doc.setUserData (::xml_schema::dom::tree_node_key,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "project" &&
            n.namespace_ () == "http://www.cadseer.com/prj/srl/prjs")
        {
          ::std::unique_ptr< ::prj::srl::prjs::Project > r (
            ::xsd::cxx::tree::traits< ::prj::srl::prjs::Project, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "project",
          "http://www.cadseer.com/prj/srl/prjs");
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace prjs
    {
      void
      operator<< (::xercesc::DOMElement& e, const Feature& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // id
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << i.id ();
        }

        // type
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "type",
              e));

          s << i.type ();
        }

        // shapeOffset
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "shapeOffset",
              e));

          s << i.shapeOffset ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const FeatureState& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // id
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << i.id ();
        }

        // state
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "state",
              e));

          s << i.state ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Connection& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // sourceId
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "sourceId",
              e));

          s << i.sourceId ();
        }

        // targetId
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "targetId",
              e));

          s << i.targetId ();
        }

        // inputType
        //
        for (Connection::InputTypeConstIterator
             b (i.inputType ().begin ()), n (i.inputType ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "inputType",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const AppVersion& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // major
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "major",
              e));

          s << i.major ();
        }

        // minor
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "minor",
              e));

          s << i.minor ();
        }

        // maintenance
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "maintenance",
              e));

          s << i.maintenance ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Expression& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // expressions
        //
        for (Expression::ExpressionsConstIterator
             b (i.expressions ().begin ()), n (i.expressions ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "expressions",
              e));

          s << *b;
        }

        // groups
        //
        for (Expression::GroupsConstIterator
             b (i.groups ().begin ()), n (i.groups ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "groups",
              e));

          s << *b;
        }

        // links
        //
        for (Expression::LinksConstIterator
             b (i.links ().begin ()), n (i.links ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "links",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Project& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // appVersion
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "appVersion",
              e));

          s << i.appVersion ();
        }

        // fileVersion
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "fileVersion",
              e));

          s << i.fileVersion ();
        }

        // features
        //
        for (Project::FeaturesConstIterator
             b (i.features ().begin ()), n (i.features ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "features",
              e));

          s << *b;
        }

        // states
        //
        for (Project::StatesConstIterator
             b (i.states ().begin ()), n (i.states ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "states",
              e));

          s << *b;
        }

        // connections
        //
        for (Project::ConnectionsConstIterator
             b (i.connections ().begin ()), n (i.connections ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "connections",
              e));

          s << *b;
        }

        // expression
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "expression",
              e));

          s << i.expression ();
        }
      }

      void
      project (::std::ostream& o,
               const ::prj::srl::prjs::Project& s,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::prjs::project (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      project (::std::ostream& o,
               const ::prj::srl::prjs::Project& s,
               ::xml_schema::ErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::prjs::project (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      project (::std::ostream& o,
               const ::prj::srl::prjs::Project& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::prjs::project (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      project (::xercesc::XMLFormatTarget& t,
               const ::prj::srl::prjs::Project& s,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::prjs::project (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      project (::xercesc::XMLFormatTarget& t,
               const ::prj::srl::prjs::Project& s,
               ::xml_schema::ErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::prjs::project (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      project (::xercesc::XMLFormatTarget& t,
               const ::prj::srl::prjs::Project& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::prjs::project (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      project (::xercesc::DOMDocument& d,
               const ::prj::srl::prjs::Project& s,
               ::xml_schema::Flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "project" &&
            n.namespace_ () == "http://www.cadseer.com/prj/srl/prjs")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "project",
            "http://www.cadseer.com/prj/srl/prjs");
        }
      }

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
      project (const ::prj::srl::prjs::Project& s,
               const ::xml_schema::NamespaceInfomap& m,
               ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "project",
            "http://www.cadseer.com/prj/srl/prjs",
            m, f));

        ::prj::srl::prjs::project (*d, s, f);
        return d;
      }

      void
      operator<< (::xercesc::DOMElement& e, const Expressions& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // id
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << i.id ();
        }

        // stringForm
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "stringForm",
              e));

          s << i.stringForm ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Groups& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // id
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << i.id ();
        }

        // name
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "name",
              e));

          s << i.name ();
        }

        // entries
        //
        for (Groups::EntriesConstIterator
             b (i.entries ().begin ()), n (i.entries ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "entries",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Links& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // parameterId
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "parameterId",
              e));

          s << i.parameterId ();
        }

        // expressionId
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "expressionId",
              e));

          s << i.expressionId ();
        }
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

