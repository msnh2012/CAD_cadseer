// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "prjsrllwsplawspine.h"

namespace prj
{
  namespace srl
  {
    namespace lwsp
    {
      // GraphNode
      // 

      const GraphNode::ParameterType& GraphNode::
      parameter () const
      {
        return this->parameter_.get ();
      }

      GraphNode::ParameterType& GraphNode::
      parameter ()
      {
        return this->parameter_.get ();
      }

      void GraphNode::
      parameter (const ParameterType& x)
      {
        this->parameter_.set (x);
      }

      void GraphNode::
      parameter (::std::unique_ptr< ParameterType > x)
      {
        this->parameter_.set (std::move (x));
      }

      const GraphNode::PLabelOptional& GraphNode::
      pLabel () const
      {
        return this->pLabel_;
      }

      GraphNode::PLabelOptional& GraphNode::
      pLabel ()
      {
        return this->pLabel_;
      }

      void GraphNode::
      pLabel (const PLabelType& x)
      {
        this->pLabel_.set (x);
      }

      void GraphNode::
      pLabel (const PLabelOptional& x)
      {
        this->pLabel_ = x;
      }

      void GraphNode::
      pLabel (::std::unique_ptr< PLabelType > x)
      {
        this->pLabel_.set (std::move (x));
      }

      const GraphNode::LocationOptional& GraphNode::
      location () const
      {
        return this->location_;
      }

      GraphNode::LocationOptional& GraphNode::
      location ()
      {
        return this->location_;
      }

      void GraphNode::
      location (const LocationType& x)
      {
        this->location_.set (x);
      }

      void GraphNode::
      location (const LocationOptional& x)
      {
        this->location_ = x;
      }

      void GraphNode::
      location (::std::unique_ptr< LocationType > x)
      {
        this->location_.set (std::move (x));
      }


      // GraphEdge
      // 

      const GraphEdge::SourceType& GraphEdge::
      source () const
      {
        return this->source_.get ();
      }

      GraphEdge::SourceType& GraphEdge::
      source ()
      {
        return this->source_.get ();
      }

      void GraphEdge::
      source (const SourceType& x)
      {
        this->source_.set (x);
      }

      const GraphEdge::TargetType& GraphEdge::
      target () const
      {
        return this->target_.get ();
      }

      GraphEdge::TargetType& GraphEdge::
      target ()
      {
        return this->target_.get ();
      }

      void GraphEdge::
      target (const TargetType& x)
      {
        this->target_.set (x);
      }

      const GraphEdge::MaskType& GraphEdge::
      mask () const
      {
        return this->mask_.get ();
      }

      GraphEdge::MaskType& GraphEdge::
      mask ()
      {
        return this->mask_.get ();
      }

      void GraphEdge::
      mask (const MaskType& x)
      {
        this->mask_.set (x);
      }


      // Graph
      // 

      const Graph::NodesSequence& Graph::
      nodes () const
      {
        return this->nodes_;
      }

      Graph::NodesSequence& Graph::
      nodes ()
      {
        return this->nodes_;
      }

      void Graph::
      nodes (const NodesSequence& s)
      {
        this->nodes_ = s;
      }

      const Graph::EdgesSequence& Graph::
      edges () const
      {
        return this->edges_;
      }

      Graph::EdgesSequence& Graph::
      edges ()
      {
        return this->edges_;
      }

      void Graph::
      edges (const EdgesSequence& s)
      {
        this->edges_ = s;
      }


      // Vessel
      // 

      const Vessel::PeriodicType& Vessel::
      periodic () const
      {
        return this->periodic_.get ();
      }

      Vessel::PeriodicType& Vessel::
      periodic ()
      {
        return this->periodic_.get ();
      }

      void Vessel::
      periodic (const PeriodicType& x)
      {
        this->periodic_.set (x);
      }

      const Vessel::StateType& Vessel::
      state () const
      {
        return this->state_.get ();
      }

      Vessel::StateType& Vessel::
      state ()
      {
        return this->state_.get ();
      }

      void Vessel::
      state (const StateType& x)
      {
        this->state_.set (x);
      }

      const Vessel::GraphType& Vessel::
      graph () const
      {
        return this->graph_.get ();
      }

      Vessel::GraphType& Vessel::
      graph ()
      {
        return this->graph_.get ();
      }

      void Vessel::
      graph (const GraphType& x)
      {
        this->graph_.set (x);
      }

      void Vessel::
      graph (::std::unique_ptr< GraphType > x)
      {
        this->graph_.set (std::move (x));
      }

      const Vessel::LawsSequence& Vessel::
      laws () const
      {
        return this->laws_;
      }

      Vessel::LawsSequence& Vessel::
      laws ()
      {
        return this->laws_;
      }

      void Vessel::
      laws (const LawsSequence& s)
      {
        this->laws_ = s;
      }


      // LawSpine
      // 

      const LawSpine::BaseType& LawSpine::
      base () const
      {
        return this->base_.get ();
      }

      LawSpine::BaseType& LawSpine::
      base ()
      {
        return this->base_.get ();
      }

      void LawSpine::
      base (const BaseType& x)
      {
        this->base_.set (x);
      }

      void LawSpine::
      base (::std::unique_ptr< BaseType > x)
      {
        this->base_.set (std::move (x));
      }

      const LawSpine::SeerShapeType& LawSpine::
      seerShape () const
      {
        return this->seerShape_.get ();
      }

      LawSpine::SeerShapeType& LawSpine::
      seerShape ()
      {
        return this->seerShape_.get ();
      }

      void LawSpine::
      seerShape (const SeerShapeType& x)
      {
        this->seerShape_.set (x);
      }

      void LawSpine::
      seerShape (::std::unique_ptr< SeerShapeType > x)
      {
        this->seerShape_.set (std::move (x));
      }

      const LawSpine::SpinePickType& LawSpine::
      spinePick () const
      {
        return this->spinePick_.get ();
      }

      LawSpine::SpinePickType& LawSpine::
      spinePick ()
      {
        return this->spinePick_.get ();
      }

      void LawSpine::
      spinePick (const SpinePickType& x)
      {
        this->spinePick_.set (x);
      }

      void LawSpine::
      spinePick (::std::unique_ptr< SpinePickType > x)
      {
        this->spinePick_.set (std::move (x));
      }

      const LawSpine::VesselType& LawSpine::
      vessel () const
      {
        return this->vessel_.get ();
      }

      LawSpine::VesselType& LawSpine::
      vessel ()
      {
        return this->vessel_.get ();
      }

      void LawSpine::
      vessel (const VesselType& x)
      {
        this->vessel_.set (x);
      }

      void LawSpine::
      vessel (::std::unique_ptr< VesselType > x)
      {
        this->vessel_.set (std::move (x));
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace lwsp
    {
      // GraphNode
      //

      GraphNode::
      GraphNode (const ParameterType& parameter)
      : ::xml_schema::Type (),
        parameter_ (parameter, this),
        pLabel_ (this),
        location_ (this)
      {
      }

      GraphNode::
      GraphNode (::std::unique_ptr< ParameterType > parameter)
      : ::xml_schema::Type (),
        parameter_ (std::move (parameter), this),
        pLabel_ (this),
        location_ (this)
      {
      }

      GraphNode::
      GraphNode (const GraphNode& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        parameter_ (x.parameter_, f, this),
        pLabel_ (x.pLabel_, f, this),
        location_ (x.location_, f, this)
      {
      }

      GraphNode::
      GraphNode (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        parameter_ (this),
        pLabel_ (this),
        location_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void GraphNode::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // parameter
          //
          if (n.name () == "parameter" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< ParameterType > r (
              ParameterTraits::create (i, f, this));

            if (!parameter_.present ())
            {
              this->parameter_.set (::std::move (r));
              continue;
            }
          }

          // pLabel
          //
          if (n.name () == "pLabel" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< PLabelType > r (
              PLabelTraits::create (i, f, this));

            if (!this->pLabel_)
            {
              this->pLabel_.set (::std::move (r));
              continue;
            }
          }

          // location
          //
          if (n.name () == "location" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< LocationType > r (
              LocationTraits::create (i, f, this));

            if (!this->location_)
            {
              this->location_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!parameter_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "parameter",
            "");
        }
      }

      GraphNode* GraphNode::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class GraphNode (*this, f, c);
      }

      GraphNode& GraphNode::
      operator= (const GraphNode& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->parameter_ = x.parameter_;
          this->pLabel_ = x.pLabel_;
          this->location_ = x.location_;
        }

        return *this;
      }

      GraphNode::
      ~GraphNode ()
      {
      }

      // GraphEdge
      //

      GraphEdge::
      GraphEdge (const SourceType& source,
                 const TargetType& target,
                 const MaskType& mask)
      : ::xml_schema::Type (),
        source_ (source, this),
        target_ (target, this),
        mask_ (mask, this)
      {
      }

      GraphEdge::
      GraphEdge (const GraphEdge& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        source_ (x.source_, f, this),
        target_ (x.target_, f, this),
        mask_ (x.mask_, f, this)
      {
      }

      GraphEdge::
      GraphEdge (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        source_ (this),
        target_ (this),
        mask_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void GraphEdge::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // source
          //
          if (n.name () == "source" && n.namespace_ ().empty ())
          {
            if (!source_.present ())
            {
              this->source_.set (SourceTraits::create (i, f, this));
              continue;
            }
          }

          // target
          //
          if (n.name () == "target" && n.namespace_ ().empty ())
          {
            if (!target_.present ())
            {
              this->target_.set (TargetTraits::create (i, f, this));
              continue;
            }
          }

          // mask
          //
          if (n.name () == "mask" && n.namespace_ ().empty ())
          {
            if (!mask_.present ())
            {
              this->mask_.set (MaskTraits::create (i, f, this));
              continue;
            }
          }

          break;
        }

        if (!source_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "source",
            "");
        }

        if (!target_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "target",
            "");
        }

        if (!mask_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "mask",
            "");
        }
      }

      GraphEdge* GraphEdge::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class GraphEdge (*this, f, c);
      }

      GraphEdge& GraphEdge::
      operator= (const GraphEdge& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->source_ = x.source_;
          this->target_ = x.target_;
          this->mask_ = x.mask_;
        }

        return *this;
      }

      GraphEdge::
      ~GraphEdge ()
      {
      }

      // Graph
      //

      Graph::
      Graph ()
      : ::xml_schema::Type (),
        nodes_ (this),
        edges_ (this)
      {
      }

      Graph::
      Graph (const Graph& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        nodes_ (x.nodes_, f, this),
        edges_ (x.edges_, f, this)
      {
      }

      Graph::
      Graph (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        nodes_ (this),
        edges_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Graph::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // nodes
          //
          if (n.name () == "nodes" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< NodesType > r (
              NodesTraits::create (i, f, this));

            this->nodes_.push_back (::std::move (r));
            continue;
          }

          // edges
          //
          if (n.name () == "edges" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< EdgesType > r (
              EdgesTraits::create (i, f, this));

            this->edges_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      Graph* Graph::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Graph (*this, f, c);
      }

      Graph& Graph::
      operator= (const Graph& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->nodes_ = x.nodes_;
          this->edges_ = x.edges_;
        }

        return *this;
      }

      Graph::
      ~Graph ()
      {
      }

      // Vessel
      //

      Vessel::
      Vessel (const PeriodicType& periodic,
              const StateType& state,
              const GraphType& graph)
      : ::xml_schema::Type (),
        periodic_ (periodic, this),
        state_ (state, this),
        graph_ (graph, this),
        laws_ (this)
      {
      }

      Vessel::
      Vessel (const PeriodicType& periodic,
              const StateType& state,
              ::std::unique_ptr< GraphType > graph)
      : ::xml_schema::Type (),
        periodic_ (periodic, this),
        state_ (state, this),
        graph_ (std::move (graph), this),
        laws_ (this)
      {
      }

      Vessel::
      Vessel (const Vessel& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        periodic_ (x.periodic_, f, this),
        state_ (x.state_, f, this),
        graph_ (x.graph_, f, this),
        laws_ (x.laws_, f, this)
      {
      }

      Vessel::
      Vessel (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        periodic_ (this),
        state_ (this),
        graph_ (this),
        laws_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void Vessel::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // periodic
          //
          if (n.name () == "periodic" && n.namespace_ ().empty ())
          {
            if (!periodic_.present ())
            {
              this->periodic_.set (PeriodicTraits::create (i, f, this));
              continue;
            }
          }

          // state
          //
          if (n.name () == "state" && n.namespace_ ().empty ())
          {
            if (!state_.present ())
            {
              this->state_.set (StateTraits::create (i, f, this));
              continue;
            }
          }

          // graph
          //
          if (n.name () == "graph" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< GraphType > r (
              GraphTraits::create (i, f, this));

            if (!graph_.present ())
            {
              this->graph_.set (::std::move (r));
              continue;
            }
          }

          // laws
          //
          if (n.name () == "laws" && n.namespace_ ().empty ())
          {
            this->laws_.push_back (LawsTraits::create (i, f, this));
            continue;
          }

          break;
        }

        if (!periodic_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "periodic",
            "");
        }

        if (!state_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "state",
            "");
        }

        if (!graph_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "graph",
            "");
        }
      }

      Vessel* Vessel::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class Vessel (*this, f, c);
      }

      Vessel& Vessel::
      operator= (const Vessel& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->periodic_ = x.periodic_;
          this->state_ = x.state_;
          this->graph_ = x.graph_;
          this->laws_ = x.laws_;
        }

        return *this;
      }

      Vessel::
      ~Vessel ()
      {
      }

      // LawSpine
      //

      LawSpine::
      LawSpine (const BaseType& base,
                const SeerShapeType& seerShape,
                const SpinePickType& spinePick,
                const VesselType& vessel)
      : ::xml_schema::Type (),
        base_ (base, this),
        seerShape_ (seerShape, this),
        spinePick_ (spinePick, this),
        vessel_ (vessel, this)
      {
      }

      LawSpine::
      LawSpine (::std::unique_ptr< BaseType > base,
                ::std::unique_ptr< SeerShapeType > seerShape,
                ::std::unique_ptr< SpinePickType > spinePick,
                ::std::unique_ptr< VesselType > vessel)
      : ::xml_schema::Type (),
        base_ (std::move (base), this),
        seerShape_ (std::move (seerShape), this),
        spinePick_ (std::move (spinePick), this),
        vessel_ (std::move (vessel), this)
      {
      }

      LawSpine::
      LawSpine (const LawSpine& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        base_ (x.base_, f, this),
        seerShape_ (x.seerShape_, f, this),
        spinePick_ (x.spinePick_, f, this),
        vessel_ (x.vessel_, f, this)
      {
      }

      LawSpine::
      LawSpine (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        base_ (this),
        seerShape_ (this),
        spinePick_ (this),
        vessel_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void LawSpine::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // base
          //
          if (n.name () == "base" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< BaseType > r (
              BaseTraits::create (i, f, this));

            if (!base_.present ())
            {
              this->base_.set (::std::move (r));
              continue;
            }
          }

          // seerShape
          //
          if (n.name () == "seerShape" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< SeerShapeType > r (
              SeerShapeTraits::create (i, f, this));

            if (!seerShape_.present ())
            {
              this->seerShape_.set (::std::move (r));
              continue;
            }
          }

          // spinePick
          //
          if (n.name () == "spinePick" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< SpinePickType > r (
              SpinePickTraits::create (i, f, this));

            if (!spinePick_.present ())
            {
              this->spinePick_.set (::std::move (r));
              continue;
            }
          }

          // vessel
          //
          if (n.name () == "vessel" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< VesselType > r (
              VesselTraits::create (i, f, this));

            if (!vessel_.present ())
            {
              this->vessel_.set (::std::move (r));
              continue;
            }
          }

          break;
        }

        if (!base_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "base",
            "");
        }

        if (!seerShape_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "seerShape",
            "");
        }

        if (!spinePick_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "spinePick",
            "");
        }

        if (!vessel_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "vessel",
            "");
        }
      }

      LawSpine* LawSpine::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class LawSpine (*this, f, c);
      }

      LawSpine& LawSpine::
      operator= (const LawSpine& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->base_ = x.base_;
          this->seerShape_ = x.seerShape_;
          this->spinePick_ = x.spinePick_;
          this->vessel_ = x.vessel_;
        }

        return *this;
      }

      LawSpine::
      ~LawSpine ()
      {
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace prj
{
  namespace srl
  {
    namespace lwsp
    {
      ::std::unique_ptr< ::prj::srl::lwsp::LawSpine >
      lawspine (const ::std::string& u,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::tree::error_handler< char > h;

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::prj::srl::lwsp::LawSpine > (
          ::prj::srl::lwsp::lawspine (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::lwsp::LawSpine >
      lawspine (const ::std::string& u,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::prj::srl::lwsp::LawSpine > (
          ::prj::srl::lwsp::lawspine (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::lwsp::LawSpine >
      lawspine (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            u, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::prj::srl::lwsp::LawSpine > (
          ::prj::srl::lwsp::lawspine (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::lwsp::LawSpine >
      lawspine (::std::istream& is,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::prj::srl::lwsp::lawspine (isrc, f, p);
      }

      ::std::unique_ptr< ::prj::srl::lwsp::LawSpine >
      lawspine (::std::istream& is,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::prj::srl::lwsp::lawspine (isrc, h, f, p);
      }

      ::std::unique_ptr< ::prj::srl::lwsp::LawSpine >
      lawspine (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is);
        return ::prj::srl::lwsp::lawspine (isrc, h, f, p);
      }

      ::std::unique_ptr< ::prj::srl::lwsp::LawSpine >
      lawspine (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::prj::srl::lwsp::lawspine (isrc, f, p);
      }

      ::std::unique_ptr< ::prj::srl::lwsp::LawSpine >
      lawspine (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0,
          (f & ::xml_schema::Flags::keep_dom) == 0);

        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::prj::srl::lwsp::lawspine (isrc, h, f, p);
      }

      ::std::unique_ptr< ::prj::srl::lwsp::LawSpine >
      lawspine (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
        return ::prj::srl::lwsp::lawspine (isrc, h, f, p);
      }

      ::std::unique_ptr< ::prj::srl::lwsp::LawSpine >
      lawspine (::xercesc::InputSource& i,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
      {
        ::xsd::cxx::tree::error_handler< char > h;

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

        return ::std::unique_ptr< ::prj::srl::lwsp::LawSpine > (
          ::prj::srl::lwsp::lawspine (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::lwsp::LawSpine >
      lawspine (::xercesc::InputSource& i,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::prj::srl::lwsp::LawSpine > (
          ::prj::srl::lwsp::lawspine (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::lwsp::LawSpine >
      lawspine (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::parse< char > (
            i, h, p, f));

        if (!d.get ())
          throw ::xsd::cxx::tree::parsing< char > ();

        return ::std::unique_ptr< ::prj::srl::lwsp::LawSpine > (
          ::prj::srl::lwsp::lawspine (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      ::std::unique_ptr< ::prj::srl::lwsp::LawSpine >
      lawspine (const ::xercesc::DOMDocument& doc,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
      {
        if (f & ::xml_schema::Flags::keep_dom)
        {
          ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
            static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

          return ::std::unique_ptr< ::prj::srl::lwsp::LawSpine > (
            ::prj::srl::lwsp::lawspine (
              std::move (d), f | ::xml_schema::Flags::own_dom, p));
        }

        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "lawspine" &&
            n.namespace_ () == "http://www.cadseer.com/prj/srl/lwsp")
        {
          ::std::unique_ptr< ::prj::srl::lwsp::LawSpine > r (
            ::xsd::cxx::tree::traits< ::prj::srl::lwsp::LawSpine, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "lawspine",
          "http://www.cadseer.com/prj/srl/lwsp");
      }

      ::std::unique_ptr< ::prj::srl::lwsp::LawSpine >
      lawspine (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties&)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
          ((f & ::xml_schema::Flags::keep_dom) &&
           !(f & ::xml_schema::Flags::own_dom))
          ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
          : 0);

        ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
        const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (f & ::xml_schema::Flags::keep_dom)
          doc.setUserData (::xml_schema::dom::tree_node_key,
                           (c.get () ? &c : &d),
                           0);

        if (n.name () == "lawspine" &&
            n.namespace_ () == "http://www.cadseer.com/prj/srl/lwsp")
        {
          ::std::unique_ptr< ::prj::srl::lwsp::LawSpine > r (
            ::xsd::cxx::tree::traits< ::prj::srl::lwsp::LawSpine, char >::create (
              e, f, 0));
          return r;
        }

        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "lawspine",
          "http://www.cadseer.com/prj/srl/lwsp");
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace lwsp
    {
      void
      operator<< (::xercesc::DOMElement& e, const GraphNode& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // parameter
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "parameter",
              e));

          s << i.parameter ();
        }

        // pLabel
        //
        if (i.pLabel ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "pLabel",
              e));

          s << *i.pLabel ();
        }

        // location
        //
        if (i.location ())
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "location",
              e));

          s << *i.location ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const GraphEdge& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // source
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "source",
              e));

          s << i.source ();
        }

        // target
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "target",
              e));

          s << i.target ();
        }

        // mask
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "mask",
              e));

          s << i.mask ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Graph& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // nodes
        //
        for (Graph::NodesConstIterator
             b (i.nodes ().begin ()), n (i.nodes ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "nodes",
              e));

          s << *b;
        }

        // edges
        //
        for (Graph::EdgesConstIterator
             b (i.edges ().begin ()), n (i.edges ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "edges",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const Vessel& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // periodic
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "periodic",
              e));

          s << i.periodic ();
        }

        // state
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "state",
              e));

          s << i.state ();
        }

        // graph
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "graph",
              e));

          s << i.graph ();
        }

        // laws
        //
        for (Vessel::LawsConstIterator
             b (i.laws ().begin ()), n (i.laws ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "laws",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const LawSpine& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // base
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "base",
              e));

          s << i.base ();
        }

        // seerShape
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "seerShape",
              e));

          s << i.seerShape ();
        }

        // spinePick
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "spinePick",
              e));

          s << i.spinePick ();
        }

        // vessel
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "vessel",
              e));

          s << i.vessel ();
        }
      }

      void
      lawspine (::std::ostream& o,
                const ::prj::srl::lwsp::LawSpine& s,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::lwsp::lawspine (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      lawspine (::std::ostream& o,
                const ::prj::srl::lwsp::LawSpine& s,
                ::xml_schema::ErrorHandler& h,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
      {
        ::xsd::cxx::xml::auto_initializer i (
          (f & ::xml_schema::Flags::dont_initialize) == 0);

        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::lwsp::lawspine (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      lawspine (::std::ostream& o,
                const ::prj::srl::lwsp::LawSpine& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::lwsp::lawspine (s, m, f));
        ::xsd::cxx::xml::dom::ostream_format_target t (o);
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      lawspine (::xercesc::XMLFormatTarget& t,
                const ::prj::srl::lwsp::LawSpine& s,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::lwsp::lawspine (s, m, f));

        ::xsd::cxx::tree::error_handler< char > h;

        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
        }
      }

      void
      lawspine (::xercesc::XMLFormatTarget& t,
                const ::prj::srl::lwsp::LawSpine& s,
                ::xml_schema::ErrorHandler& h,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::lwsp::lawspine (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      lawspine (::xercesc::XMLFormatTarget& t,
                const ::prj::srl::lwsp::LawSpine& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::prj::srl::lwsp::lawspine (s, m, f));
        if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
        {
          throw ::xsd::cxx::tree::serialization< char > ();
        }
      }

      void
      lawspine (::xercesc::DOMDocument& d,
                const ::prj::srl::lwsp::LawSpine& s,
                ::xml_schema::Flags)
      {
        ::xercesc::DOMElement& e (*d.getDocumentElement ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (e));

        if (n.name () == "lawspine" &&
            n.namespace_ () == "http://www.cadseer.com/prj/srl/lwsp")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "lawspine",
            "http://www.cadseer.com/prj/srl/lwsp");
        }
      }

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
      lawspine (const ::prj::srl::lwsp::LawSpine& s,
                const ::xml_schema::NamespaceInfomap& m,
                ::xml_schema::Flags f)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          ::xsd::cxx::xml::dom::serialize< char > (
            "lawspine",
            "http://www.cadseer.com/prj/srl/lwsp",
            m, f));

        ::prj::srl::lwsp::lawspine (*d, s, f);
        return d;
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

