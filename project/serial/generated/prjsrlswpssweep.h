// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef PRJ_SRL_SWPS_PRJSRLSWPSSWEEP_H
#define PRJ_SRL_SWPS_PRJSRLSWPSSWEEP_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include "../../../xmlbase.h"

// Forward declarations.
//
namespace prj
{
  namespace srl
  {
    namespace swps
    {
      class SweepProfile;
      class SweepAuxiliary;
      class SweepBinormal;
      class Instance;
      class Sweep;
    }
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "prjsrlsptseershape.h"

#include "prjsrlsptparameter.h"

#include "prjsrlsptoverlay.h"

#include "prjsrllwfslawfunction.h"

#include "prjsrlsptbase.h"

namespace prj
{
  namespace srl
  {
    namespace swps
    {
      class SweepProfile: public ::xml_schema::Type
      {
        public:
        // pick
        //
        typedef ::prj::srl::spt::Parameter PickType;
        typedef ::xsd::cxx::tree::traits< PickType, char > PickTraits;

        const PickType&
        pick () const;

        PickType&
        pick ();

        void
        pick (const PickType& x);

        void
        pick (::std::unique_ptr< PickType > p);

        // contact
        //
        typedef ::prj::srl::spt::Parameter ContactType;
        typedef ::xsd::cxx::tree::traits< ContactType, char > ContactTraits;

        const ContactType&
        contact () const;

        ContactType&
        contact ();

        void
        contact (const ContactType& x);

        void
        contact (::std::unique_ptr< ContactType > p);

        // correction
        //
        typedef ::prj::srl::spt::Parameter CorrectionType;
        typedef ::xsd::cxx::tree::traits< CorrectionType, char > CorrectionTraits;

        const CorrectionType&
        correction () const;

        CorrectionType&
        correction ();

        void
        correction (const CorrectionType& x);

        void
        correction (::std::unique_ptr< CorrectionType > p);

        // contactLabel
        //
        typedef ::prj::srl::spt::PLabel ContactLabelType;
        typedef ::xsd::cxx::tree::traits< ContactLabelType, char > ContactLabelTraits;

        const ContactLabelType&
        contactLabel () const;

        ContactLabelType&
        contactLabel ();

        void
        contactLabel (const ContactLabelType& x);

        void
        contactLabel (::std::unique_ptr< ContactLabelType > p);

        // correctionLabel
        //
        typedef ::prj::srl::spt::PLabel CorrectionLabelType;
        typedef ::xsd::cxx::tree::traits< CorrectionLabelType, char > CorrectionLabelTraits;

        const CorrectionLabelType&
        correctionLabel () const;

        CorrectionLabelType&
        correctionLabel ();

        void
        correctionLabel (const CorrectionLabelType& x);

        void
        correctionLabel (::std::unique_ptr< CorrectionLabelType > p);

        // Constructors.
        //
        SweepProfile (const PickType&,
                      const ContactType&,
                      const CorrectionType&,
                      const ContactLabelType&,
                      const CorrectionLabelType&);

        SweepProfile (::std::unique_ptr< PickType >,
                      ::std::unique_ptr< ContactType >,
                      ::std::unique_ptr< CorrectionType >,
                      ::std::unique_ptr< ContactLabelType >,
                      ::std::unique_ptr< CorrectionLabelType >);

        SweepProfile (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

        SweepProfile (const SweepProfile& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

        virtual SweepProfile*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        SweepProfile&
        operator= (const SweepProfile& x);

        virtual 
        ~SweepProfile ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< PickType > pick_;
        ::xsd::cxx::tree::one< ContactType > contact_;
        ::xsd::cxx::tree::one< CorrectionType > correction_;
        ::xsd::cxx::tree::one< ContactLabelType > contactLabel_;
        ::xsd::cxx::tree::one< CorrectionLabelType > correctionLabel_;
      };

      class SweepAuxiliary: public ::xml_schema::Type
      {
        public:
        // pick
        //
        typedef ::prj::srl::spt::Parameter PickType;
        typedef ::xsd::cxx::tree::traits< PickType, char > PickTraits;

        const PickType&
        pick () const;

        PickType&
        pick ();

        void
        pick (const PickType& x);

        void
        pick (::std::unique_ptr< PickType > p);

        // curvilinearEquivalence
        //
        typedef ::prj::srl::spt::Parameter CurvilinearEquivalenceType;
        typedef ::xsd::cxx::tree::traits< CurvilinearEquivalenceType, char > CurvilinearEquivalenceTraits;

        const CurvilinearEquivalenceType&
        curvilinearEquivalence () const;

        CurvilinearEquivalenceType&
        curvilinearEquivalence ();

        void
        curvilinearEquivalence (const CurvilinearEquivalenceType& x);

        void
        curvilinearEquivalence (::std::unique_ptr< CurvilinearEquivalenceType > p);

        // contactType
        //
        typedef ::prj::srl::spt::Parameter ContactTypeType;
        typedef ::xsd::cxx::tree::traits< ContactTypeType, char > ContactTypeTraits;

        const ContactTypeType&
        contactType () const;

        ContactTypeType&
        contactType ();

        void
        contactType (const ContactTypeType& x);

        void
        contactType (::std::unique_ptr< ContactTypeType > p);

        // curvilinearEquivalenceLabel
        //
        typedef ::prj::srl::spt::PLabel CurvilinearEquivalenceLabelType;
        typedef ::xsd::cxx::tree::traits< CurvilinearEquivalenceLabelType, char > CurvilinearEquivalenceLabelTraits;

        const CurvilinearEquivalenceLabelType&
        curvilinearEquivalenceLabel () const;

        CurvilinearEquivalenceLabelType&
        curvilinearEquivalenceLabel ();

        void
        curvilinearEquivalenceLabel (const CurvilinearEquivalenceLabelType& x);

        void
        curvilinearEquivalenceLabel (::std::unique_ptr< CurvilinearEquivalenceLabelType > p);

        // contactTypeLabel
        //
        typedef ::prj::srl::spt::PLabel ContactTypeLabelType;
        typedef ::xsd::cxx::tree::traits< ContactTypeLabelType, char > ContactTypeLabelTraits;

        const ContactTypeLabelType&
        contactTypeLabel () const;

        ContactTypeLabelType&
        contactTypeLabel ();

        void
        contactTypeLabel (const ContactTypeLabelType& x);

        void
        contactTypeLabel (::std::unique_ptr< ContactTypeLabelType > p);

        // Constructors.
        //
        SweepAuxiliary (const PickType&,
                        const CurvilinearEquivalenceType&,
                        const ContactTypeType&,
                        const CurvilinearEquivalenceLabelType&,
                        const ContactTypeLabelType&);

        SweepAuxiliary (::std::unique_ptr< PickType >,
                        ::std::unique_ptr< CurvilinearEquivalenceType >,
                        ::std::unique_ptr< ContactTypeType >,
                        ::std::unique_ptr< CurvilinearEquivalenceLabelType >,
                        ::std::unique_ptr< ContactTypeLabelType >);

        SweepAuxiliary (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

        SweepAuxiliary (const SweepAuxiliary& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

        virtual SweepAuxiliary*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        SweepAuxiliary&
        operator= (const SweepAuxiliary& x);

        virtual 
        ~SweepAuxiliary ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< PickType > pick_;
        ::xsd::cxx::tree::one< CurvilinearEquivalenceType > curvilinearEquivalence_;
        ::xsd::cxx::tree::one< ContactTypeType > contactType_;
        ::xsd::cxx::tree::one< CurvilinearEquivalenceLabelType > curvilinearEquivalenceLabel_;
        ::xsd::cxx::tree::one< ContactTypeLabelType > contactTypeLabel_;
      };

      class SweepBinormal: public ::xml_schema::Type
      {
        public:
        // picks
        //
        typedef ::prj::srl::spt::Parameter PicksType;
        typedef ::xsd::cxx::tree::traits< PicksType, char > PicksTraits;

        const PicksType&
        picks () const;

        PicksType&
        picks ();

        void
        picks (const PicksType& x);

        void
        picks (::std::unique_ptr< PicksType > p);

        // binormal
        //
        typedef ::prj::srl::spt::Parameter BinormalType;
        typedef ::xsd::cxx::tree::traits< BinormalType, char > BinormalTraits;

        const BinormalType&
        binormal () const;

        BinormalType&
        binormal ();

        void
        binormal (const BinormalType& x);

        void
        binormal (::std::unique_ptr< BinormalType > p);

        // binormalLabel
        //
        typedef ::prj::srl::spt::PLabel BinormalLabelType;
        typedef ::xsd::cxx::tree::traits< BinormalLabelType, char > BinormalLabelTraits;

        const BinormalLabelType&
        binormalLabel () const;

        BinormalLabelType&
        binormalLabel ();

        void
        binormalLabel (const BinormalLabelType& x);

        void
        binormalLabel (::std::unique_ptr< BinormalLabelType > p);

        // Constructors.
        //
        SweepBinormal (const PicksType&,
                       const BinormalType&,
                       const BinormalLabelType&);

        SweepBinormal (::std::unique_ptr< PicksType >,
                       ::std::unique_ptr< BinormalType >,
                       ::std::unique_ptr< BinormalLabelType >);

        SweepBinormal (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

        SweepBinormal (const SweepBinormal& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

        virtual SweepBinormal*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        SweepBinormal&
        operator= (const SweepBinormal& x);

        virtual 
        ~SweepBinormal ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< PicksType > picks_;
        ::xsd::cxx::tree::one< BinormalType > binormal_;
        ::xsd::cxx::tree::one< BinormalLabelType > binormalLabel_;
      };

      class Instance: public ::xml_schema::Type
      {
        public:
        // key
        //
        typedef ::xml_schema::String KeyType;
        typedef ::xsd::cxx::tree::traits< KeyType, char > KeyTraits;

        const KeyType&
        key () const;

        KeyType&
        key ();

        void
        key (const KeyType& x);

        void
        key (::std::unique_ptr< KeyType > p);

        // values
        //
        typedef ::xml_schema::String ValuesType;
        typedef ::xsd::cxx::tree::sequence< ValuesType > ValuesSequence;
        typedef ValuesSequence::iterator ValuesIterator;
        typedef ValuesSequence::const_iterator ValuesConstIterator;
        typedef ::xsd::cxx::tree::traits< ValuesType, char > ValuesTraits;

        const ValuesSequence&
        values () const;

        ValuesSequence&
        values ();

        void
        values (const ValuesSequence& s);

        // Constructors.
        //
        Instance (const KeyType&);

        Instance (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

        Instance (const Instance& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

        virtual Instance*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        Instance&
        operator= (const Instance& x);

        virtual 
        ~Instance ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< KeyType > key_;
        ValuesSequence values_;
      };

      class Sweep: public ::xml_schema::Type
      {
        public:
        // base
        //
        typedef ::prj::srl::spt::Base BaseType;
        typedef ::xsd::cxx::tree::traits< BaseType, char > BaseTraits;

        const BaseType&
        base () const;

        BaseType&
        base ();

        void
        base (const BaseType& x);

        void
        base (::std::unique_ptr< BaseType > p);

        // seerShape
        //
        typedef ::prj::srl::spt::SeerShape SeerShapeType;
        typedef ::xsd::cxx::tree::traits< SeerShapeType, char > SeerShapeTraits;

        const SeerShapeType&
        seerShape () const;

        SeerShapeType&
        seerShape ();

        void
        seerShape (const SeerShapeType& x);

        void
        seerShape (::std::unique_ptr< SeerShapeType > p);

        // lawFunction
        //
        typedef ::prj::srl::lwfs::Cue LawFunctionType;
        typedef ::xsd::cxx::tree::traits< LawFunctionType, char > LawFunctionTraits;

        const LawFunctionType&
        lawFunction () const;

        LawFunctionType&
        lawFunction ();

        void
        lawFunction (const LawFunctionType& x);

        void
        lawFunction (::std::unique_ptr< LawFunctionType > p);

        // trihedron
        //
        typedef ::prj::srl::spt::Parameter TrihedronType;
        typedef ::xsd::cxx::tree::traits< TrihedronType, char > TrihedronTraits;

        const TrihedronType&
        trihedron () const;

        TrihedronType&
        trihedron ();

        void
        trihedron (const TrihedronType& x);

        void
        trihedron (::std::unique_ptr< TrihedronType > p);

        // transition
        //
        typedef ::prj::srl::spt::Parameter TransitionType;
        typedef ::xsd::cxx::tree::traits< TransitionType, char > TransitionTraits;

        const TransitionType&
        transition () const;

        TransitionType&
        transition ();

        void
        transition (const TransitionType& x);

        void
        transition (::std::unique_ptr< TransitionType > p);

        // forceC1
        //
        typedef ::prj::srl::spt::Parameter ForceC1Type;
        typedef ::xsd::cxx::tree::traits< ForceC1Type, char > ForceC1Traits;

        const ForceC1Type&
        forceC1 () const;

        ForceC1Type&
        forceC1 ();

        void
        forceC1 (const ForceC1Type& x);

        void
        forceC1 (::std::unique_ptr< ForceC1Type > p);

        // solid
        //
        typedef ::prj::srl::spt::Parameter SolidType;
        typedef ::xsd::cxx::tree::traits< SolidType, char > SolidTraits;

        const SolidType&
        solid () const;

        SolidType&
        solid ();

        void
        solid (const SolidType& x);

        void
        solid (::std::unique_ptr< SolidType > p);

        // useLaw
        //
        typedef ::prj::srl::spt::Parameter UseLawType;
        typedef ::xsd::cxx::tree::traits< UseLawType, char > UseLawTraits;

        const UseLawType&
        useLaw () const;

        UseLawType&
        useLaw ();

        void
        useLaw (const UseLawType& x);

        void
        useLaw (::std::unique_ptr< UseLawType > p);

        // spine
        //
        typedef ::prj::srl::spt::Parameter SpineType;
        typedef ::xsd::cxx::tree::traits< SpineType, char > SpineTraits;

        const SpineType&
        spine () const;

        SpineType&
        spine ();

        void
        spine (const SpineType& x);

        void
        spine (::std::unique_ptr< SpineType > p);

        // profiles
        //
        typedef ::prj::srl::swps::SweepProfile ProfilesType;
        typedef ::xsd::cxx::tree::sequence< ProfilesType > ProfilesSequence;
        typedef ProfilesSequence::iterator ProfilesIterator;
        typedef ProfilesSequence::const_iterator ProfilesConstIterator;
        typedef ::xsd::cxx::tree::traits< ProfilesType, char > ProfilesTraits;

        const ProfilesSequence&
        profiles () const;

        ProfilesSequence&
        profiles ();

        void
        profiles (const ProfilesSequence& s);

        // auxiliary
        //
        typedef ::prj::srl::swps::SweepAuxiliary AuxiliaryType;
        typedef ::xsd::cxx::tree::traits< AuxiliaryType, char > AuxiliaryTraits;

        const AuxiliaryType&
        auxiliary () const;

        AuxiliaryType&
        auxiliary ();

        void
        auxiliary (const AuxiliaryType& x);

        void
        auxiliary (::std::unique_ptr< AuxiliaryType > p);

        // support
        //
        typedef ::prj::srl::spt::Parameter SupportType;
        typedef ::xsd::cxx::tree::traits< SupportType, char > SupportTraits;

        const SupportType&
        support () const;

        SupportType&
        support ();

        void
        support (const SupportType& x);

        void
        support (::std::unique_ptr< SupportType > p);

        // binormal
        //
        typedef ::prj::srl::swps::SweepBinormal BinormalType;
        typedef ::xsd::cxx::tree::traits< BinormalType, char > BinormalTraits;

        const BinormalType&
        binormal () const;

        BinormalType&
        binormal ();

        void
        binormal (const BinormalType& x);

        void
        binormal (::std::unique_ptr< BinormalType > p);

        // trihedronLabel
        //
        typedef ::prj::srl::spt::PLabel TrihedronLabelType;
        typedef ::xsd::cxx::tree::traits< TrihedronLabelType, char > TrihedronLabelTraits;

        const TrihedronLabelType&
        trihedronLabel () const;

        TrihedronLabelType&
        trihedronLabel ();

        void
        trihedronLabel (const TrihedronLabelType& x);

        void
        trihedronLabel (::std::unique_ptr< TrihedronLabelType > p);

        // transitionLabel
        //
        typedef ::prj::srl::spt::PLabel TransitionLabelType;
        typedef ::xsd::cxx::tree::traits< TransitionLabelType, char > TransitionLabelTraits;

        const TransitionLabelType&
        transitionLabel () const;

        TransitionLabelType&
        transitionLabel ();

        void
        transitionLabel (const TransitionLabelType& x);

        void
        transitionLabel (::std::unique_ptr< TransitionLabelType > p);

        // forceC1Label
        //
        typedef ::prj::srl::spt::PLabel ForceC1LabelType;
        typedef ::xsd::cxx::tree::traits< ForceC1LabelType, char > ForceC1LabelTraits;

        const ForceC1LabelType&
        forceC1Label () const;

        ForceC1LabelType&
        forceC1Label ();

        void
        forceC1Label (const ForceC1LabelType& x);

        void
        forceC1Label (::std::unique_ptr< ForceC1LabelType > p);

        // solidLabel
        //
        typedef ::prj::srl::spt::PLabel SolidLabelType;
        typedef ::xsd::cxx::tree::traits< SolidLabelType, char > SolidLabelTraits;

        const SolidLabelType&
        solidLabel () const;

        SolidLabelType&
        solidLabel ();

        void
        solidLabel (const SolidLabelType& x);

        void
        solidLabel (::std::unique_ptr< SolidLabelType > p);

        // useLawLabel
        //
        typedef ::prj::srl::spt::PLabel UseLawLabelType;
        typedef ::xsd::cxx::tree::traits< UseLawLabelType, char > UseLawLabelTraits;

        const UseLawLabelType&
        useLawLabel () const;

        UseLawLabelType&
        useLawLabel ();

        void
        useLawLabel (const UseLawLabelType& x);

        void
        useLawLabel (::std::unique_ptr< UseLawLabelType > p);

        // lawVizMatrix
        //
        typedef ::prj::srl::spt::Matrixd LawVizMatrixType;
        typedef ::xsd::cxx::tree::traits< LawVizMatrixType, char > LawVizMatrixTraits;

        const LawVizMatrixType&
        lawVizMatrix () const;

        LawVizMatrixType&
        lawVizMatrix ();

        void
        lawVizMatrix (const LawVizMatrixType& x);

        void
        lawVizMatrix (::std::unique_ptr< LawVizMatrixType > p);

        // lawVizScale
        //
        typedef ::xml_schema::Double LawVizScaleType;
        typedef ::xsd::cxx::tree::traits< LawVizScaleType, char, ::xsd::cxx::tree::schema_type::double_ > LawVizScaleTraits;

        const LawVizScaleType&
        lawVizScale () const;

        LawVizScaleType&
        lawVizScale ();

        void
        lawVizScale (const LawVizScaleType& x);

        // solidId
        //
        typedef ::xml_schema::String SolidIdType;
        typedef ::xsd::cxx::tree::traits< SolidIdType, char > SolidIdTraits;

        const SolidIdType&
        solidId () const;

        SolidIdType&
        solidId ();

        void
        solidId (const SolidIdType& x);

        void
        solidId (::std::unique_ptr< SolidIdType > p);

        // shellId
        //
        typedef ::xml_schema::String ShellIdType;
        typedef ::xsd::cxx::tree::traits< ShellIdType, char > ShellIdTraits;

        const ShellIdType&
        shellId () const;

        ShellIdType&
        shellId ();

        void
        shellId (const ShellIdType& x);

        void
        shellId (::std::unique_ptr< ShellIdType > p);

        // firstFaceId
        //
        typedef ::xml_schema::String FirstFaceIdType;
        typedef ::xsd::cxx::tree::traits< FirstFaceIdType, char > FirstFaceIdTraits;

        const FirstFaceIdType&
        firstFaceId () const;

        FirstFaceIdType&
        firstFaceId ();

        void
        firstFaceId (const FirstFaceIdType& x);

        void
        firstFaceId (::std::unique_ptr< FirstFaceIdType > p);

        // lastFaceId
        //
        typedef ::xml_schema::String LastFaceIdType;
        typedef ::xsd::cxx::tree::traits< LastFaceIdType, char > LastFaceIdTraits;

        const LastFaceIdType&
        lastFaceId () const;

        LastFaceIdType&
        lastFaceId ();

        void
        lastFaceId (const LastFaceIdType& x);

        void
        lastFaceId (::std::unique_ptr< LastFaceIdType > p);

        // outerWireMap
        //
        typedef ::prj::srl::spt::EvolveRecord OuterWireMapType;
        typedef ::xsd::cxx::tree::sequence< OuterWireMapType > OuterWireMapSequence;
        typedef OuterWireMapSequence::iterator OuterWireMapIterator;
        typedef OuterWireMapSequence::const_iterator OuterWireMapConstIterator;
        typedef ::xsd::cxx::tree::traits< OuterWireMapType, char > OuterWireMapTraits;

        const OuterWireMapSequence&
        outerWireMap () const;

        OuterWireMapSequence&
        outerWireMap ();

        void
        outerWireMap (const OuterWireMapSequence& s);

        // instanceMap
        //
        typedef ::prj::srl::swps::Instance InstanceMapType;
        typedef ::xsd::cxx::tree::sequence< InstanceMapType > InstanceMapSequence;
        typedef InstanceMapSequence::iterator InstanceMapIterator;
        typedef InstanceMapSequence::const_iterator InstanceMapConstIterator;
        typedef ::xsd::cxx::tree::traits< InstanceMapType, char > InstanceMapTraits;

        const InstanceMapSequence&
        instanceMap () const;

        InstanceMapSequence&
        instanceMap ();

        void
        instanceMap (const InstanceMapSequence& s);

        // firstShapeMap
        //
        typedef ::prj::srl::spt::EvolveRecord FirstShapeMapType;
        typedef ::xsd::cxx::tree::sequence< FirstShapeMapType > FirstShapeMapSequence;
        typedef FirstShapeMapSequence::iterator FirstShapeMapIterator;
        typedef FirstShapeMapSequence::const_iterator FirstShapeMapConstIterator;
        typedef ::xsd::cxx::tree::traits< FirstShapeMapType, char > FirstShapeMapTraits;

        const FirstShapeMapSequence&
        firstShapeMap () const;

        FirstShapeMapSequence&
        firstShapeMap ();

        void
        firstShapeMap (const FirstShapeMapSequence& s);

        // lastShapeMap
        //
        typedef ::prj::srl::spt::EvolveRecord LastShapeMapType;
        typedef ::xsd::cxx::tree::sequence< LastShapeMapType > LastShapeMapSequence;
        typedef LastShapeMapSequence::iterator LastShapeMapIterator;
        typedef LastShapeMapSequence::const_iterator LastShapeMapConstIterator;
        typedef ::xsd::cxx::tree::traits< LastShapeMapType, char > LastShapeMapTraits;

        const LastShapeMapSequence&
        lastShapeMap () const;

        LastShapeMapSequence&
        lastShapeMap ();

        void
        lastShapeMap (const LastShapeMapSequence& s);

        // Constructors.
        //
        Sweep (const BaseType&,
               const SeerShapeType&,
               const LawFunctionType&,
               const TrihedronType&,
               const TransitionType&,
               const ForceC1Type&,
               const SolidType&,
               const UseLawType&,
               const SpineType&,
               const AuxiliaryType&,
               const SupportType&,
               const BinormalType&,
               const TrihedronLabelType&,
               const TransitionLabelType&,
               const ForceC1LabelType&,
               const SolidLabelType&,
               const UseLawLabelType&,
               const LawVizMatrixType&,
               const LawVizScaleType&,
               const SolidIdType&,
               const ShellIdType&,
               const FirstFaceIdType&,
               const LastFaceIdType&);

        Sweep (::std::unique_ptr< BaseType >,
               ::std::unique_ptr< SeerShapeType >,
               ::std::unique_ptr< LawFunctionType >,
               ::std::unique_ptr< TrihedronType >,
               ::std::unique_ptr< TransitionType >,
               ::std::unique_ptr< ForceC1Type >,
               ::std::unique_ptr< SolidType >,
               ::std::unique_ptr< UseLawType >,
               ::std::unique_ptr< SpineType >,
               ::std::unique_ptr< AuxiliaryType >,
               ::std::unique_ptr< SupportType >,
               ::std::unique_ptr< BinormalType >,
               ::std::unique_ptr< TrihedronLabelType >,
               ::std::unique_ptr< TransitionLabelType >,
               ::std::unique_ptr< ForceC1LabelType >,
               ::std::unique_ptr< SolidLabelType >,
               ::std::unique_ptr< UseLawLabelType >,
               ::std::unique_ptr< LawVizMatrixType >,
               const LawVizScaleType&,
               const SolidIdType&,
               const ShellIdType&,
               const FirstFaceIdType&,
               const LastFaceIdType&);

        Sweep (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

        Sweep (const Sweep& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

        virtual Sweep*
        _clone (::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0) const;

        Sweep&
        operator= (const Sweep& x);

        virtual 
        ~Sweep ();

        // Implementation.
        //
        protected:
        void
        parse (::xsd::cxx::xml::dom::parser< char >&,
               ::xml_schema::Flags);

        protected:
        ::xsd::cxx::tree::one< BaseType > base_;
        ::xsd::cxx::tree::one< SeerShapeType > seerShape_;
        ::xsd::cxx::tree::one< LawFunctionType > lawFunction_;
        ::xsd::cxx::tree::one< TrihedronType > trihedron_;
        ::xsd::cxx::tree::one< TransitionType > transition_;
        ::xsd::cxx::tree::one< ForceC1Type > forceC1_;
        ::xsd::cxx::tree::one< SolidType > solid_;
        ::xsd::cxx::tree::one< UseLawType > useLaw_;
        ::xsd::cxx::tree::one< SpineType > spine_;
        ProfilesSequence profiles_;
        ::xsd::cxx::tree::one< AuxiliaryType > auxiliary_;
        ::xsd::cxx::tree::one< SupportType > support_;
        ::xsd::cxx::tree::one< BinormalType > binormal_;
        ::xsd::cxx::tree::one< TrihedronLabelType > trihedronLabel_;
        ::xsd::cxx::tree::one< TransitionLabelType > transitionLabel_;
        ::xsd::cxx::tree::one< ForceC1LabelType > forceC1Label_;
        ::xsd::cxx::tree::one< SolidLabelType > solidLabel_;
        ::xsd::cxx::tree::one< UseLawLabelType > useLawLabel_;
        ::xsd::cxx::tree::one< LawVizMatrixType > lawVizMatrix_;
        ::xsd::cxx::tree::one< LawVizScaleType > lawVizScale_;
        ::xsd::cxx::tree::one< SolidIdType > solidId_;
        ::xsd::cxx::tree::one< ShellIdType > shellId_;
        ::xsd::cxx::tree::one< FirstFaceIdType > firstFaceId_;
        ::xsd::cxx::tree::one< LastFaceIdType > lastFaceId_;
        OuterWireMapSequence outerWireMap_;
        InstanceMapSequence instanceMap_;
        FirstShapeMapSequence firstShapeMap_;
        LastShapeMapSequence lastShapeMap_;
      };
    }
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace prj
{
  namespace srl
  {
    namespace swps
    {
      // Parse a URI or a local file.
      //

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (const ::std::string& uri,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (const ::std::string& uri,
             ::xml_schema::ErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (const ::std::string& uri,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      // Parse std::istream.
      //

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::std::istream& is,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::std::istream& is,
             ::xml_schema::ErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::std::istream& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::ErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::std::istream& is,
             const ::std::string& id,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      // Parse xercesc::InputSource.
      //

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::xercesc::InputSource& is,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::xercesc::InputSource& is,
             ::xml_schema::ErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::xercesc::InputSource& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      // Parse xercesc::DOMDocument.
      //

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (const ::xercesc::DOMDocument& d,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

      ::std::unique_ptr< ::prj::srl::swps::Sweep >
      sweep (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());
    }
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace prj
{
  namespace srl
  {
    namespace swps
    {
      void
      operator<< (::xercesc::DOMElement&, const SweepProfile&);

      void
      operator<< (::xercesc::DOMElement&, const SweepAuxiliary&);

      void
      operator<< (::xercesc::DOMElement&, const SweepBinormal&);

      void
      operator<< (::xercesc::DOMElement&, const Instance&);

      void
      operator<< (::xercesc::DOMElement&, const Sweep&);

      // Serialize to std::ostream.
      //

      void
      sweep (::std::ostream& os,
             const ::prj::srl::swps::Sweep& x, 
             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::Flags f = 0);

      void
      sweep (::std::ostream& os,
             const ::prj::srl::swps::Sweep& x, 
             ::xml_schema::ErrorHandler& eh,
             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::Flags f = 0);

      void
      sweep (::std::ostream& os,
             const ::prj::srl::swps::Sweep& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::Flags f = 0);

      // Serialize to xercesc::XMLFormatTarget.
      //

      void
      sweep (::xercesc::XMLFormatTarget& ft,
             const ::prj::srl::swps::Sweep& x, 
             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::Flags f = 0);

      void
      sweep (::xercesc::XMLFormatTarget& ft,
             const ::prj::srl::swps::Sweep& x, 
             ::xml_schema::ErrorHandler& eh,
             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::Flags f = 0);

      void
      sweep (::xercesc::XMLFormatTarget& ft,
             const ::prj::srl::swps::Sweep& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::Flags f = 0);

      // Serialize to an existing xercesc::DOMDocument.
      //

      void
      sweep (::xercesc::DOMDocument& d,
             const ::prj::srl::swps::Sweep& x,
             ::xml_schema::Flags f = 0);

      // Serialize to a new xercesc::DOMDocument.
      //

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
      sweep (const ::prj::srl::swps::Sweep& x, 
             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
             ::xml_schema::Flags f = 0);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // PRJ_SRL_SWPS_PRJSRLSWPSSWEEP_H
