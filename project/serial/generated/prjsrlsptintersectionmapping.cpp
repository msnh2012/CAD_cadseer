// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "prjsrlsptintersectionmapping.h"

namespace prj
{
  namespace srl
  {
    namespace spt
    {
      // EdgeNode
      // 

      const EdgeNode::EdgeIdType& EdgeNode::
      edgeId () const
      {
        return this->edgeId_.get ();
      }

      EdgeNode::EdgeIdType& EdgeNode::
      edgeId ()
      {
        return this->edgeId_.get ();
      }

      void EdgeNode::
      edgeId (const EdgeIdType& x)
      {
        this->edgeId_.set (x);
      }

      void EdgeNode::
      edgeId (::std::unique_ptr< EdgeIdType > x)
      {
        this->edgeId_.set (std::move (x));
      }

      const EdgeNode::EdgeIdType& EdgeNode::
      edgeId_default_value ()
      {
        return edgeId_default_value_;
      }

      const EdgeNode::CenterType& EdgeNode::
      center () const
      {
        return this->center_.get ();
      }

      EdgeNode::CenterType& EdgeNode::
      center ()
      {
        return this->center_.get ();
      }

      void EdgeNode::
      center (const CenterType& x)
      {
        this->center_.set (x);
      }

      const EdgeNode::AliveType& EdgeNode::
      alive () const
      {
        return this->alive_.get ();
      }

      EdgeNode::AliveType& EdgeNode::
      alive ()
      {
        return this->alive_.get ();
      }

      void EdgeNode::
      alive (const AliveType& x)
      {
        this->alive_.set (x);
      }


      // EdgeSplit
      // 

      const EdgeSplit::EdgeHistoryType& EdgeSplit::
      edgeHistory () const
      {
        return this->edgeHistory_.get ();
      }

      EdgeSplit::EdgeHistoryType& EdgeSplit::
      edgeHistory ()
      {
        return this->edgeHistory_.get ();
      }

      void EdgeSplit::
      edgeHistory (const EdgeHistoryType& x)
      {
        this->edgeHistory_.set (x);
      }

      void EdgeSplit::
      edgeHistory (::std::unique_ptr< EdgeHistoryType > x)
      {
        this->edgeHistory_.set (std::move (x));
      }

      const EdgeSplit::NodesSequence& EdgeSplit::
      nodes () const
      {
        return this->nodes_;
      }

      EdgeSplit::NodesSequence& EdgeSplit::
      nodes ()
      {
        return this->nodes_;
      }

      void EdgeSplit::
      nodes (const NodesSequence& s)
      {
        this->nodes_ = s;
      }


      // IntersectionNode
      // 

      const IntersectionNode::EdgeIdType& IntersectionNode::
      edgeId () const
      {
        return this->edgeId_.get ();
      }

      IntersectionNode::EdgeIdType& IntersectionNode::
      edgeId ()
      {
        return this->edgeId_.get ();
      }

      void IntersectionNode::
      edgeId (const EdgeIdType& x)
      {
        this->edgeId_.set (x);
      }

      void IntersectionNode::
      edgeId (::std::unique_ptr< EdgeIdType > x)
      {
        this->edgeId_.set (std::move (x));
      }

      const IntersectionNode::EdgeIdType& IntersectionNode::
      edgeId_default_value ()
      {
        return edgeId_default_value_;
      }

      const IntersectionNode::CenterXType& IntersectionNode::
      centerX () const
      {
        return this->centerX_.get ();
      }

      IntersectionNode::CenterXType& IntersectionNode::
      centerX ()
      {
        return this->centerX_.get ();
      }

      void IntersectionNode::
      centerX (const CenterXType& x)
      {
        this->centerX_.set (x);
      }

      const IntersectionNode::CenterYType& IntersectionNode::
      centerY () const
      {
        return this->centerY_.get ();
      }

      IntersectionNode::CenterYType& IntersectionNode::
      centerY ()
      {
        return this->centerY_.get ();
      }

      void IntersectionNode::
      centerY (const CenterYType& x)
      {
        this->centerY_.set (x);
      }

      const IntersectionNode::AliveType& IntersectionNode::
      alive () const
      {
        return this->alive_.get ();
      }

      IntersectionNode::AliveType& IntersectionNode::
      alive ()
      {
        return this->alive_.get ();
      }

      void IntersectionNode::
      alive (const AliveType& x)
      {
        this->alive_.set (x);
      }


      // EdgeIntersection
      // 

      const EdgeIntersection::FaceHistory1Type& EdgeIntersection::
      faceHistory1 () const
      {
        return this->faceHistory1_.get ();
      }

      EdgeIntersection::FaceHistory1Type& EdgeIntersection::
      faceHistory1 ()
      {
        return this->faceHistory1_.get ();
      }

      void EdgeIntersection::
      faceHistory1 (const FaceHistory1Type& x)
      {
        this->faceHistory1_.set (x);
      }

      void EdgeIntersection::
      faceHistory1 (::std::unique_ptr< FaceHistory1Type > x)
      {
        this->faceHistory1_.set (std::move (x));
      }

      const EdgeIntersection::FaceHistory2Type& EdgeIntersection::
      faceHistory2 () const
      {
        return this->faceHistory2_.get ();
      }

      EdgeIntersection::FaceHistory2Type& EdgeIntersection::
      faceHistory2 ()
      {
        return this->faceHistory2_.get ();
      }

      void EdgeIntersection::
      faceHistory2 (const FaceHistory2Type& x)
      {
        this->faceHistory2_.set (x);
      }

      void EdgeIntersection::
      faceHistory2 (::std::unique_ptr< FaceHistory2Type > x)
      {
        this->faceHistory2_.set (std::move (x));
      }

      const EdgeIntersection::NodesSequence& EdgeIntersection::
      nodes () const
      {
        return this->nodes_;
      }

      EdgeIntersection::NodesSequence& EdgeIntersection::
      nodes ()
      {
        return this->nodes_;
      }

      void EdgeIntersection::
      nodes (const NodesSequence& s)
      {
        this->nodes_ = s;
      }


      // FaceNode
      // 

      const FaceNode::FaceIdType& FaceNode::
      faceId () const
      {
        return this->faceId_.get ();
      }

      FaceNode::FaceIdType& FaceNode::
      faceId ()
      {
        return this->faceId_.get ();
      }

      void FaceNode::
      faceId (const FaceIdType& x)
      {
        this->faceId_.set (x);
      }

      void FaceNode::
      faceId (::std::unique_ptr< FaceIdType > x)
      {
        this->faceId_.set (std::move (x));
      }

      const FaceNode::FaceIdType& FaceNode::
      faceId_default_value ()
      {
        return faceId_default_value_;
      }

      const FaceNode::WireIdType& FaceNode::
      wireId () const
      {
        return this->wireId_.get ();
      }

      FaceNode::WireIdType& FaceNode::
      wireId ()
      {
        return this->wireId_.get ();
      }

      void FaceNode::
      wireId (const WireIdType& x)
      {
        this->wireId_.set (x);
      }

      void FaceNode::
      wireId (::std::unique_ptr< WireIdType > x)
      {
        this->wireId_.set (std::move (x));
      }

      const FaceNode::WireIdType& FaceNode::
      wireId_default_value ()
      {
        return wireId_default_value_;
      }

      const FaceNode::CenterXType& FaceNode::
      centerX () const
      {
        return this->centerX_.get ();
      }

      FaceNode::CenterXType& FaceNode::
      centerX ()
      {
        return this->centerX_.get ();
      }

      void FaceNode::
      centerX (const CenterXType& x)
      {
        this->centerX_.set (x);
      }

      const FaceNode::CenterYType& FaceNode::
      centerY () const
      {
        return this->centerY_.get ();
      }

      FaceNode::CenterYType& FaceNode::
      centerY ()
      {
        return this->centerY_.get ();
      }

      void FaceNode::
      centerY (const CenterYType& x)
      {
        this->centerY_.set (x);
      }

      const FaceNode::AliveType& FaceNode::
      alive () const
      {
        return this->alive_.get ();
      }

      FaceNode::AliveType& FaceNode::
      alive ()
      {
        return this->alive_.get ();
      }

      void FaceNode::
      alive (const AliveType& x)
      {
        this->alive_.set (x);
      }


      // FaceSplit
      // 

      const FaceSplit::FaceHistoryType& FaceSplit::
      faceHistory () const
      {
        return this->faceHistory_.get ();
      }

      FaceSplit::FaceHistoryType& FaceSplit::
      faceHistory ()
      {
        return this->faceHistory_.get ();
      }

      void FaceSplit::
      faceHistory (const FaceHistoryType& x)
      {
        this->faceHistory_.set (x);
      }

      void FaceSplit::
      faceHistory (::std::unique_ptr< FaceHistoryType > x)
      {
        this->faceHistory_.set (std::move (x));
      }

      const FaceSplit::NodesSequence& FaceSplit::
      nodes () const
      {
        return this->nodes_;
      }

      FaceSplit::NodesSequence& FaceSplit::
      nodes ()
      {
        return this->nodes_;
      }

      void FaceSplit::
      nodes (const NodesSequence& s)
      {
        this->nodes_ = s;
      }


      // SameDomain
      // 

      const SameDomain::IdType& SameDomain::
      id () const
      {
        return this->id_.get ();
      }

      SameDomain::IdType& SameDomain::
      id ()
      {
        return this->id_.get ();
      }

      void SameDomain::
      id (const IdType& x)
      {
        this->id_.set (x);
      }

      void SameDomain::
      id (::std::unique_ptr< IdType > x)
      {
        this->id_.set (std::move (x));
      }

      const SameDomain::IdType& SameDomain::
      id_default_value ()
      {
        return id_default_value_;
      }

      const SameDomain::HistoriesSequence& SameDomain::
      histories () const
      {
        return this->histories_;
      }

      SameDomain::HistoriesSequence& SameDomain::
      histories ()
      {
        return this->histories_;
      }

      void SameDomain::
      histories (const HistoriesSequence& s)
      {
        this->histories_ = s;
      }


      // IntersectionMapper
      // 

      const IntersectionMapper::EdgeIntersectionsSequence& IntersectionMapper::
      edgeIntersections () const
      {
        return this->edgeIntersections_;
      }

      IntersectionMapper::EdgeIntersectionsSequence& IntersectionMapper::
      edgeIntersections ()
      {
        return this->edgeIntersections_;
      }

      void IntersectionMapper::
      edgeIntersections (const EdgeIntersectionsSequence& s)
      {
        this->edgeIntersections_ = s;
      }

      const IntersectionMapper::FaceSplitsSequence& IntersectionMapper::
      faceSplits () const
      {
        return this->faceSplits_;
      }

      IntersectionMapper::FaceSplitsSequence& IntersectionMapper::
      faceSplits ()
      {
        return this->faceSplits_;
      }

      void IntersectionMapper::
      faceSplits (const FaceSplitsSequence& s)
      {
        this->faceSplits_ = s;
      }

      const IntersectionMapper::EdgeSplitsSequence& IntersectionMapper::
      edgeSplits () const
      {
        return this->edgeSplits_;
      }

      IntersectionMapper::EdgeSplitsSequence& IntersectionMapper::
      edgeSplits ()
      {
        return this->edgeSplits_;
      }

      void IntersectionMapper::
      edgeSplits (const EdgeSplitsSequence& s)
      {
        this->edgeSplits_ = s;
      }

      const IntersectionMapper::SameDomainsSequence& IntersectionMapper::
      sameDomains () const
      {
        return this->sameDomains_;
      }

      IntersectionMapper::SameDomainsSequence& IntersectionMapper::
      sameDomains ()
      {
        return this->sameDomains_;
      }

      void IntersectionMapper::
      sameDomains (const SameDomainsSequence& s)
      {
        this->sameDomains_ = s;
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace spt
    {
      // EdgeNode
      //

      const EdgeNode::EdgeIdType EdgeNode::edgeId_default_value_ (
        "00000000-0000-0000-0000-000000000000");

      EdgeNode::
      EdgeNode (const EdgeIdType& edgeId,
                const CenterType& center,
                const AliveType& alive)
      : ::xml_schema::Type (),
        edgeId_ (edgeId, this),
        center_ (center, this),
        alive_ (alive, this)
      {
      }

      EdgeNode::
      EdgeNode (const EdgeNode& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        edgeId_ (x.edgeId_, f, this),
        center_ (x.center_, f, this),
        alive_ (x.alive_, f, this)
      {
      }

      EdgeNode::
      EdgeNode (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        edgeId_ (this),
        center_ (this),
        alive_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void EdgeNode::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // edgeId
          //
          if (n.name () == "edgeId" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< EdgeIdType > r (
              EdgeIdTraits::create (i, f, this));

            if (!edgeId_.present ())
            {
              this->edgeId_.set (::std::move (r));
              continue;
            }
          }

          // center
          //
          if (n.name () == "center" && n.namespace_ ().empty ())
          {
            if (!center_.present ())
            {
              this->center_.set (CenterTraits::create (i, f, this));
              continue;
            }
          }

          // alive
          //
          if (n.name () == "alive" && n.namespace_ ().empty ())
          {
            if (!alive_.present ())
            {
              this->alive_.set (AliveTraits::create (i, f, this));
              continue;
            }
          }

          break;
        }

        if (!edgeId_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "edgeId",
            "");
        }

        if (!center_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "center",
            "");
        }

        if (!alive_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "alive",
            "");
        }
      }

      EdgeNode* EdgeNode::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class EdgeNode (*this, f, c);
      }

      EdgeNode& EdgeNode::
      operator= (const EdgeNode& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->edgeId_ = x.edgeId_;
          this->center_ = x.center_;
          this->alive_ = x.alive_;
        }

        return *this;
      }

      EdgeNode::
      ~EdgeNode ()
      {
      }

      // EdgeSplit
      //

      EdgeSplit::
      EdgeSplit (const EdgeHistoryType& edgeHistory)
      : ::xml_schema::Type (),
        edgeHistory_ (edgeHistory, this),
        nodes_ (this)
      {
      }

      EdgeSplit::
      EdgeSplit (::std::unique_ptr< EdgeHistoryType > edgeHistory)
      : ::xml_schema::Type (),
        edgeHistory_ (std::move (edgeHistory), this),
        nodes_ (this)
      {
      }

      EdgeSplit::
      EdgeSplit (const EdgeSplit& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        edgeHistory_ (x.edgeHistory_, f, this),
        nodes_ (x.nodes_, f, this)
      {
      }

      EdgeSplit::
      EdgeSplit (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        edgeHistory_ (this),
        nodes_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void EdgeSplit::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // edgeHistory
          //
          if (n.name () == "edgeHistory" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< EdgeHistoryType > r (
              EdgeHistoryTraits::create (i, f, this));

            if (!edgeHistory_.present ())
            {
              this->edgeHistory_.set (::std::move (r));
              continue;
            }
          }

          // nodes
          //
          if (n.name () == "nodes" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< NodesType > r (
              NodesTraits::create (i, f, this));

            this->nodes_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        if (!edgeHistory_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "edgeHistory",
            "");
        }
      }

      EdgeSplit* EdgeSplit::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class EdgeSplit (*this, f, c);
      }

      EdgeSplit& EdgeSplit::
      operator= (const EdgeSplit& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->edgeHistory_ = x.edgeHistory_;
          this->nodes_ = x.nodes_;
        }

        return *this;
      }

      EdgeSplit::
      ~EdgeSplit ()
      {
      }

      // IntersectionNode
      //

      const IntersectionNode::EdgeIdType IntersectionNode::edgeId_default_value_ (
        "00000000-0000-0000-0000-000000000000");

      IntersectionNode::
      IntersectionNode (const EdgeIdType& edgeId,
                        const CenterXType& centerX,
                        const CenterYType& centerY,
                        const AliveType& alive)
      : ::xml_schema::Type (),
        edgeId_ (edgeId, this),
        centerX_ (centerX, this),
        centerY_ (centerY, this),
        alive_ (alive, this)
      {
      }

      IntersectionNode::
      IntersectionNode (const IntersectionNode& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        edgeId_ (x.edgeId_, f, this),
        centerX_ (x.centerX_, f, this),
        centerY_ (x.centerY_, f, this),
        alive_ (x.alive_, f, this)
      {
      }

      IntersectionNode::
      IntersectionNode (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        edgeId_ (this),
        centerX_ (this),
        centerY_ (this),
        alive_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void IntersectionNode::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // edgeId
          //
          if (n.name () == "edgeId" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< EdgeIdType > r (
              EdgeIdTraits::create (i, f, this));

            if (!edgeId_.present ())
            {
              this->edgeId_.set (::std::move (r));
              continue;
            }
          }

          // centerX
          //
          if (n.name () == "centerX" && n.namespace_ ().empty ())
          {
            if (!centerX_.present ())
            {
              this->centerX_.set (CenterXTraits::create (i, f, this));
              continue;
            }
          }

          // centerY
          //
          if (n.name () == "centerY" && n.namespace_ ().empty ())
          {
            if (!centerY_.present ())
            {
              this->centerY_.set (CenterYTraits::create (i, f, this));
              continue;
            }
          }

          // alive
          //
          if (n.name () == "alive" && n.namespace_ ().empty ())
          {
            if (!alive_.present ())
            {
              this->alive_.set (AliveTraits::create (i, f, this));
              continue;
            }
          }

          break;
        }

        if (!edgeId_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "edgeId",
            "");
        }

        if (!centerX_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "centerX",
            "");
        }

        if (!centerY_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "centerY",
            "");
        }

        if (!alive_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "alive",
            "");
        }
      }

      IntersectionNode* IntersectionNode::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class IntersectionNode (*this, f, c);
      }

      IntersectionNode& IntersectionNode::
      operator= (const IntersectionNode& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->edgeId_ = x.edgeId_;
          this->centerX_ = x.centerX_;
          this->centerY_ = x.centerY_;
          this->alive_ = x.alive_;
        }

        return *this;
      }

      IntersectionNode::
      ~IntersectionNode ()
      {
      }

      // EdgeIntersection
      //

      EdgeIntersection::
      EdgeIntersection (const FaceHistory1Type& faceHistory1,
                        const FaceHistory2Type& faceHistory2)
      : ::xml_schema::Type (),
        faceHistory1_ (faceHistory1, this),
        faceHistory2_ (faceHistory2, this),
        nodes_ (this)
      {
      }

      EdgeIntersection::
      EdgeIntersection (::std::unique_ptr< FaceHistory1Type > faceHistory1,
                        ::std::unique_ptr< FaceHistory2Type > faceHistory2)
      : ::xml_schema::Type (),
        faceHistory1_ (std::move (faceHistory1), this),
        faceHistory2_ (std::move (faceHistory2), this),
        nodes_ (this)
      {
      }

      EdgeIntersection::
      EdgeIntersection (const EdgeIntersection& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        faceHistory1_ (x.faceHistory1_, f, this),
        faceHistory2_ (x.faceHistory2_, f, this),
        nodes_ (x.nodes_, f, this)
      {
      }

      EdgeIntersection::
      EdgeIntersection (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        faceHistory1_ (this),
        faceHistory2_ (this),
        nodes_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void EdgeIntersection::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // faceHistory1
          //
          if (n.name () == "faceHistory1" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< FaceHistory1Type > r (
              FaceHistory1Traits::create (i, f, this));

            if (!faceHistory1_.present ())
            {
              this->faceHistory1_.set (::std::move (r));
              continue;
            }
          }

          // faceHistory2
          //
          if (n.name () == "faceHistory2" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< FaceHistory2Type > r (
              FaceHistory2Traits::create (i, f, this));

            if (!faceHistory2_.present ())
            {
              this->faceHistory2_.set (::std::move (r));
              continue;
            }
          }

          // nodes
          //
          if (n.name () == "nodes" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< NodesType > r (
              NodesTraits::create (i, f, this));

            this->nodes_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        if (!faceHistory1_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "faceHistory1",
            "");
        }

        if (!faceHistory2_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "faceHistory2",
            "");
        }
      }

      EdgeIntersection* EdgeIntersection::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class EdgeIntersection (*this, f, c);
      }

      EdgeIntersection& EdgeIntersection::
      operator= (const EdgeIntersection& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->faceHistory1_ = x.faceHistory1_;
          this->faceHistory2_ = x.faceHistory2_;
          this->nodes_ = x.nodes_;
        }

        return *this;
      }

      EdgeIntersection::
      ~EdgeIntersection ()
      {
      }

      // FaceNode
      //

      const FaceNode::FaceIdType FaceNode::faceId_default_value_ (
        "00000000-0000-0000-0000-000000000000");

      const FaceNode::WireIdType FaceNode::wireId_default_value_ (
        "00000000-0000-0000-0000-000000000000");

      FaceNode::
      FaceNode (const FaceIdType& faceId,
                const WireIdType& wireId,
                const CenterXType& centerX,
                const CenterYType& centerY,
                const AliveType& alive)
      : ::xml_schema::Type (),
        faceId_ (faceId, this),
        wireId_ (wireId, this),
        centerX_ (centerX, this),
        centerY_ (centerY, this),
        alive_ (alive, this)
      {
      }

      FaceNode::
      FaceNode (const FaceNode& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        faceId_ (x.faceId_, f, this),
        wireId_ (x.wireId_, f, this),
        centerX_ (x.centerX_, f, this),
        centerY_ (x.centerY_, f, this),
        alive_ (x.alive_, f, this)
      {
      }

      FaceNode::
      FaceNode (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        faceId_ (this),
        wireId_ (this),
        centerX_ (this),
        centerY_ (this),
        alive_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void FaceNode::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // faceId
          //
          if (n.name () == "faceId" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< FaceIdType > r (
              FaceIdTraits::create (i, f, this));

            if (!faceId_.present ())
            {
              this->faceId_.set (::std::move (r));
              continue;
            }
          }

          // wireId
          //
          if (n.name () == "wireId" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< WireIdType > r (
              WireIdTraits::create (i, f, this));

            if (!wireId_.present ())
            {
              this->wireId_.set (::std::move (r));
              continue;
            }
          }

          // centerX
          //
          if (n.name () == "centerX" && n.namespace_ ().empty ())
          {
            if (!centerX_.present ())
            {
              this->centerX_.set (CenterXTraits::create (i, f, this));
              continue;
            }
          }

          // centerY
          //
          if (n.name () == "centerY" && n.namespace_ ().empty ())
          {
            if (!centerY_.present ())
            {
              this->centerY_.set (CenterYTraits::create (i, f, this));
              continue;
            }
          }

          // alive
          //
          if (n.name () == "alive" && n.namespace_ ().empty ())
          {
            if (!alive_.present ())
            {
              this->alive_.set (AliveTraits::create (i, f, this));
              continue;
            }
          }

          break;
        }

        if (!faceId_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "faceId",
            "");
        }

        if (!wireId_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "wireId",
            "");
        }

        if (!centerX_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "centerX",
            "");
        }

        if (!centerY_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "centerY",
            "");
        }

        if (!alive_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "alive",
            "");
        }
      }

      FaceNode* FaceNode::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class FaceNode (*this, f, c);
      }

      FaceNode& FaceNode::
      operator= (const FaceNode& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->faceId_ = x.faceId_;
          this->wireId_ = x.wireId_;
          this->centerX_ = x.centerX_;
          this->centerY_ = x.centerY_;
          this->alive_ = x.alive_;
        }

        return *this;
      }

      FaceNode::
      ~FaceNode ()
      {
      }

      // FaceSplit
      //

      FaceSplit::
      FaceSplit (const FaceHistoryType& faceHistory)
      : ::xml_schema::Type (),
        faceHistory_ (faceHistory, this),
        nodes_ (this)
      {
      }

      FaceSplit::
      FaceSplit (::std::unique_ptr< FaceHistoryType > faceHistory)
      : ::xml_schema::Type (),
        faceHistory_ (std::move (faceHistory), this),
        nodes_ (this)
      {
      }

      FaceSplit::
      FaceSplit (const FaceSplit& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        faceHistory_ (x.faceHistory_, f, this),
        nodes_ (x.nodes_, f, this)
      {
      }

      FaceSplit::
      FaceSplit (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        faceHistory_ (this),
        nodes_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void FaceSplit::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // faceHistory
          //
          if (n.name () == "faceHistory" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< FaceHistoryType > r (
              FaceHistoryTraits::create (i, f, this));

            if (!faceHistory_.present ())
            {
              this->faceHistory_.set (::std::move (r));
              continue;
            }
          }

          // nodes
          //
          if (n.name () == "nodes" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< NodesType > r (
              NodesTraits::create (i, f, this));

            this->nodes_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        if (!faceHistory_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "faceHistory",
            "");
        }
      }

      FaceSplit* FaceSplit::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class FaceSplit (*this, f, c);
      }

      FaceSplit& FaceSplit::
      operator= (const FaceSplit& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->faceHistory_ = x.faceHistory_;
          this->nodes_ = x.nodes_;
        }

        return *this;
      }

      FaceSplit::
      ~FaceSplit ()
      {
      }

      // SameDomain
      //

      const SameDomain::IdType SameDomain::id_default_value_ (
        "00000000-0000-0000-0000-000000000000");

      SameDomain::
      SameDomain (const IdType& id)
      : ::xml_schema::Type (),
        id_ (id, this),
        histories_ (this)
      {
      }

      SameDomain::
      SameDomain (const SameDomain& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        id_ (x.id_, f, this),
        histories_ (x.histories_, f, this)
      {
      }

      SameDomain::
      SameDomain (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        id_ (this),
        histories_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void SameDomain::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // id
          //
          if (n.name () == "id" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< IdType > r (
              IdTraits::create (i, f, this));

            if (!id_.present ())
            {
              this->id_.set (::std::move (r));
              continue;
            }
          }

          // histories
          //
          if (n.name () == "histories" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< HistoriesType > r (
              HistoriesTraits::create (i, f, this));

            this->histories_.push_back (::std::move (r));
            continue;
          }

          break;
        }

        if (!id_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "id",
            "");
        }
      }

      SameDomain* SameDomain::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class SameDomain (*this, f, c);
      }

      SameDomain& SameDomain::
      operator= (const SameDomain& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->id_ = x.id_;
          this->histories_ = x.histories_;
        }

        return *this;
      }

      SameDomain::
      ~SameDomain ()
      {
      }

      // IntersectionMapper
      //

      IntersectionMapper::
      IntersectionMapper ()
      : ::xml_schema::Type (),
        edgeIntersections_ (this),
        faceSplits_ (this),
        edgeSplits_ (this),
        sameDomains_ (this)
      {
      }

      IntersectionMapper::
      IntersectionMapper (const IntersectionMapper& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        edgeIntersections_ (x.edgeIntersections_, f, this),
        faceSplits_ (x.faceSplits_, f, this),
        edgeSplits_ (x.edgeSplits_, f, this),
        sameDomains_ (x.sameDomains_, f, this)
      {
      }

      IntersectionMapper::
      IntersectionMapper (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        edgeIntersections_ (this),
        faceSplits_ (this),
        edgeSplits_ (this),
        sameDomains_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
          this->parse (p, f);
        }
      }

      void IntersectionMapper::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // edgeIntersections
          //
          if (n.name () == "edgeIntersections" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< EdgeIntersectionsType > r (
              EdgeIntersectionsTraits::create (i, f, this));

            this->edgeIntersections_.push_back (::std::move (r));
            continue;
          }

          // faceSplits
          //
          if (n.name () == "faceSplits" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< FaceSplitsType > r (
              FaceSplitsTraits::create (i, f, this));

            this->faceSplits_.push_back (::std::move (r));
            continue;
          }

          // edgeSplits
          //
          if (n.name () == "edgeSplits" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< EdgeSplitsType > r (
              EdgeSplitsTraits::create (i, f, this));

            this->edgeSplits_.push_back (::std::move (r));
            continue;
          }

          // sameDomains
          //
          if (n.name () == "sameDomains" && n.namespace_ ().empty ())
          {
            ::std::unique_ptr< SameDomainsType > r (
              SameDomainsTraits::create (i, f, this));

            this->sameDomains_.push_back (::std::move (r));
            continue;
          }

          break;
        }
      }

      IntersectionMapper* IntersectionMapper::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class IntersectionMapper (*this, f, c);
      }

      IntersectionMapper& IntersectionMapper::
      operator= (const IntersectionMapper& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->edgeIntersections_ = x.edgeIntersections_;
          this->faceSplits_ = x.faceSplits_;
          this->edgeSplits_ = x.edgeSplits_;
          this->sameDomains_ = x.sameDomains_;
        }

        return *this;
      }

      IntersectionMapper::
      ~IntersectionMapper ()
      {
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace prj
{
  namespace srl
  {
    namespace spt
    {
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace prj
{
  namespace srl
  {
    namespace spt
    {
      void
      operator<< (::xercesc::DOMElement& e, const EdgeNode& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // edgeId
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "edgeId",
              e));

          s << i.edgeId ();
        }

        // center
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "center",
              e));

          s << ::xml_schema::AsDouble(i.center ());
        }

        // alive
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "alive",
              e));

          s << i.alive ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const EdgeSplit& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // edgeHistory
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "edgeHistory",
              e));

          s << i.edgeHistory ();
        }

        // nodes
        //
        for (EdgeSplit::NodesConstIterator
             b (i.nodes ().begin ()), n (i.nodes ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "nodes",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const IntersectionNode& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // edgeId
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "edgeId",
              e));

          s << i.edgeId ();
        }

        // centerX
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "centerX",
              e));

          s << ::xml_schema::AsDouble(i.centerX ());
        }

        // centerY
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "centerY",
              e));

          s << ::xml_schema::AsDouble(i.centerY ());
        }

        // alive
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "alive",
              e));

          s << i.alive ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const EdgeIntersection& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // faceHistory1
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "faceHistory1",
              e));

          s << i.faceHistory1 ();
        }

        // faceHistory2
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "faceHistory2",
              e));

          s << i.faceHistory2 ();
        }

        // nodes
        //
        for (EdgeIntersection::NodesConstIterator
             b (i.nodes ().begin ()), n (i.nodes ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "nodes",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const FaceNode& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // faceId
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "faceId",
              e));

          s << i.faceId ();
        }

        // wireId
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "wireId",
              e));

          s << i.wireId ();
        }

        // centerX
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "centerX",
              e));

          s << ::xml_schema::AsDouble(i.centerX ());
        }

        // centerY
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "centerY",
              e));

          s << ::xml_schema::AsDouble(i.centerY ());
        }

        // alive
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "alive",
              e));

          s << i.alive ();
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const FaceSplit& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // faceHistory
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "faceHistory",
              e));

          s << i.faceHistory ();
        }

        // nodes
        //
        for (FaceSplit::NodesConstIterator
             b (i.nodes ().begin ()), n (i.nodes ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "nodes",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const SameDomain& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // id
        //
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "id",
              e));

          s << i.id ();
        }

        // histories
        //
        for (SameDomain::HistoriesConstIterator
             b (i.histories ().begin ()), n (i.histories ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "histories",
              e));

          s << *b;
        }
      }

      void
      operator<< (::xercesc::DOMElement& e, const IntersectionMapper& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // edgeIntersections
        //
        for (IntersectionMapper::EdgeIntersectionsConstIterator
             b (i.edgeIntersections ().begin ()), n (i.edgeIntersections ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "edgeIntersections",
              e));

          s << *b;
        }

        // faceSplits
        //
        for (IntersectionMapper::FaceSplitsConstIterator
             b (i.faceSplits ().begin ()), n (i.faceSplits ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "faceSplits",
              e));

          s << *b;
        }

        // edgeSplits
        //
        for (IntersectionMapper::EdgeSplitsConstIterator
             b (i.edgeSplits ().begin ()), n (i.edgeSplits ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "edgeSplits",
              e));

          s << *b;
        }

        // sameDomains
        //
        for (IntersectionMapper::SameDomainsConstIterator
             b (i.sameDomains ().begin ()), n (i.sameDomains ().end ());
             b != n; ++b)
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "sameDomains",
              e));

          s << *b;
        }
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

