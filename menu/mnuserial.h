// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from mnuserial.xsd.
 */

#ifndef MNU_SRL_MNUSERIAL_H
#define MNU_SRL_MNUSERIAL_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include "../xmlbase.h"

// Forward declarations.
//
namespace mnu
{
  namespace srl
  {
    class DecPositive;
    class Visual;
    class Command;
    class ToolbarEntry;
    class Toolbar;
    class IconSize;
    class ToolbarSettings;
    class MenuNode;
    class Gesture;
    class MenuSettings;
    class Cue;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace mnu
{
  /**
   * @brief C++ namespace for the %http://www.cadseer.com/mnu/srl
   * schema namespace.
   */
  namespace srl
  {
    /**
     * @brief Class corresponding to the %DecPositive schema type.
     *
     * @nosubgrouping
     */
    class DecPositive: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ >
    {
      public:
      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      DecPositive (const ::xml_schema::Double&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DecPositive (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DecPositive (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DecPositive (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DecPositive (const DecPositive& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual DecPositive*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~DecPositive ();
    };

    /**
     * @brief Class corresponding to the %Visual schema type.
     *
     * @nosubgrouping
     */
    class Visual: public ::xml_schema::Type
    {
      public:
      /**
       * @name icon
       *
       * @brief Accessor and modifier functions for the %icon
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String IconType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< IconType > IconOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< IconType, char > IconTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const IconOptional&
      icon () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      IconOptional&
      icon ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      icon (const IconType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      icon (const IconOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      icon (::std::unique_ptr< IconType > p);

      //@}

      /**
       * @name iconText
       *
       * @brief Accessor and modifier functions for the %iconText
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String IconTextType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< IconTextType > IconTextOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< IconTextType, char > IconTextTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const IconTextOptional&
      iconText () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      IconTextOptional&
      iconText ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      iconText (const IconTextType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      iconText (const IconTextOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      iconText (::std::unique_ptr< IconTextType > p);

      //@}

      /**
       * @name statusText
       *
       * @brief Accessor and modifier functions for the %statusText
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String StatusTextType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< StatusTextType > StatusTextOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< StatusTextType, char > StatusTextTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const StatusTextOptional&
      statusText () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      StatusTextOptional&
      statusText ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      statusText (const StatusTextType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      statusText (const StatusTextOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      statusText (::std::unique_ptr< StatusTextType > p);

      //@}

      /**
       * @name whatThisText
       *
       * @brief Accessor and modifier functions for the %whatThisText
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String WhatThisTextType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< WhatThisTextType > WhatThisTextOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< WhatThisTextType, char > WhatThisTextTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const WhatThisTextOptional&
      whatThisText () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      WhatThisTextOptional&
      whatThisText ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      whatThisText (const WhatThisTextType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      whatThisText (const WhatThisTextOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      whatThisText (::std::unique_ptr< WhatThisTextType > p);

      //@}

      /**
       * @name toolTipText
       *
       * @brief Accessor and modifier functions for the %toolTipText
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String ToolTipTextType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ToolTipTextType > ToolTipTextOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ToolTipTextType, char > ToolTipTextTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ToolTipTextOptional&
      toolTipText () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      ToolTipTextOptional&
      toolTipText ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      toolTipText (const ToolTipTextType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      toolTipText (const ToolTipTextOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      toolTipText (::std::unique_ptr< ToolTipTextType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      Visual ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      Visual (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Visual (const Visual& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual Visual*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Visual&
      operator= (const Visual& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~Visual ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      IconOptional icon_;
      IconTextOptional iconText_;
      StatusTextOptional statusText_;
      WhatThisTextOptional whatThisText_;
      ToolTipTextOptional toolTipText_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %Command schema type.
     *
     * @nosubgrouping
     */
    class Command: public ::xml_schema::Type
    {
      public:
      /**
       * @name id
       *
       * @brief Accessor and modifier functions for the %id
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::UnsignedLong IdType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const IdType&
      id () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      IdType&
      id ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      id (const IdType& x);

      //@}

      /**
       * @name visual
       *
       * @brief Accessor and modifier functions for the %visual
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::mnu::srl::Visual VisualType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< VisualType > VisualOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< VisualType, char > VisualTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const VisualOptional&
      visual () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      VisualOptional&
      visual ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      visual (const VisualType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      visual (const VisualOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      visual (::std::unique_ptr< VisualType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      Command (const IdType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      Command (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Command (const Command& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual Command*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Command&
      operator= (const Command& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~Command ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< IdType > id_;
      VisualOptional visual_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %ToolbarEntry schema type.
     *
     * @nosubgrouping
     */
    class ToolbarEntry: public ::xml_schema::Type
    {
      public:
      /**
       * @name commandIds
       *
       * @brief Accessor and modifier functions for the %commandIds
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::UnsignedLong CommandIdsType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< CommandIdsType > CommandIdsSequence;

      /**
       * @brief Element iterator type.
       */
      typedef CommandIdsSequence::iterator CommandIdsIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef CommandIdsSequence::const_iterator CommandIdsConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< CommandIdsType, char > CommandIdsTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const CommandIdsSequence&
      commandIds () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      CommandIdsSequence&
      commandIds ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      commandIds (const CommandIdsSequence& s);

      //@}

      /**
       * @name visual
       *
       * @brief Accessor and modifier functions for the %visual
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::mnu::srl::Visual VisualType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< VisualType > VisualOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< VisualType, char > VisualTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const VisualOptional&
      visual () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      VisualOptional&
      visual ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      visual (const VisualType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      visual (const VisualOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      visual (::std::unique_ptr< VisualType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ToolbarEntry ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ToolbarEntry (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ToolbarEntry (const ToolbarEntry& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ToolbarEntry*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ToolbarEntry&
      operator= (const ToolbarEntry& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ToolbarEntry ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      CommandIdsSequence commandIds_;
      VisualOptional visual_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %Toolbar schema type.
     *
     * @nosubgrouping
     */
    class Toolbar: public ::xml_schema::Type
    {
      public:
      /**
       * @name icon
       *
       * @brief Accessor and modifier functions for the %icon
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String IconType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< IconType, char > IconTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const IconType&
      icon () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      IconType&
      icon ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      icon (const IconType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      icon (::std::unique_ptr< IconType > p);

      //@}

      /**
       * @name text
       *
       * @brief Accessor and modifier functions for the %text
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String TextType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TextType, char > TextTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const TextType&
      text () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      TextType&
      text ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      text (const TextType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      text (::std::unique_ptr< TextType > p);

      //@}

      /**
       * @name entries
       *
       * @brief Accessor and modifier functions for the %entries
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::mnu::srl::ToolbarEntry EntriesType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< EntriesType > EntriesSequence;

      /**
       * @brief Element iterator type.
       */
      typedef EntriesSequence::iterator EntriesIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef EntriesSequence::const_iterator EntriesConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< EntriesType, char > EntriesTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const EntriesSequence&
      entries () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      EntriesSequence&
      entries ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      entries (const EntriesSequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      Toolbar (const IconType&,
               const TextType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      Toolbar (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Toolbar (const Toolbar& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual Toolbar*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Toolbar&
      operator= (const Toolbar& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~Toolbar ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< IconType > icon_;
      ::xsd::cxx::tree::one< TextType > text_;
      EntriesSequence entries_;

      //@endcond
    };

    /**
     * @brief Enumeration class corresponding to the %IconSize
     * schema type.
     */
    class IconSize: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType >
    {
      public:
      /**
       * @brief Create an instance from a fundamental type value.
       *
       * @param v A fundamental type value.
       */
      IconSize (::xml_schema::Int v);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      IconSize (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      IconSize (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      IconSize (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      IconSize (const IconSize& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual IconSize*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;
    };

    /**
     * @brief Class corresponding to the %ToolbarSettings schema type.
     *
     * @nosubgrouping
     */
    class ToolbarSettings: public ::xml_schema::Type
    {
      public:
      /**
       * @name showIcon
       *
       * @brief Accessor and modifier functions for the %showIcon
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::Boolean ShowIconType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ShowIconType, char > ShowIconTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const ShowIconType&
      showIcon () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      ShowIconType&
      showIcon ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      showIcon (const ShowIconType& x);

      //@}

      /**
       * @name showText
       *
       * @brief Accessor and modifier functions for the %showText
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::Boolean ShowTextType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ShowTextType, char > ShowTextTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const ShowTextType&
      showText () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      ShowTextType&
      showText ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      showText (const ShowTextType& x);

      //@}

      /**
       * @name iconSize
       *
       * @brief Accessor and modifier functions for the %iconSize
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::mnu::srl::IconSize IconSizeType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< IconSizeType, char > IconSizeTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const IconSizeType&
      iconSize () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      IconSizeType&
      iconSize ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      iconSize (const IconSizeType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      iconSize (::std::unique_ptr< IconSizeType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ToolbarSettings (const ShowIconType&,
                       const ShowTextType&,
                       const IconSizeType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ToolbarSettings (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ToolbarSettings (const ToolbarSettings& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ToolbarSettings*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ToolbarSettings&
      operator= (const ToolbarSettings& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ToolbarSettings ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< ShowIconType > showIcon_;
      ::xsd::cxx::tree::one< ShowTextType > showText_;
      ::xsd::cxx::tree::one< IconSizeType > iconSize_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %MenuNode schema type.
     *
     * @nosubgrouping
     */
    class MenuNode: public ::xml_schema::Type
    {
      public:
      /**
       * @name icon
       *
       * @brief Accessor and modifier functions for the %icon
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String IconType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< IconType, char > IconTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const IconType&
      icon () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      IconType&
      icon ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      icon (const IconType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      icon (::std::unique_ptr< IconType > p);

      //@}

      /**
       * @name text
       *
       * @brief Accessor and modifier functions for the %text
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String TextType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TextType, char > TextTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const TextType&
      text () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      TextType&
      text ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      text (const TextType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      text (::std::unique_ptr< TextType > p);

      //@}

      /**
       * @name subMenus
       *
       * @brief Accessor and modifier functions for the %subMenus
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::mnu::srl::MenuNode SubMenusType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< SubMenusType > SubMenusSequence;

      /**
       * @brief Element iterator type.
       */
      typedef SubMenusSequence::iterator SubMenusIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef SubMenusSequence::const_iterator SubMenusConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< SubMenusType, char > SubMenusTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const SubMenusSequence&
      subMenus () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      SubMenusSequence&
      subMenus ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      subMenus (const SubMenusSequence& s);

      //@}

      /**
       * @name commandIds
       *
       * @brief Accessor and modifier functions for the %commandIds
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::UnsignedLong CommandIdsType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< CommandIdsType > CommandIdsSequence;

      /**
       * @brief Element iterator type.
       */
      typedef CommandIdsSequence::iterator CommandIdsIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef CommandIdsSequence::const_iterator CommandIdsConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< CommandIdsType, char > CommandIdsTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const CommandIdsSequence&
      commandIds () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      CommandIdsSequence&
      commandIds ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      commandIds (const CommandIdsSequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      MenuNode (const IconType&,
                const TextType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      MenuNode (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      MenuNode (const MenuNode& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual MenuNode*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      MenuNode&
      operator= (const MenuNode& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~MenuNode ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< IconType > icon_;
      ::xsd::cxx::tree::one< TextType > text_;
      SubMenusSequence subMenus_;
      CommandIdsSequence commandIds_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %Gesture schema type.
     *
     * @nosubgrouping
     */
    class Gesture: public ::xml_schema::Type
    {
      public:
      /**
       * @name animationSeconds
       *
       * @brief Accessor and modifier functions for the %animationSeconds
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::mnu::srl::DecPositive AnimationSecondsType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< AnimationSecondsType, char > AnimationSecondsTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const AnimationSecondsType&
      animationSeconds () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      AnimationSecondsType&
      animationSeconds ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      animationSeconds (const AnimationSecondsType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      animationSeconds (::std::unique_ptr< AnimationSecondsType > p);

      /**
       * @brief Return the default value for the element.
       *
       * @return The element's default value.
       */
      static AnimationSecondsType
      animationSeconds_default_value ();

      //@}

      /**
       * @name iconRadius
       *
       * @brief Accessor and modifier functions for the %iconRadius
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::Int IconRadiusType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< IconRadiusType, char > IconRadiusTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const IconRadiusType&
      iconRadius () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      IconRadiusType&
      iconRadius ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      iconRadius (const IconRadiusType& x);

      /**
       * @brief Return the default value for the element.
       *
       * @return The element's default value.
       */
      static IconRadiusType
      iconRadius_default_value ();

      //@}

      /**
       * @name includeAngle
       *
       * @brief Accessor and modifier functions for the %includeAngle
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::Int IncludeAngleType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< IncludeAngleType, char > IncludeAngleTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const IncludeAngleType&
      includeAngle () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      IncludeAngleType&
      includeAngle ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      includeAngle (const IncludeAngleType& x);

      /**
       * @brief Return the default value for the element.
       *
       * @return The element's default value.
       */
      static IncludeAngleType
      includeAngle_default_value ();

      //@}

      /**
       * @name spreadFactor
       *
       * @brief Accessor and modifier functions for the %spreadFactor
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::mnu::srl::DecPositive SpreadFactorType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< SpreadFactorType, char > SpreadFactorTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const SpreadFactorType&
      spreadFactor () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      SpreadFactorType&
      spreadFactor ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      spreadFactor (const SpreadFactorType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      spreadFactor (::std::unique_ptr< SpreadFactorType > p);

      /**
       * @brief Return the default value for the element.
       *
       * @return The element's default value.
       */
      static SpreadFactorType
      spreadFactor_default_value ();

      //@}

      /**
       * @name sprayFactor
       *
       * @brief Accessor and modifier functions for the %sprayFactor
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::mnu::srl::DecPositive SprayFactorType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< SprayFactorType, char > SprayFactorTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const SprayFactorType&
      sprayFactor () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      SprayFactorType&
      sprayFactor ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      sprayFactor (const SprayFactorType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      sprayFactor (::std::unique_ptr< SprayFactorType > p);

      /**
       * @brief Return the default value for the element.
       *
       * @return The element's default value.
       */
      static SprayFactorType
      sprayFactor_default_value ();

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      Gesture (const AnimationSecondsType&,
               const IconRadiusType&,
               const IncludeAngleType&,
               const SpreadFactorType&,
               const SprayFactorType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      Gesture (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Gesture (const Gesture& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual Gesture*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Gesture&
      operator= (const Gesture& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~Gesture ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< AnimationSecondsType > animationSeconds_;
      ::xsd::cxx::tree::one< IconRadiusType > iconRadius_;
      ::xsd::cxx::tree::one< IncludeAngleType > includeAngle_;
      ::xsd::cxx::tree::one< SpreadFactorType > spreadFactor_;
      ::xsd::cxx::tree::one< SprayFactorType > sprayFactor_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %MenuSettings schema type.
     *
     * @nosubgrouping
     */
    class MenuSettings: public ::xml_schema::Type
    {
      public:
      /**
       * @name gesture
       *
       * @brief Accessor and modifier functions for the %gesture
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::mnu::srl::Gesture GestureType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< GestureType, char > GestureTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const GestureType&
      gesture () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      GestureType&
      gesture ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      gesture (const GestureType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      gesture (::std::unique_ptr< GestureType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      MenuSettings (const GestureType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      MenuSettings (::std::unique_ptr< GestureType >);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      MenuSettings (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      MenuSettings (const MenuSettings& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual MenuSettings*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      MenuSettings&
      operator= (const MenuSettings& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~MenuSettings ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< GestureType > gesture_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %Cue schema type.
     *
     * @nosubgrouping
     */
    class Cue: public ::xml_schema::Type
    {
      public:
      /**
       * @name commands
       *
       * @brief Accessor and modifier functions for the %commands
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::mnu::srl::Command CommandsType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< CommandsType > CommandsSequence;

      /**
       * @brief Element iterator type.
       */
      typedef CommandsSequence::iterator CommandsIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef CommandsSequence::const_iterator CommandsConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< CommandsType, char > CommandsTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const CommandsSequence&
      commands () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      CommandsSequence&
      commands ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      commands (const CommandsSequence& s);

      //@}

      /**
       * @name toolbarSettings
       *
       * @brief Accessor and modifier functions for the %toolbarSettings
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::mnu::srl::ToolbarSettings ToolbarSettingsType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ToolbarSettingsType > ToolbarSettingsOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ToolbarSettingsType, char > ToolbarSettingsTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ToolbarSettingsOptional&
      toolbarSettings () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      ToolbarSettingsOptional&
      toolbarSettings ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      toolbarSettings (const ToolbarSettingsType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      toolbarSettings (const ToolbarSettingsOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      toolbarSettings (::std::unique_ptr< ToolbarSettingsType > p);

      //@}

      /**
       * @name toolbars
       *
       * @brief Accessor and modifier functions for the %toolbars
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::mnu::srl::Toolbar ToolbarsType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< ToolbarsType > ToolbarsSequence;

      /**
       * @brief Element iterator type.
       */
      typedef ToolbarsSequence::iterator ToolbarsIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef ToolbarsSequence::const_iterator ToolbarsConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ToolbarsType, char > ToolbarsTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const ToolbarsSequence&
      toolbars () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      ToolbarsSequence&
      toolbars ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      toolbars (const ToolbarsSequence& s);

      //@}

      /**
       * @name menuSettings
       *
       * @brief Accessor and modifier functions for the %menuSettings
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::mnu::srl::MenuSettings MenuSettingsType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< MenuSettingsType > MenuSettingsOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< MenuSettingsType, char > MenuSettingsTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const MenuSettingsOptional&
      menuSettings () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      MenuSettingsOptional&
      menuSettings ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      menuSettings (const MenuSettingsType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      menuSettings (const MenuSettingsOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      menuSettings (::std::unique_ptr< MenuSettingsType > p);

      //@}

      /**
       * @name gestureNode
       *
       * @brief Accessor and modifier functions for the %gestureNode
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::mnu::srl::MenuNode GestureNodeType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< GestureNodeType > GestureNodeOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< GestureNodeType, char > GestureNodeTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const GestureNodeOptional&
      gestureNode () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      GestureNodeOptional&
      gestureNode ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      gestureNode (const GestureNodeType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      gestureNode (const GestureNodeOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      gestureNode (::std::unique_ptr< GestureNodeType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      Cue ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      Cue (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Cue (const Cue& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual Cue*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Cue&
      operator= (const Cue& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~Cue ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      CommandsSequence commands_;
      ToolbarSettingsOptional toolbarSettings_;
      ToolbarsSequence toolbars_;
      MenuSettingsOptional menuSettings_;
      GestureNodeOptional gestureNode_;

      //@endcond
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace mnu
{
  namespace srl
  {
    /**
     * @name Parsing functions for the %cue document root.
     */
    //@{

    /**
     * @brief Parse a URI or a local file.
     *
     * @param uri A URI or a local file name.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function uses exceptions to report parsing errors.
     */
    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (const ::std::string& uri,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a URI or a local file with an error handler.
     *
     * @param uri A URI or a local file name.
     * @param eh An error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (const ::std::string& uri,
         ::xml_schema::ErrorHandler& eh,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a URI or a local file with a Xerces-C++ DOM error
     * handler.
     *
     * @param uri A URI or a local file name.
     * @param eh A Xerces-C++ DOM error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (const ::std::string& uri,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a standard input stream.
     *
     * @param is A standrad input stream.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function uses exceptions to report parsing errors.
     */
    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::std::istream& is,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a standard input stream with an error handler.
     *
     * @param is A standrad input stream.
     * @param eh An error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::std::istream& is,
         ::xml_schema::ErrorHandler& eh,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a standard input stream with a Xerces-C++ DOM error
     * handler.
     *
     * @param is A standrad input stream.
     * @param eh A Xerces-C++ DOM error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::std::istream& is,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a standard input stream with a resource id.
     *
     * @param is A standrad input stream.
     * @param id A resource id.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * The resource id is used to identify the document being parsed in
     * diagnostics as well as to resolve relative paths.
     *
     * This function uses exceptions to report parsing errors.
     */
    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::std::istream& is,
         const ::std::string& id,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a standard input stream with a resource id and an
     * error handler.
     *
     * @param is A standrad input stream.
     * @param id A resource id.
     * @param eh An error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * The resource id is used to identify the document being parsed in
     * diagnostics as well as to resolve relative paths.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::std::istream& is,
         const ::std::string& id,
         ::xml_schema::ErrorHandler& eh,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a standard input stream with a resource id and a
     * Xerces-C++ DOM error handler.
     *
     * @param is A standrad input stream.
     * @param id A resource id.
     * @param eh A Xerces-C++ DOM error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * The resource id is used to identify the document being parsed in
     * diagnostics as well as to resolve relative paths.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::std::istream& is,
         const ::std::string& id,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a Xerces-C++ input source.
     *
     * @param is A Xerces-C++ input source.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function uses exceptions to report parsing errors.
     */
    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::xercesc::InputSource& is,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a Xerces-C++ input source with an error handler.
     *
     * @param is A Xerces-C++ input source.
     * @param eh An error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::xercesc::InputSource& is,
         ::xml_schema::ErrorHandler& eh,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
     * error handler.
     *
     * @param is A Xerces-C++ input source.
     * @param eh A Xerces-C++ DOM error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::xercesc::InputSource& is,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a Xerces-C++ DOM document.
     *
     * @param d A Xerces-C++ DOM document.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     */
    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (const ::xercesc::DOMDocument& d,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    /**
     * @brief Parse a Xerces-C++ DOM document.
     *
     * @param d A pointer to the Xerces-C++ DOM document.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function is normally used together with the keep_dom and
     * own_dom parsing flags to assign ownership of the DOM document
     * to the object model.
     */
    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::Flags f = 0,
         const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    //@}
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace mnu
{
  namespace srl
  {
    void
    operator<< (::xercesc::DOMElement&, const DecPositive&);

    void
    operator<< (::xercesc::DOMAttr&, const DecPositive&);

    void
    operator<< (::xml_schema::ListStream&,
                const DecPositive&);

    void
    operator<< (::xercesc::DOMElement&, const Visual&);

    void
    operator<< (::xercesc::DOMElement&, const Command&);

    void
    operator<< (::xercesc::DOMElement&, const ToolbarEntry&);

    void
    operator<< (::xercesc::DOMElement&, const Toolbar&);

    void
    operator<< (::xercesc::DOMElement&, const IconSize&);

    void
    operator<< (::xercesc::DOMAttr&, const IconSize&);

    void
    operator<< (::xml_schema::ListStream&,
                const IconSize&);

    void
    operator<< (::xercesc::DOMElement&, const ToolbarSettings&);

    void
    operator<< (::xercesc::DOMElement&, const MenuNode&);

    void
    operator<< (::xercesc::DOMElement&, const Gesture&);

    void
    operator<< (::xercesc::DOMElement&, const MenuSettings&);

    void
    operator<< (::xercesc::DOMElement&, const Cue&);

    /**
     * @name Serialization functions for the %cue document root.
     */
    //@{

    /**
     * @brief Serialize to a standard output stream.
     *
     * @param os A standrad output stream.
     * @param x An object model to serialize.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function uses exceptions to report serialization errors.
     */
    void
    cue (::std::ostream& os,
         const ::mnu::srl::Cue& x, 
         const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::Flags f = 0);

    /**
     * @brief Serialize to a standard output stream with an error handler.
     *
     * @param os A standrad output stream.
     * @param x An object model to serialize.
     * @param eh An error handler.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function reports serialization errors by calling the error
     * handler.
     */
    void
    cue (::std::ostream& os,
         const ::mnu::srl::Cue& x, 
         ::xml_schema::ErrorHandler& eh,
         const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::Flags f = 0);

    /**
     * @brief Serialize to a standard output stream with a Xerces-C++ DOM
     * error handler.
     *
     * @param os A standrad output stream.
     * @param x An object model to serialize.
     * @param eh A Xerces-C++ DOM error handler.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function reports serialization errors by calling the error
     * handler.
     */
    void
    cue (::std::ostream& os,
         const ::mnu::srl::Cue& x, 
         ::xercesc::DOMErrorHandler& eh,
         const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::Flags f = 0);

    /**
     * @brief Serialize to a Xerces-C++ XML format target.
     *
     * @param ft A Xerces-C++ XML format target.
     * @param x An object model to serialize.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function uses exceptions to report serialization errors.
     */
    void
    cue (::xercesc::XMLFormatTarget& ft,
         const ::mnu::srl::Cue& x, 
         const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::Flags f = 0);

    /**
     * @brief Serialize to a Xerces-C++ XML format target with an error
     * handler.
     *
     * @param ft A Xerces-C++ XML format target.
     * @param x An object model to serialize.
     * @param eh An error handler.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function reports serialization errors by calling the error
     * handler.
     */
    void
    cue (::xercesc::XMLFormatTarget& ft,
         const ::mnu::srl::Cue& x, 
         ::xml_schema::ErrorHandler& eh,
         const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::Flags f = 0);

    /**
     * @brief Serialize to a Xerces-C++ XML format target with a
     * Xerces-C++ DOM error handler.
     *
     * @param ft A Xerces-C++ XML format target.
     * @param x An object model to serialize.
     * @param eh A Xerces-C++ DOM error handler.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function reports serialization errors by calling the error
     * handler.
     */
    void
    cue (::xercesc::XMLFormatTarget& ft,
         const ::mnu::srl::Cue& x, 
         ::xercesc::DOMErrorHandler& eh,
         const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::Flags f = 0);

    /**
     * @brief Serialize to an existing Xerces-C++ DOM document.
     *
     * @param d A Xerces-C++ DOM document.
     * @param x An object model to serialize.
     * @param f Serialization flags.
     *
     * Note that it is your responsibility to create the DOM document
     * with the correct root element as well as set the necessary
     * namespace mapping attributes.
     */
    void
    cue (::xercesc::DOMDocument& d,
         const ::mnu::srl::Cue& x,
         ::xml_schema::Flags f = 0);

    /**
     * @brief Serialize to a new Xerces-C++ DOM document.
     *
     * @param x An object model to serialize.
     * @param m A namespace information map.
     * @param f Serialization flags.
     * @return A pointer to the new Xerces-C++ DOM document.
     */
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    cue (const ::mnu::srl::Cue& x, 
         const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
         ::xml_schema::Flags f = 0);

    //@}
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // MNU_SRL_MNUSERIAL_H
