// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "mnuserial.h"

namespace mnu
{
  namespace srl
  {
    // DecPositive
    // 


    // Visual
    // 

    const Visual::IconOptional& Visual::
    icon () const
    {
      return this->icon_;
    }

    Visual::IconOptional& Visual::
    icon ()
    {
      return this->icon_;
    }

    void Visual::
    icon (const IconType& x)
    {
      this->icon_.set (x);
    }

    void Visual::
    icon (const IconOptional& x)
    {
      this->icon_ = x;
    }

    void Visual::
    icon (::std::unique_ptr< IconType > x)
    {
      this->icon_.set (std::move (x));
    }

    const Visual::IconTextOptional& Visual::
    iconText () const
    {
      return this->iconText_;
    }

    Visual::IconTextOptional& Visual::
    iconText ()
    {
      return this->iconText_;
    }

    void Visual::
    iconText (const IconTextType& x)
    {
      this->iconText_.set (x);
    }

    void Visual::
    iconText (const IconTextOptional& x)
    {
      this->iconText_ = x;
    }

    void Visual::
    iconText (::std::unique_ptr< IconTextType > x)
    {
      this->iconText_.set (std::move (x));
    }

    const Visual::StatusTextOptional& Visual::
    statusText () const
    {
      return this->statusText_;
    }

    Visual::StatusTextOptional& Visual::
    statusText ()
    {
      return this->statusText_;
    }

    void Visual::
    statusText (const StatusTextType& x)
    {
      this->statusText_.set (x);
    }

    void Visual::
    statusText (const StatusTextOptional& x)
    {
      this->statusText_ = x;
    }

    void Visual::
    statusText (::std::unique_ptr< StatusTextType > x)
    {
      this->statusText_.set (std::move (x));
    }

    const Visual::WhatThisTextOptional& Visual::
    whatThisText () const
    {
      return this->whatThisText_;
    }

    Visual::WhatThisTextOptional& Visual::
    whatThisText ()
    {
      return this->whatThisText_;
    }

    void Visual::
    whatThisText (const WhatThisTextType& x)
    {
      this->whatThisText_.set (x);
    }

    void Visual::
    whatThisText (const WhatThisTextOptional& x)
    {
      this->whatThisText_ = x;
    }

    void Visual::
    whatThisText (::std::unique_ptr< WhatThisTextType > x)
    {
      this->whatThisText_.set (std::move (x));
    }

    const Visual::ToolTipTextOptional& Visual::
    toolTipText () const
    {
      return this->toolTipText_;
    }

    Visual::ToolTipTextOptional& Visual::
    toolTipText ()
    {
      return this->toolTipText_;
    }

    void Visual::
    toolTipText (const ToolTipTextType& x)
    {
      this->toolTipText_.set (x);
    }

    void Visual::
    toolTipText (const ToolTipTextOptional& x)
    {
      this->toolTipText_ = x;
    }

    void Visual::
    toolTipText (::std::unique_ptr< ToolTipTextType > x)
    {
      this->toolTipText_.set (std::move (x));
    }


    // Command
    // 

    const Command::IdType& Command::
    id () const
    {
      return this->id_.get ();
    }

    Command::IdType& Command::
    id ()
    {
      return this->id_.get ();
    }

    void Command::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    const Command::VisualOptional& Command::
    visual () const
    {
      return this->visual_;
    }

    Command::VisualOptional& Command::
    visual ()
    {
      return this->visual_;
    }

    void Command::
    visual (const VisualType& x)
    {
      this->visual_.set (x);
    }

    void Command::
    visual (const VisualOptional& x)
    {
      this->visual_ = x;
    }

    void Command::
    visual (::std::unique_ptr< VisualType > x)
    {
      this->visual_.set (std::move (x));
    }


    // ToolbarEntry
    // 

    const ToolbarEntry::CommandIdsSequence& ToolbarEntry::
    commandIds () const
    {
      return this->commandIds_;
    }

    ToolbarEntry::CommandIdsSequence& ToolbarEntry::
    commandIds ()
    {
      return this->commandIds_;
    }

    void ToolbarEntry::
    commandIds (const CommandIdsSequence& s)
    {
      this->commandIds_ = s;
    }

    const ToolbarEntry::VisualOptional& ToolbarEntry::
    visual () const
    {
      return this->visual_;
    }

    ToolbarEntry::VisualOptional& ToolbarEntry::
    visual ()
    {
      return this->visual_;
    }

    void ToolbarEntry::
    visual (const VisualType& x)
    {
      this->visual_.set (x);
    }

    void ToolbarEntry::
    visual (const VisualOptional& x)
    {
      this->visual_ = x;
    }

    void ToolbarEntry::
    visual (::std::unique_ptr< VisualType > x)
    {
      this->visual_.set (std::move (x));
    }


    // Toolbar
    // 

    const Toolbar::IconType& Toolbar::
    icon () const
    {
      return this->icon_.get ();
    }

    Toolbar::IconType& Toolbar::
    icon ()
    {
      return this->icon_.get ();
    }

    void Toolbar::
    icon (const IconType& x)
    {
      this->icon_.set (x);
    }

    void Toolbar::
    icon (::std::unique_ptr< IconType > x)
    {
      this->icon_.set (std::move (x));
    }

    const Toolbar::TextType& Toolbar::
    text () const
    {
      return this->text_.get ();
    }

    Toolbar::TextType& Toolbar::
    text ()
    {
      return this->text_.get ();
    }

    void Toolbar::
    text (const TextType& x)
    {
      this->text_.set (x);
    }

    void Toolbar::
    text (::std::unique_ptr< TextType > x)
    {
      this->text_.set (std::move (x));
    }

    const Toolbar::EntriesSequence& Toolbar::
    entries () const
    {
      return this->entries_;
    }

    Toolbar::EntriesSequence& Toolbar::
    entries ()
    {
      return this->entries_;
    }

    void Toolbar::
    entries (const EntriesSequence& s)
    {
      this->entries_ = s;
    }


    // IconSize
    // 

    IconSize::
    IconSize (::xml_schema::Int v): ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (v)
    {
    }

    IconSize::
    IconSize (const IconSize& v,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (v, f, c)
    {
    }


    // ToolbarSettings
    // 

    const ToolbarSettings::ShowIconType& ToolbarSettings::
    showIcon () const
    {
      return this->showIcon_.get ();
    }

    ToolbarSettings::ShowIconType& ToolbarSettings::
    showIcon ()
    {
      return this->showIcon_.get ();
    }

    void ToolbarSettings::
    showIcon (const ShowIconType& x)
    {
      this->showIcon_.set (x);
    }

    const ToolbarSettings::ShowTextType& ToolbarSettings::
    showText () const
    {
      return this->showText_.get ();
    }

    ToolbarSettings::ShowTextType& ToolbarSettings::
    showText ()
    {
      return this->showText_.get ();
    }

    void ToolbarSettings::
    showText (const ShowTextType& x)
    {
      this->showText_.set (x);
    }

    const ToolbarSettings::IconSizeType& ToolbarSettings::
    iconSize () const
    {
      return this->iconSize_.get ();
    }

    ToolbarSettings::IconSizeType& ToolbarSettings::
    iconSize ()
    {
      return this->iconSize_.get ();
    }

    void ToolbarSettings::
    iconSize (const IconSizeType& x)
    {
      this->iconSize_.set (x);
    }

    void ToolbarSettings::
    iconSize (::std::unique_ptr< IconSizeType > x)
    {
      this->iconSize_.set (std::move (x));
    }


    // MenuNode
    // 

    const MenuNode::IconType& MenuNode::
    icon () const
    {
      return this->icon_.get ();
    }

    MenuNode::IconType& MenuNode::
    icon ()
    {
      return this->icon_.get ();
    }

    void MenuNode::
    icon (const IconType& x)
    {
      this->icon_.set (x);
    }

    void MenuNode::
    icon (::std::unique_ptr< IconType > x)
    {
      this->icon_.set (std::move (x));
    }

    const MenuNode::TextType& MenuNode::
    text () const
    {
      return this->text_.get ();
    }

    MenuNode::TextType& MenuNode::
    text ()
    {
      return this->text_.get ();
    }

    void MenuNode::
    text (const TextType& x)
    {
      this->text_.set (x);
    }

    void MenuNode::
    text (::std::unique_ptr< TextType > x)
    {
      this->text_.set (std::move (x));
    }

    const MenuNode::SubMenusSequence& MenuNode::
    subMenus () const
    {
      return this->subMenus_;
    }

    MenuNode::SubMenusSequence& MenuNode::
    subMenus ()
    {
      return this->subMenus_;
    }

    void MenuNode::
    subMenus (const SubMenusSequence& s)
    {
      this->subMenus_ = s;
    }

    const MenuNode::CommandIdsSequence& MenuNode::
    commandIds () const
    {
      return this->commandIds_;
    }

    MenuNode::CommandIdsSequence& MenuNode::
    commandIds ()
    {
      return this->commandIds_;
    }

    void MenuNode::
    commandIds (const CommandIdsSequence& s)
    {
      this->commandIds_ = s;
    }


    // Gesture
    // 

    const Gesture::AnimationSecondsType& Gesture::
    animationSeconds () const
    {
      return this->animationSeconds_.get ();
    }

    Gesture::AnimationSecondsType& Gesture::
    animationSeconds ()
    {
      return this->animationSeconds_.get ();
    }

    void Gesture::
    animationSeconds (const AnimationSecondsType& x)
    {
      this->animationSeconds_.set (x);
    }

    void Gesture::
    animationSeconds (::std::unique_ptr< AnimationSecondsType > x)
    {
      this->animationSeconds_.set (std::move (x));
    }

    Gesture::AnimationSecondsType Gesture::
    animationSeconds_default_value ()
    {
      return AnimationSecondsType (1.0);
    }

    const Gesture::IconRadiusType& Gesture::
    iconRadius () const
    {
      return this->iconRadius_.get ();
    }

    Gesture::IconRadiusType& Gesture::
    iconRadius ()
    {
      return this->iconRadius_.get ();
    }

    void Gesture::
    iconRadius (const IconRadiusType& x)
    {
      this->iconRadius_.set (x);
    }

    Gesture::IconRadiusType Gesture::
    iconRadius_default_value ()
    {
      return IconRadiusType (32);
    }

    const Gesture::IncludeAngleType& Gesture::
    includeAngle () const
    {
      return this->includeAngle_.get ();
    }

    Gesture::IncludeAngleType& Gesture::
    includeAngle ()
    {
      return this->includeAngle_.get ();
    }

    void Gesture::
    includeAngle (const IncludeAngleType& x)
    {
      this->includeAngle_.set (x);
    }

    Gesture::IncludeAngleType Gesture::
    includeAngle_default_value ()
    {
      return IncludeAngleType (90);
    }

    const Gesture::SpreadFactorType& Gesture::
    spreadFactor () const
    {
      return this->spreadFactor_.get ();
    }

    Gesture::SpreadFactorType& Gesture::
    spreadFactor ()
    {
      return this->spreadFactor_.get ();
    }

    void Gesture::
    spreadFactor (const SpreadFactorType& x)
    {
      this->spreadFactor_.set (x);
    }

    void Gesture::
    spreadFactor (::std::unique_ptr< SpreadFactorType > x)
    {
      this->spreadFactor_.set (std::move (x));
    }

    Gesture::SpreadFactorType Gesture::
    spreadFactor_default_value ()
    {
      return SpreadFactorType (.10);
    }

    const Gesture::SprayFactorType& Gesture::
    sprayFactor () const
    {
      return this->sprayFactor_.get ();
    }

    Gesture::SprayFactorType& Gesture::
    sprayFactor ()
    {
      return this->sprayFactor_.get ();
    }

    void Gesture::
    sprayFactor (const SprayFactorType& x)
    {
      this->sprayFactor_.set (x);
    }

    void Gesture::
    sprayFactor (::std::unique_ptr< SprayFactorType > x)
    {
      this->sprayFactor_.set (std::move (x));
    }

    Gesture::SprayFactorType Gesture::
    sprayFactor_default_value ()
    {
      return SprayFactorType (1.0);
    }


    // MenuSettings
    // 

    const MenuSettings::GestureType& MenuSettings::
    gesture () const
    {
      return this->gesture_.get ();
    }

    MenuSettings::GestureType& MenuSettings::
    gesture ()
    {
      return this->gesture_.get ();
    }

    void MenuSettings::
    gesture (const GestureType& x)
    {
      this->gesture_.set (x);
    }

    void MenuSettings::
    gesture (::std::unique_ptr< GestureType > x)
    {
      this->gesture_.set (std::move (x));
    }


    // Cue
    // 

    const Cue::CommandsSequence& Cue::
    commands () const
    {
      return this->commands_;
    }

    Cue::CommandsSequence& Cue::
    commands ()
    {
      return this->commands_;
    }

    void Cue::
    commands (const CommandsSequence& s)
    {
      this->commands_ = s;
    }

    const Cue::ToolbarSettingsOptional& Cue::
    toolbarSettings () const
    {
      return this->toolbarSettings_;
    }

    Cue::ToolbarSettingsOptional& Cue::
    toolbarSettings ()
    {
      return this->toolbarSettings_;
    }

    void Cue::
    toolbarSettings (const ToolbarSettingsType& x)
    {
      this->toolbarSettings_.set (x);
    }

    void Cue::
    toolbarSettings (const ToolbarSettingsOptional& x)
    {
      this->toolbarSettings_ = x;
    }

    void Cue::
    toolbarSettings (::std::unique_ptr< ToolbarSettingsType > x)
    {
      this->toolbarSettings_.set (std::move (x));
    }

    const Cue::ToolbarsSequence& Cue::
    toolbars () const
    {
      return this->toolbars_;
    }

    Cue::ToolbarsSequence& Cue::
    toolbars ()
    {
      return this->toolbars_;
    }

    void Cue::
    toolbars (const ToolbarsSequence& s)
    {
      this->toolbars_ = s;
    }

    const Cue::MenuSettingsOptional& Cue::
    menuSettings () const
    {
      return this->menuSettings_;
    }

    Cue::MenuSettingsOptional& Cue::
    menuSettings ()
    {
      return this->menuSettings_;
    }

    void Cue::
    menuSettings (const MenuSettingsType& x)
    {
      this->menuSettings_.set (x);
    }

    void Cue::
    menuSettings (const MenuSettingsOptional& x)
    {
      this->menuSettings_ = x;
    }

    void Cue::
    menuSettings (::std::unique_ptr< MenuSettingsType > x)
    {
      this->menuSettings_.set (std::move (x));
    }

    const Cue::GestureNodeOptional& Cue::
    gestureNode () const
    {
      return this->gestureNode_;
    }

    Cue::GestureNodeOptional& Cue::
    gestureNode ()
    {
      return this->gestureNode_;
    }

    void Cue::
    gestureNode (const GestureNodeType& x)
    {
      this->gestureNode_.set (x);
    }

    void Cue::
    gestureNode (const GestureNodeOptional& x)
    {
      this->gestureNode_ = x;
    }

    void Cue::
    gestureNode (::std::unique_ptr< GestureNodeType > x)
    {
      this->gestureNode_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace mnu
{
  namespace srl
  {
    // DecPositive
    //

    DecPositive::
    DecPositive (const ::xml_schema::Double& _xsd_Double_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (_xsd_Double_base)
    {
    }

    DecPositive::
    DecPositive (const DecPositive& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
    {
    }

    DecPositive::
    DecPositive (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
    {
    }

    DecPositive::
    DecPositive (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
    {
    }

    DecPositive::
    DecPositive (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
    {
    }

    DecPositive* DecPositive::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DecPositive (*this, f, c);
    }

    DecPositive::
    ~DecPositive ()
    {
    }

    // Visual
    //

    Visual::
    Visual ()
    : ::xml_schema::Type (),
      icon_ (this),
      iconText_ (this),
      statusText_ (this),
      whatThisText_ (this),
      toolTipText_ (this)
    {
    }

    Visual::
    Visual (const Visual& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      icon_ (x.icon_, f, this),
      iconText_ (x.iconText_, f, this),
      statusText_ (x.statusText_, f, this),
      whatThisText_ (x.whatThisText_, f, this),
      toolTipText_ (x.toolTipText_, f, this)
    {
    }

    Visual::
    Visual (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      icon_ (this),
      iconText_ (this),
      statusText_ (this),
      whatThisText_ (this),
      toolTipText_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Visual::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // icon
        //
        if (n.name () == "icon" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IconType > r (
            IconTraits::create (i, f, this));

          if (!this->icon_)
          {
            this->icon_.set (::std::move (r));
            continue;
          }
        }

        // iconText
        //
        if (n.name () == "iconText" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IconTextType > r (
            IconTextTraits::create (i, f, this));

          if (!this->iconText_)
          {
            this->iconText_.set (::std::move (r));
            continue;
          }
        }

        // statusText
        //
        if (n.name () == "statusText" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< StatusTextType > r (
            StatusTextTraits::create (i, f, this));

          if (!this->statusText_)
          {
            this->statusText_.set (::std::move (r));
            continue;
          }
        }

        // whatThisText
        //
        if (n.name () == "whatThisText" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< WhatThisTextType > r (
            WhatThisTextTraits::create (i, f, this));

          if (!this->whatThisText_)
          {
            this->whatThisText_.set (::std::move (r));
            continue;
          }
        }

        // toolTipText
        //
        if (n.name () == "toolTipText" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ToolTipTextType > r (
            ToolTipTextTraits::create (i, f, this));

          if (!this->toolTipText_)
          {
            this->toolTipText_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    Visual* Visual::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Visual (*this, f, c);
    }

    Visual& Visual::
    operator= (const Visual& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->icon_ = x.icon_;
        this->iconText_ = x.iconText_;
        this->statusText_ = x.statusText_;
        this->whatThisText_ = x.whatThisText_;
        this->toolTipText_ = x.toolTipText_;
      }

      return *this;
    }

    Visual::
    ~Visual ()
    {
    }

    // Command
    //

    Command::
    Command (const IdType& id)
    : ::xml_schema::Type (),
      id_ (id, this),
      visual_ (this)
    {
    }

    Command::
    Command (const Command& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this),
      visual_ (x.visual_, f, this)
    {
    }

    Command::
    Command (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this),
      visual_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Command::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // id
        //
        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          if (!id_.present ())
          {
            this->id_.set (IdTraits::create (i, f, this));
            continue;
          }
        }

        // visual
        //
        if (n.name () == "visual" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< VisualType > r (
            VisualTraits::create (i, f, this));

          if (!this->visual_)
          {
            this->visual_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "id",
          "");
      }
    }

    Command* Command::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Command (*this, f, c);
    }

    Command& Command::
    operator= (const Command& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
        this->visual_ = x.visual_;
      }

      return *this;
    }

    Command::
    ~Command ()
    {
    }

    // ToolbarEntry
    //

    ToolbarEntry::
    ToolbarEntry ()
    : ::xml_schema::Type (),
      commandIds_ (this),
      visual_ (this)
    {
    }

    ToolbarEntry::
    ToolbarEntry (const ToolbarEntry& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      commandIds_ (x.commandIds_, f, this),
      visual_ (x.visual_, f, this)
    {
    }

    ToolbarEntry::
    ToolbarEntry (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      commandIds_ (this),
      visual_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToolbarEntry::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // commandIds
        //
        if (n.name () == "commandIds" && n.namespace_ ().empty ())
        {
          this->commandIds_.push_back (CommandIdsTraits::create (i, f, this));
          continue;
        }

        // visual
        //
        if (n.name () == "visual" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< VisualType > r (
            VisualTraits::create (i, f, this));

          if (!this->visual_)
          {
            this->visual_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ToolbarEntry* ToolbarEntry::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ToolbarEntry (*this, f, c);
    }

    ToolbarEntry& ToolbarEntry::
    operator= (const ToolbarEntry& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->commandIds_ = x.commandIds_;
        this->visual_ = x.visual_;
      }

      return *this;
    }

    ToolbarEntry::
    ~ToolbarEntry ()
    {
    }

    // Toolbar
    //

    Toolbar::
    Toolbar (const IconType& icon,
             const TextType& text)
    : ::xml_schema::Type (),
      icon_ (icon, this),
      text_ (text, this),
      entries_ (this)
    {
    }

    Toolbar::
    Toolbar (const Toolbar& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      icon_ (x.icon_, f, this),
      text_ (x.text_, f, this),
      entries_ (x.entries_, f, this)
    {
    }

    Toolbar::
    Toolbar (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      icon_ (this),
      text_ (this),
      entries_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Toolbar::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // icon
        //
        if (n.name () == "icon" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IconType > r (
            IconTraits::create (i, f, this));

          if (!icon_.present ())
          {
            this->icon_.set (::std::move (r));
            continue;
          }
        }

        // text
        //
        if (n.name () == "text" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< TextType > r (
            TextTraits::create (i, f, this));

          if (!text_.present ())
          {
            this->text_.set (::std::move (r));
            continue;
          }
        }

        // entries
        //
        if (n.name () == "entries" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< EntriesType > r (
            EntriesTraits::create (i, f, this));

          this->entries_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      if (!icon_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "icon",
          "");
      }

      if (!text_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "text",
          "");
      }
    }

    Toolbar* Toolbar::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Toolbar (*this, f, c);
    }

    Toolbar& Toolbar::
    operator= (const Toolbar& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->icon_ = x.icon_;
        this->text_ = x.text_;
        this->entries_ = x.entries_;
      }

      return *this;
    }

    Toolbar::
    ~Toolbar ()
    {
    }

    // IconSize
    //

    IconSize::
    IconSize (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (e, f, c)
    {
    }

    IconSize::
    IconSize (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (a, f, c)
    {
    }

    IconSize::
    IconSize (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType > (s, e, f, c)
    {
    }

    IconSize* IconSize::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IconSize (*this, f, c);
    }

    // ToolbarSettings
    //

    ToolbarSettings::
    ToolbarSettings (const ShowIconType& showIcon,
                     const ShowTextType& showText,
                     const IconSizeType& iconSize)
    : ::xml_schema::Type (),
      showIcon_ (showIcon, this),
      showText_ (showText, this),
      iconSize_ (iconSize, this)
    {
    }

    ToolbarSettings::
    ToolbarSettings (const ToolbarSettings& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      showIcon_ (x.showIcon_, f, this),
      showText_ (x.showText_, f, this),
      iconSize_ (x.iconSize_, f, this)
    {
    }

    ToolbarSettings::
    ToolbarSettings (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      showIcon_ (this),
      showText_ (this),
      iconSize_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToolbarSettings::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // showIcon
        //
        if (n.name () == "showIcon" && n.namespace_ ().empty ())
        {
          if (!showIcon_.present ())
          {
            this->showIcon_.set (ShowIconTraits::create (i, f, this));
            continue;
          }
        }

        // showText
        //
        if (n.name () == "showText" && n.namespace_ ().empty ())
        {
          if (!showText_.present ())
          {
            this->showText_.set (ShowTextTraits::create (i, f, this));
            continue;
          }
        }

        // iconSize
        //
        if (n.name () == "iconSize" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IconSizeType > r (
            IconSizeTraits::create (i, f, this));

          if (!iconSize_.present ())
          {
            this->iconSize_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!showIcon_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "showIcon",
          "");
      }

      if (!showText_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "showText",
          "");
      }

      if (!iconSize_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "iconSize",
          "");
      }
    }

    ToolbarSettings* ToolbarSettings::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ToolbarSettings (*this, f, c);
    }

    ToolbarSettings& ToolbarSettings::
    operator= (const ToolbarSettings& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->showIcon_ = x.showIcon_;
        this->showText_ = x.showText_;
        this->iconSize_ = x.iconSize_;
      }

      return *this;
    }

    ToolbarSettings::
    ~ToolbarSettings ()
    {
    }

    // MenuNode
    //

    MenuNode::
    MenuNode (const IconType& icon,
              const TextType& text)
    : ::xml_schema::Type (),
      icon_ (icon, this),
      text_ (text, this),
      subMenus_ (this),
      commandIds_ (this)
    {
    }

    MenuNode::
    MenuNode (const MenuNode& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      icon_ (x.icon_, f, this),
      text_ (x.text_, f, this),
      subMenus_ (x.subMenus_, f, this),
      commandIds_ (x.commandIds_, f, this)
    {
    }

    MenuNode::
    MenuNode (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      icon_ (this),
      text_ (this),
      subMenus_ (this),
      commandIds_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MenuNode::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // icon
        //
        if (n.name () == "icon" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< IconType > r (
            IconTraits::create (i, f, this));

          if (!icon_.present ())
          {
            this->icon_.set (::std::move (r));
            continue;
          }
        }

        // text
        //
        if (n.name () == "text" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< TextType > r (
            TextTraits::create (i, f, this));

          if (!text_.present ())
          {
            this->text_.set (::std::move (r));
            continue;
          }
        }

        // subMenus
        //
        if (n.name () == "subMenus" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< SubMenusType > r (
            SubMenusTraits::create (i, f, this));

          this->subMenus_.push_back (::std::move (r));
          continue;
        }

        // commandIds
        //
        if (n.name () == "commandIds" && n.namespace_ ().empty ())
        {
          this->commandIds_.push_back (CommandIdsTraits::create (i, f, this));
          continue;
        }

        break;
      }

      if (!icon_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "icon",
          "");
      }

      if (!text_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "text",
          "");
      }
    }

    MenuNode* MenuNode::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class MenuNode (*this, f, c);
    }

    MenuNode& MenuNode::
    operator= (const MenuNode& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->icon_ = x.icon_;
        this->text_ = x.text_;
        this->subMenus_ = x.subMenus_;
        this->commandIds_ = x.commandIds_;
      }

      return *this;
    }

    MenuNode::
    ~MenuNode ()
    {
    }

    // Gesture
    //

    Gesture::
    Gesture (const AnimationSecondsType& animationSeconds,
             const IconRadiusType& iconRadius,
             const IncludeAngleType& includeAngle,
             const SpreadFactorType& spreadFactor,
             const SprayFactorType& sprayFactor)
    : ::xml_schema::Type (),
      animationSeconds_ (animationSeconds, this),
      iconRadius_ (iconRadius, this),
      includeAngle_ (includeAngle, this),
      spreadFactor_ (spreadFactor, this),
      sprayFactor_ (sprayFactor, this)
    {
    }

    Gesture::
    Gesture (const Gesture& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      animationSeconds_ (x.animationSeconds_, f, this),
      iconRadius_ (x.iconRadius_, f, this),
      includeAngle_ (x.includeAngle_, f, this),
      spreadFactor_ (x.spreadFactor_, f, this),
      sprayFactor_ (x.sprayFactor_, f, this)
    {
    }

    Gesture::
    Gesture (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      animationSeconds_ (this),
      iconRadius_ (this),
      includeAngle_ (this),
      spreadFactor_ (this),
      sprayFactor_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Gesture::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // animationSeconds
        //
        if (n.name () == "animationSeconds" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< AnimationSecondsType > r (
            AnimationSecondsTraits::create (i, f, this));

          if (!animationSeconds_.present ())
          {
            this->animationSeconds_.set (::std::move (r));
            continue;
          }
        }

        // iconRadius
        //
        if (n.name () == "iconRadius" && n.namespace_ ().empty ())
        {
          if (!iconRadius_.present ())
          {
            this->iconRadius_.set (IconRadiusTraits::create (i, f, this));
            continue;
          }
        }

        // includeAngle
        //
        if (n.name () == "includeAngle" && n.namespace_ ().empty ())
        {
          if (!includeAngle_.present ())
          {
            this->includeAngle_.set (IncludeAngleTraits::create (i, f, this));
            continue;
          }
        }

        // spreadFactor
        //
        if (n.name () == "spreadFactor" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< SpreadFactorType > r (
            SpreadFactorTraits::create (i, f, this));

          if (!spreadFactor_.present ())
          {
            this->spreadFactor_.set (::std::move (r));
            continue;
          }
        }

        // sprayFactor
        //
        if (n.name () == "sprayFactor" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< SprayFactorType > r (
            SprayFactorTraits::create (i, f, this));

          if (!sprayFactor_.present ())
          {
            this->sprayFactor_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!animationSeconds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "animationSeconds",
          "");
      }

      if (!iconRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "iconRadius",
          "");
      }

      if (!includeAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "includeAngle",
          "");
      }

      if (!spreadFactor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "spreadFactor",
          "");
      }

      if (!sprayFactor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "sprayFactor",
          "");
      }
    }

    Gesture* Gesture::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Gesture (*this, f, c);
    }

    Gesture& Gesture::
    operator= (const Gesture& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->animationSeconds_ = x.animationSeconds_;
        this->iconRadius_ = x.iconRadius_;
        this->includeAngle_ = x.includeAngle_;
        this->spreadFactor_ = x.spreadFactor_;
        this->sprayFactor_ = x.sprayFactor_;
      }

      return *this;
    }

    Gesture::
    ~Gesture ()
    {
    }

    // MenuSettings
    //

    MenuSettings::
    MenuSettings (const GestureType& gesture)
    : ::xml_schema::Type (),
      gesture_ (gesture, this)
    {
    }

    MenuSettings::
    MenuSettings (::std::unique_ptr< GestureType > gesture)
    : ::xml_schema::Type (),
      gesture_ (std::move (gesture), this)
    {
    }

    MenuSettings::
    MenuSettings (const MenuSettings& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      gesture_ (x.gesture_, f, this)
    {
    }

    MenuSettings::
    MenuSettings (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      gesture_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MenuSettings::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // gesture
        //
        if (n.name () == "gesture" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< GestureType > r (
            GestureTraits::create (i, f, this));

          if (!gesture_.present ())
          {
            this->gesture_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!gesture_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "gesture",
          "");
      }
    }

    MenuSettings* MenuSettings::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class MenuSettings (*this, f, c);
    }

    MenuSettings& MenuSettings::
    operator= (const MenuSettings& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->gesture_ = x.gesture_;
      }

      return *this;
    }

    MenuSettings::
    ~MenuSettings ()
    {
    }

    // Cue
    //

    Cue::
    Cue ()
    : ::xml_schema::Type (),
      commands_ (this),
      toolbarSettings_ (this),
      toolbars_ (this),
      menuSettings_ (this),
      gestureNode_ (this)
    {
    }

    Cue::
    Cue (const Cue& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      commands_ (x.commands_, f, this),
      toolbarSettings_ (x.toolbarSettings_, f, this),
      toolbars_ (x.toolbars_, f, this),
      menuSettings_ (x.menuSettings_, f, this),
      gestureNode_ (x.gestureNode_, f, this)
    {
    }

    Cue::
    Cue (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      commands_ (this),
      toolbarSettings_ (this),
      toolbars_ (this),
      menuSettings_ (this),
      gestureNode_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Cue::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // commands
        //
        if (n.name () == "commands" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< CommandsType > r (
            CommandsTraits::create (i, f, this));

          this->commands_.push_back (::std::move (r));
          continue;
        }

        // toolbarSettings
        //
        if (n.name () == "toolbarSettings" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ToolbarSettingsType > r (
            ToolbarSettingsTraits::create (i, f, this));

          if (!this->toolbarSettings_)
          {
            this->toolbarSettings_.set (::std::move (r));
            continue;
          }
        }

        // toolbars
        //
        if (n.name () == "toolbars" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< ToolbarsType > r (
            ToolbarsTraits::create (i, f, this));

          this->toolbars_.push_back (::std::move (r));
          continue;
        }

        // menuSettings
        //
        if (n.name () == "menuSettings" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< MenuSettingsType > r (
            MenuSettingsTraits::create (i, f, this));

          if (!this->menuSettings_)
          {
            this->menuSettings_.set (::std::move (r));
            continue;
          }
        }

        // gestureNode
        //
        if (n.name () == "gestureNode" && n.namespace_ ().empty ())
        {
          ::std::unique_ptr< GestureNodeType > r (
            GestureNodeTraits::create (i, f, this));

          if (!this->gestureNode_)
          {
            this->gestureNode_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    Cue* Cue::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Cue (*this, f, c);
    }

    Cue& Cue::
    operator= (const Cue& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->commands_ = x.commands_;
        this->toolbarSettings_ = x.toolbarSettings_;
        this->toolbars_ = x.toolbars_;
        this->menuSettings_ = x.menuSettings_;
        this->gestureNode_ = x.gestureNode_;
      }

      return *this;
    }

    Cue::
    ~Cue ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace mnu
{
  namespace srl
  {
    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (const ::std::string& u,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::mnu::srl::Cue > (
        ::mnu::srl::cue (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (const ::std::string& u,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::mnu::srl::Cue > (
        ::mnu::srl::cue (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::mnu::srl::Cue > (
        ::mnu::srl::cue (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::std::istream& is,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::mnu::srl::cue (isrc, f, p);
    }

    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::std::istream& is,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::mnu::srl::cue (isrc, h, f, p);
    }

    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::mnu::srl::cue (isrc, h, f, p);
    }

    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::mnu::srl::cue (isrc, f, p);
    }

    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::mnu::srl::cue (isrc, h, f, p);
    }

    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::mnu::srl::cue (isrc, h, f, p);
    }

    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::xercesc::InputSource& i,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::mnu::srl::Cue > (
        ::mnu::srl::cue (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::xercesc::InputSource& i,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::mnu::srl::Cue > (
        ::mnu::srl::cue (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::mnu::srl::Cue > (
        ::mnu::srl::cue (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (const ::xercesc::DOMDocument& doc,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::mnu::srl::Cue > (
          ::mnu::srl::cue (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "cue" &&
          n.namespace_ () == "http://www.cadseer.com/mnu/srl")
      {
        ::std::unique_ptr< ::mnu::srl::Cue > r (
          ::xsd::cxx::tree::traits< ::mnu::srl::Cue, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "cue",
        "http://www.cadseer.com/mnu/srl");
    }

    ::std::unique_ptr< ::mnu::srl::Cue >
    cue (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "cue" &&
          n.namespace_ () == "http://www.cadseer.com/mnu/srl")
      {
        ::std::unique_ptr< ::mnu::srl::Cue > r (
          ::xsd::cxx::tree::traits< ::mnu::srl::Cue, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "cue",
        "http://www.cadseer.com/mnu/srl");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace mnu
{
  namespace srl
  {
    void
    operator<< (::xercesc::DOMElement& e, const DecPositive& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DecPositive& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ >& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DecPositive& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ >& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const Visual& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // icon
      //
      if (i.icon ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "icon",
            e));

        s << *i.icon ();
      }

      // iconText
      //
      if (i.iconText ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "iconText",
            e));

        s << *i.iconText ();
      }

      // statusText
      //
      if (i.statusText ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "statusText",
            e));

        s << *i.statusText ();
      }

      // whatThisText
      //
      if (i.whatThisText ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "whatThisText",
            e));

        s << *i.whatThisText ();
      }

      // toolTipText
      //
      if (i.toolTipText ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "toolTipText",
            e));

        s << *i.toolTipText ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Command& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // id
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "id",
            e));

        s << i.id ();
      }

      // visual
      //
      if (i.visual ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "visual",
            e));

        s << *i.visual ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ToolbarEntry& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // commandIds
      //
      for (ToolbarEntry::CommandIdsConstIterator
           b (i.commandIds ().begin ()), n (i.commandIds ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "commandIds",
            e));

        s << *b;
      }

      // visual
      //
      if (i.visual ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "visual",
            e));

        s << *i.visual ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Toolbar& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // icon
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "icon",
            e));

        s << i.icon ();
      }

      // text
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "text",
            e));

        s << i.text ();
      }

      // entries
      //
      for (Toolbar::EntriesConstIterator
           b (i.entries ().begin ()), n (i.entries ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "entries",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IconSize& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const IconSize& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType >& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const IconSize& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Int, char, ::xml_schema::SimpleType >& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const ToolbarSettings& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // showIcon
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "showIcon",
            e));

        s << i.showIcon ();
      }

      // showText
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "showText",
            e));

        s << i.showText ();
      }

      // iconSize
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "iconSize",
            e));

        s << i.iconSize ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const MenuNode& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // icon
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "icon",
            e));

        s << i.icon ();
      }

      // text
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "text",
            e));

        s << i.text ();
      }

      // subMenus
      //
      for (MenuNode::SubMenusConstIterator
           b (i.subMenus ().begin ()), n (i.subMenus ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "subMenus",
            e));

        s << *b;
      }

      // commandIds
      //
      for (MenuNode::CommandIdsConstIterator
           b (i.commandIds ().begin ()), n (i.commandIds ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "commandIds",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Gesture& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // animationSeconds
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "animationSeconds",
            e));

        s << i.animationSeconds ();
      }

      // iconRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "iconRadius",
            e));

        s << i.iconRadius ();
      }

      // includeAngle
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "includeAngle",
            e));

        s << i.includeAngle ();
      }

      // spreadFactor
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "spreadFactor",
            e));

        s << i.spreadFactor ();
      }

      // sprayFactor
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "sprayFactor",
            e));

        s << i.sprayFactor ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const MenuSettings& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // gesture
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "gesture",
            e));

        s << i.gesture ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const Cue& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // commands
      //
      for (Cue::CommandsConstIterator
           b (i.commands ().begin ()), n (i.commands ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "commands",
            e));

        s << *b;
      }

      // toolbarSettings
      //
      if (i.toolbarSettings ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "toolbarSettings",
            e));

        s << *i.toolbarSettings ();
      }

      // toolbars
      //
      for (Cue::ToolbarsConstIterator
           b (i.toolbars ().begin ()), n (i.toolbars ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "toolbars",
            e));

        s << *b;
      }

      // menuSettings
      //
      if (i.menuSettings ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "menuSettings",
            e));

        s << *i.menuSettings ();
      }

      // gestureNode
      //
      if (i.gestureNode ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "gestureNode",
            e));

        s << *i.gestureNode ();
      }
    }

    void
    cue (::std::ostream& o,
         const ::mnu::srl::Cue& s,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::mnu::srl::cue (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    cue (::std::ostream& o,
         const ::mnu::srl::Cue& s,
         ::xml_schema::ErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::mnu::srl::cue (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    cue (::std::ostream& o,
         const ::mnu::srl::Cue& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::mnu::srl::cue (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    cue (::xercesc::XMLFormatTarget& t,
         const ::mnu::srl::Cue& s,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::mnu::srl::cue (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    cue (::xercesc::XMLFormatTarget& t,
         const ::mnu::srl::Cue& s,
         ::xml_schema::ErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::mnu::srl::cue (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    cue (::xercesc::XMLFormatTarget& t,
         const ::mnu::srl::Cue& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::mnu::srl::cue (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    cue (::xercesc::DOMDocument& d,
         const ::mnu::srl::Cue& s,
         ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "cue" &&
          n.namespace_ () == "http://www.cadseer.com/mnu/srl")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "cue",
          "http://www.cadseer.com/mnu/srl");
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    cue (const ::mnu::srl::Cue& s,
         const ::xml_schema::NamespaceInfomap& m,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "cue",
          "http://www.cadseer.com/mnu/srl",
          m, f));

      ::mnu::srl::cue (*d, s, f);
      return d;
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

